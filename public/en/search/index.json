[{"contents":"","link":"https://emurgo.io/en/blog/emurgo-to-partner-with-ergo-and-build-blockchain-based-decentralized-financial-solutions","permalink":"https://ergoplatform.org/en/news/2020_06_09/","subtitle":"EMURGO, a global blockchain solutions firm \u0026 a founding entity of the globally recognized Cardano protocol, announces today a strategic partnership with Ergo - a proof-of-work blockchain protocol built to be a platform for applications with a main focus on providing simple solutions for financial contracts with its UTXO-based smart contracts.","title":"EMURGO to Partner with Ergo and Build Blockchain-Based Decentralized Financial Solutions"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/","subtitle":null,"title":"Ergo"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.2.6","permalink":"https://ergoplatform.org/en/news/2020_05_31/","subtitle":"This release is fixing a problem from 3.2.5 with possibility of duplicate inputs for transaction assembler, see ( #1126 ) for details","title":"Ergo Mainnet 3.2.6 released"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.2.5","permalink":"https://ergoplatform.org/en/news/2020_05_26/","subtitle":"Support for offchain boxes spending ( #1032 ), downloading logic fix for the case when best full block is not on the best header-chain","title":"Ergo Mainnet 3.2.5 released"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.2.4","permalink":"https://ergoplatform.org/en/news/2020_05_18/","subtitle":"Build transaction with token burning (PR #1101), default transaction complexity limit raised to 250K (PR #1104) and fixes","title":"Ergo Mainnet 3.2.4 released"},{"contents":"","link":"https://eprint.iacr.org/2020/560.pdf","permalink":"https://ergoplatform.org/en/news/2020_05_15/","subtitle":"We present ZeroJoin, a practical privacy-enhancing protocol for blockchain transactions.","title":"ZeroJoin: Combining ZeroCoin and CoinJoin (Alexander Chepurnoy and Amitabh Saxena)"},{"contents":"We have three great new developments to announce to the Ergo community, all of which will boost our user base and decentralisation!\nWe have not just one but three outstanding developments for the Ergo ecosystem to announce! Together, these will make it easier than ever before to acquire, trade, store and spend ERG – and will open up a huge new potential community of users, developers and hodlers.\nCoinsbit listing and airdrop Firstly, ERG has been listed on Coinsbit: a major trading platform that enables fiat deposits and withdrawals via debit and credit card. Ergo will be listed in three pairs:\n ERG/BTC ERG/USDT ERG/USD  We anticipate this will bring new traders and liquidity to the currency. The Coinsbit Telegram group has around 120,000 members, so this is a great opportunity to welcome new people to the community.\nTo celebrate this landmark development and promote Ergo to new traders, we are holding a joint airdrop. The conditions are as follows:\n Join Ergo’s Telegram chat: https://t.me/ergoplatform Register on Coinsbit and complete KYC Send your Coinsbit username to @Coinsbit on Telegram Receive your 5 ERG airdrop!  The airdrop will run for just 10 days and is limited to the first 5,000 participants, so don’t delay!\nCypra wallet The second major development is that Ergo will be integrated with the Cypra wallet. This is a fantastic multi-currency desktop and mobile wallet. It’s secure, open-source and non-custodial – making it super easy and convenient to deal with your coins!\nCypra is designed to address the worst shortcomings of conventional wallets, exchanges and payment services. It enables users to spend their crypto on real-world purchases with minimal friction and the lowest crypto-to-fiat conversion fees.\nYou can find out more in Cypra’s one-page summary. Check it out, keep your ERG safe and user them in a variety of cool ways!\nErgo mining pool Lastly, we will have Ergo’s first censorhip resistant mining pool with collaterals!\nThis is a really interesting development, since Ergo includes protection against ordinary pools by design. This is a feature implemented to improve decentralisation and accessibility for smaller, regular miners.\nJason, the pool owner, has created a decentralised pool using a smart contract that ensures miners who connect to the pool get paid. This is an intriguing example of smart contracts being used to bypass or change the consensus of a platform. It’s DeFi and community participation in action.\nThere are plans to implement the Stratum protocol and efficient mining software after the pool launches.\nIf you’d like to find out more about the theory behind pool mining on Ergo, we have an academic paper that was presented at Financial Cryptography 2020.\nThat’s all for now – but stay tuned, because we have more developments on the way!\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_05_14_updates/","subtitle":null,"title":"Ergo update, 14 May 2020: New exchange, wallet and first mining pool with collaterals!"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_05_14_updates/","permalink":"https://ergoplatform.org/en/news/2020_05_14/","subtitle":"Integration with Cypra wallet, Coinsbit listing and censorhip resistant mining pool","title":"Ergo update, 14 May 2020: New exchange, wallet and first mining pool with collaterals!"},{"contents":"","link":"https://ergoplatform.org/en/hall_of_fame/","permalink":"https://ergoplatform.org/en/news/2020_05_13/","subtitle":"Ergo Platform moving towards being true community-driven Proof-of-Work cryptocurrency","title":"\"Team\" page is replaced with \"Hall of Fame\""},{"contents":"","link":"https://www.facebook.com/coinsbit.io.cr/posts/2308490386121520","permalink":"https://ergoplatform.org/en/news/2020_05_13_2/","subtitle":"We're happy to announce that Ergo ($ERG) is listed on Coinsbit Exchange","title":"Ergo ($ERG) is listed on Coinsbit Exchange"},{"contents":"","link":"https://bpsaa.vision/new-member-announcement-ergo","permalink":"https://ergoplatform.org/en/news/2020_05_13_3/","subtitle":"Ergo is a smart contracts and DeFi platform that offers powerful but safe smart contracts, with Sigma protocols enabling flexible, highly composable applications out of the box.","title":"Ergo joins BPSAA thinktank"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.2.3","permalink":"https://ergoplatform.org/en/news/2020_05_12/","subtitle":"Fixes and improvements. Details in the description of the release","title":"Ergo Platform Reference Client 3.2.3 released"},{"contents":"Ergo allows any user to run a full node with low resources – meaning you can help maintain the network with a device as simple as a Raspberry Pi.\nIn a previous post, we looked at Ergo’s SPV mode, which allows for secure, efficient mobile clients. This enables users to make transactions using almost any device.\nAt the other end of the scale, you might want to run a full node. If you’re a miner, this will require that you download the full blockchain, because you’ll need the whole UTXO (unspent outputs) set to mine new blocks. But you can still run a full node without that UTXO set – vastly reducing the specification and expense of the hardware needed.\nErgo blocks In Ergo, just like Bitcoin, Ethereum and other blockchains, blocks are broken into sections. In Bitcoin, there’s simply a block header and the transactions themselves. But in Ergo, we have some extra sections that enable new functionality:\n Header Transactions Extensions Proofs of UTXO transformation  The ‘extension’ section contains certain mandatory fields (including links for NiPoPoW, once per 1,024 block epoch) and parameters for miner voting, such as current block size. It can also contain arbitrary fields.\nWhat this means in practice is that different types of node and client can download only those sections of the blocks they need – reducing the demands for storage, bandwidth and CPU cycles.\nLite full nodes While miners need to download everything, lite full nodes only need the transactions and proofs. This means they have a cryptographic guarantee of transactions, without holding the full UTXO set itself.\nLite full nodes check the proofs generated by full nodes (including miners) who do hold the full blockchain, providing a guarantee of ledger validity. In Ethereum, these nodes are called Stateless Clients.\nFor Ergo, it means you can run a full node and maintain the network with a device as simple as a Raspberry Pi with 512 MB RAM. This provides the ideal balance between ensuring the security of the network and placing an unnecessary burden on users who wish to do so – improving decentralisation and democratising participation in the Ergo network and community.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_05_08_lite_full_nodes/","subtitle":null,"title":"Building Ergo: Lite full nodes"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_05_08_lite_full_nodes/","permalink":"https://ergoplatform.org/en/news/2020_05_08/","subtitle":"The extension section contains certain mandatory fields including links for NiPoPoW and parameters for miner voting, such as current block size.","title":"Building Ergo: Lite full nodes"},{"contents":"Stablecoins are a major use case for DeFi but come in various different forms. The stablecoin space is still relatively young and underserved – but that’s changing fast.\nStablecoins are one of the most important and popular DeFi products, enabling users to hedge and store value on the blockchain, without having to use exchanges or other centralised providers.\nAs a smart contracts and DeFi platform, Ergo is well suited for building all kinds of dApps, including stablecoins. You’ll certainly be hearing more from us in the future about a stablecoin on the Ergo blockchain, but until then, we want to introduce and unpack the idea as context for what’s coming.\nDifferent stablecoin approaches There are various ways to peg a crypto token to the dollar or another fiat currency. The easiest way is to hold dollars in a bank account, and issue one token for every dollar you have. This is exactly the approach that Tether (USDT) takes. This offers users the ability to store and transfer USD easily, without using an exchange. However, this approach is still highly centralised; you have to trust Tether that they have enough dollars in their bank account to cover the issued tokens. Tether is well known for being opaque and refusing proper audits. The token could also be shut down if a regulator managed to freeze their accounts.\nThere are various backed stablecoins on the market, which take broadly the same approach. Tokens like USDC and Gemini dollars are much the same, but they are far more transparent, and operate within a clear regulatory framework. Then there are projects like TrustToken, which underpins the TrueUSD token (TUSD); this is much the same again, though takes a more distributed approach, with both a high degree of transparency and multiple banking partners.\nAll of these necessarily have a degree of centralisation and risk, because they rely on banking partners – and those accounts can potentially be frozen, shut down or even raided.\nOther projects – notably the Maker Protocol – attempt to address this with a fully decentralised model. Maker’s Dai is an algorithmic stablecoin: a ‘synthetic’ dollar that is not backed by real dollars as USDT, USDC and other stablecoins are.\nDai are issued from ‘Vaults’ backed by crypto collateral (mostly ETH). A system of smart contracts and oracles (decentralised price feeds) ensures that every Dai issued is collateralised by at least $1.50; if the ratio falls too low, the Vault is closed and the Dai repurchased automatically. It’s a complex and impressive system, and the largest project in the DeFi space.\nSome stablecoins are more stable than others Stablecoins have been around since at least 2014, though the first attempts had limited success. The earliest algorithmic coins, like NuBits and BitUSD, did not have the benefit of smart contracts platforms (which were only available with the launch of Ethereum in 2015). They tended to be centralised or semi-centralised, and didn’t work well in practice. (NuBits, for example, lost its peg and has completely collapsed.)\nTether, which has been around since 2014, has grown into a multi-billion-dollar phenomenon, with tens of billions of dollars of daily volumes. However, while Tether generally keeps its peg pretty well, occasional quirks of the market and fears about the company’s reserves mean it has not always been worth $1 (once dropping as low as $0.90). USDC, which is more trustworthy and transparent, tends to have lower spreads and a more reliable peg.\nMeanwhile Dai, as the foremost algorithmic stablecoin, has historically done well. It aims to maintain a ‘soft’ peg, with decentralised monetary policy nudging it back towards $1 if market conditions push it too far away from this. This has generally been successful; the only time prices have deviated significantly was on the enormous market volatility of ‘Black Thursday’ in March, which saw a massive sell-off of almost every fiat and crypto asset.\nAlgo, collateralised, back or a combination? And so the existing stablecoins take one or more of several approaches to keeping the token pegged to the dollar. The simplest, but also the most centralised, is to back the token with actual dollars. You can also back it with crypto, so long as you ensure there is enough collateral to cover the tokens issued in the event of market volatility. Algorithmic stablecoins use price feeds and decentralised monetary policy to make it more or less attractive to buy or sell the tokens, helping to ensure the price gravitates towards $1.\nEvery approach has its strengths and weaknesses. Ergo will be announcing details of its own implementations in the coming weeks, and explaining why its developers are taking the approach they are.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_05_05_stablecoins/","subtitle":null,"title":"Introduction to stablecoins"},{"contents":"There’s often a tension in the crypto world between security and convenience. That trade-off is unacceptable if we want these technologies to be widely used. Here’s how Ergo addresses one common and very important issue.\nWe all know that the most secure way to use Bitcoin, or any crypto, is to download a copy of the blockchain and run a full node yourself. That way, every time you or anyone else makes a transaction, your client checks the blockchain to ensure it’s valid. You don’t have to trust anyone else.\nA full Bitcoin node checks all the blocks in the blockchain (using headers) and makes sure there are no fraudulent transactions. It’s a very secure way of using crypto – but there’s a problem. It requires significant bandwidth, storage and processing power. That kind of commodity hardware is expensive, and using a full node to validate and make transactions is in any case unsuitable for mobile devices. This is particularly true for Bitcoin, where the blockchain is over 270 GB and counting.\nSPV Simplified Payment Verification (SPV) is designed to address this problem, as described in the Bitcoin white paper:\n It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it's timestamped in. He can't check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accepted it.  Satoshi notes that this is not a perfect solution, and is vulnerable to an attacker overpowering the network and fooling SPV users.\nMoreover, while SPV mode is intended for resource-limited devices, even this ‘lite’ approach is not always feasible. Ethereum’s headers alone total around 5 GB to download. Thus Ethereum mobile clients do not validate chain validity and so blindly have to trust third parties.\nThere are proposals to reduce the requirements for SPV mode by checking just a few random headers, instead of all of them. But it’s hard to do that securely.\nEfficient SPV Several years have been spent researching and developing secure protocols that allow for efficient SPV clients. The two best-known and most reliable protocols are NiPoPoWs and FlyClient.\nErgo implements NiPoPoWs, or Non-interactive Proof-of-Proof-of-Work. This technology can be explored in full on this dedicated website: https://nipopows.com:\n  Non-Interactive Proofs of Proof-of-Work (NIPoPoWs) are short stand-alone strings that a computer program can inspect to verify that an event happened on a proof-of-work-based blockchain without connecting to the blockchain network and without downloading all block headers. For example, these proofs can illustrate that a cryptocurrency payment was made.\n  NIPoPoWs allow very efficient mobile wallets to be created. SPV wallets are already very lightweight compared to full nodes because they only require the download of block headers, not the whole blockchain. NIPoPoW wallets need to download only a small sample of block headers, around 250, when SPV clients need to download half a million block headers. The sample needed changes but doesn't grow much in size as the blockchain grows larger by the years, even after decades of data has been accumulated.\n  This enables us to build a mobile SPV client that requires around just 100KB of block headers to be downloaded.\nA super-efficient Ergo wallet with SPV security is in development, so stay tuned for more updates!\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_05_1_spv_security/","subtitle":null,"title":"Building Ergo: SPV security"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_05_1_spv_security/","permalink":"https://ergoplatform.org/en/news/2020_05_01/","subtitle":"Ergo implements NiPoPoWs, or Non-interactive Proof-of-Proof-of-Work. This technology can be explored in full on this dedicated website: https://nipopows.com/","title":"Building Ergo: SPV security "},{"contents":" With thanks to Robert Kornacki for polishing of the draft.\n Introduction ErgoScript is the smart contract language used by the Ergo blockchain. While it has concise syntax adopted from Scala/Kotlin, it still may seem confusing at first because conceptually ErgoScript is quite different compared to conventional languages which we all know and love. This is because Ergo is a UTXO based blockchain, whereas smart contracts are traditionally associated with account based systems like Ethereum. However, Ergo's transaction model has many advantages over the account based model and with the right approach it can even be significantly easier to develop Ergo contracts than to write and debug Solidity code.\nBelow we will cover the key aspects of the Ergo contract model which makes it different:\nParadigm The account model of Ethereum is imperative. This means that the typical task of sending coins from Alice to Bob requires changing the balances in storage as a series of operations. Ergo's UTXO based programming model on the other hand is declarative. ErgoScript contracts specify conditions for a transaction to be accepted by the blockchain (not changes to be made in the storage state as result of the contract execution).\nScalability In the account model of Ethereum both storage changes and validity checks are performed on-chain during code execution. In contrast, Ergo transactions are created off-chain and only validation checks are performed on-chain thus reducing the amount of operations performed by every node on the network. In addition, due to immutability of the transaction graph, various optimization strategies are possible to improve throughput of transactions per second in the network. Light verifying nodes are also possible thus further facilitating scalability and accessibility of the network.\nShared state The account-based model is reliant on shared mutable state which is known to lead to complex semantics (and subtle million dollar bugs) in the context of concurrent/ distributed computation. Ergo's model is based on an immutable graph of transactions. This approach, inherited from Bitcoin, plays well with the concurrent and distributed nature of blockchains and facilitates light trustless clients.\nExpressive Power Ethereum advocated execution of a turing-complete language on the blockchain. It theoretically promised unlimited potential, however in practice severe limitations came to light from excessive blockchain bloat, subtle multi-million dollar bugs, gas costs which limit contract complexity, and other such problems. Ergo on the flip side extends UTXO to enable turing-completeness while limiting the complexity of the ErgoScript language itself. The same expressive power is achieved in a different and more semantically sound way.\nWith the all of the above points, it should be clear that there are a lot of benefits to the model Ergo is using. In the rest of this article I will introduce you to the concept of FlowCards - a dApp developer component which allows for designing complex Ergo contracts in a declarative and visual way.\nFrom Imperative to Declarative In the imperative programming model of Ethereum a transaction is a sequence of operations executed by the Ethereum VM. The following Solidity function implements a transfer of tokens from sender to receiver. The transaction starts when sender calls this function on an instance of a contract and ends when the function returns.\n// Sends an amount of existing coins from any caller to an address function send(address receiver, uint amount) public { require(amount \u0026lt;= balances[msg.sender], \u0026#34;Insufficient balance.\u0026#34;); balances[msg.sender] -= amount; balances[receiver] += amount; emit Sent(msg.sender, receiver, amount); } The function first checks the pre-conditions, then updates the storage (i.e. balances) and finally publishes the post-condition as the Sent event. The gas which is consumed by the transaction is sent to the miner as a reward for executing this transaction.\nUnlike Ethereum, a transaction in Ergo is a data structure holding a list of input coins which it spends and a list of output coins which it creates preserving the total balances of ERGs and tokens (in which Ergo is similar to Bitcoin).\nTurning back to the example above, since Ergo natively supports tokens, therefore for this specific example of sending tokens we don't need to write any code in ErgoScript. Instead we need to create the \u0026lsquo;send\u0026rsquo; transaction shown in the following figure, which describes the same token transfer but declaratively.\nThe picture visually describes the following steps, which the network user needs to perform:\n Select unspent sender's boxes, containing in total tB \u0026gt;= amount of tokens and B \u0026gt;= txFee + minErg ERGs. Create an output target box which is protected by the receiver public key with minErg ERGs and amount of T tokens. Create one fee output protected by the minerFee contract with txFee ERGs. Create one change output protected by the sender public key, containing B - minErg - txFee ERGs and tB - amount of T tokens. Create a new transaction, sign it using the sender's secret key and send to the Ergo network.  What is important to understand here is that all of these steps are preformed off-chain (for example using Appkit Transaction API) by the user's application. Ergo network nodes don't need to repeat this transaction creation process, they only need to validate the already formed transaction. ErgoScript contracts are stored in the inputs of the transaction and check spending conditions. The node executes the contracts on-chain when the transaction is validated. The transaction is valid if all of the conditions are satisfied.\nThus, in Ethereum when we \u0026ldquo;send amount from sender to recipient\u0026rdquo; we are literally editing balances and updating the storage with a concrete set of commands. This happens on-chain and thus a new transaction is also created on-chain as the result of this process.\nIn Ergo (as in Bitcoin) transactions are created off-chain and the network nodes only verify them. The effects of the transaction on the blockchain state is that input coins (or Boxes in Ergo's parlance) are removed and output boxes are added to the UTXO set.\nIn the example above we don't use an ErgoScript contract but instead assume a signature check is used as the spending pre-condition. However in more complex application scenarios we of course need to use ErgoScript which is what we are going to discuss next.\nFrom Changing State to Checking Context In the send function example we first checked the pre-condition (require(amount \u0026lt;= balances[msg.sender],...)) and then changed the state (i.e. update balances balances[msg.sender] -= amount). This is typical in Ethereum transactions. Before we change anything we need to check if it is valid to do so.\nIn Ergo, as we discussed previously, the state (i.e. UTXO set of boxes) is changed implicitly when a valid transaction is included in a block. Thus we only need to check the pre-conditions before the transaction can be added to the block. This is what ErgoScript contracts do.\nIt is not possible to \u0026ldquo;change the state\u0026rdquo; in ErgoScript because it is a language to check pre-conditions for spending coins. ErgoScript is a purely functional language without side effects that operates on immutable data values. This means all the inputs, outputs and other transaction parameters available in a script are immutable. This, among other things, makes ErgoScript a very simple language that is easy to learn and safe to use. Similar to Bitcoin, each input box contains a script, which should return the true value in order to 1) allow spending of the box (i.e. removing from the UTXO set) and 2) adding the transaction to the block.\nIf we are being pedantic, it is therefore incorrect (strictly speaking) to think of ErgoScript as the language of Ergo contracts, because it is the language of propositions (logical predicates, formulas, etc.) which protect boxes from \u0026ldquo;illegal\u0026rdquo; spending. Unlike Bitcoin, in Ergo the whole transaction and a part of the current blockchain context is available to every script. Therefore each script may check which outputs are created by the transaction, their ERG and token amounts (we will use this capability in our example DEX contracts), current block number etc.\nIn ErgoScript you define the conditions of whether changes (i.e. coin spending) are allowed to happen in a given context. This is in contrast to programming the changes imperatively in the code of a contract.\nWhile Ergo's transaction model unlocks a whole range of applications like (DEX, DeFi Apps, LETS, etc), designing contracts as pre-conditions for coin spending (or guarding scripts) directly is not intuitive. In the next sections we will consider a useful graphical notation to design contracts declaratively using FlowCard Diagrams, which is a visual representation of executable components (FlowCards).\nFlowCards aim to radically simplify dApp development on the Ergo platform by providing a high-level declarative language, execution runtime, storage format and a graphical notation.\nWe will start with a high level of diagrams and go down to FlowCard specification.\nFlowCard Diagrams The idea behind FlowCard diagrams is based on the following observations: 1) An Ergo box is immutable and can only be spent in the transaction which uses it as an input. 2) We therefore can draw a flow of boxes through transactions, so that boxes flowing in to the transaction are spent and those flowing out are created and added to the UTXO. 3) A transaction from this perspective is simply a transformer of old boxes to the new ones preserving the balances of ERGs and tokens involved.\nThe following figure shows the main elements of the Ergo transaction we've already seen previously (now under the name of FlowCard Diagram).\nThere is a strictly defined meaning (semantics) behind every element of the diagram, so that the diagram is a visual representation (or a view) of the underlying executable component (called FlowCard).\nThe FlowCard can be used as a reusable component of an Ergo dApp to create and initiate the transaction on the Ergo blockchain. We will discuss this in the coming sections.\nNow let's look at the individual pieces of the FlowCard diagram one by one.\n1. Name and Parameters Each flow card is given a name and a list of typed parameters. This is similar to a template with parameters. In the above figure we can see the Send flow card which has five parameters. The parameters are used in the specification.\n2. Contract Wallet This is a key element of the flow card. Every box has a guarding script. Often it is the script that checks a signature against a public key. This script is trivial in ErgoScript and is defined like the def pk(pubkey: Address) = { pubkey } template where pubkey is a parameter of the type Address. In the figure, the script template is applied to the parameter pk(sender) and thus a concrete wallet contract is obtained. Therefore pk(sender) and pk(receiver) yield different scripts and represent different wallets on the diagram, even though they use the same template.\nContract Wallet contains a set of all UTXO boxes which have a given script derived from the given script template using flow card parameters. For example, in the figure, the template is pk and parameter pubkey is substituted with the `sender\u0026rsquo; flow card parameter.\n3. Contract Even though a contract is a property of a box, on the diagram we group the boxes by their contracts, therefore it looks like the boxes belong to the contracts, rather than the contracts belong to the boxes. In the example, we have three instantiated contracts pk(sender), pk(receiver) and minerFee. Note, that pk(sender) is the instantiation of the pk template with the concrete parameter sender and minerFee is the instantiation of the pre-defined contract which protects the miner reward boxes.\n4. Box name In the diagram we can give each box a name. Besides readability of the diagram, we also use the name as a synonym of a more complex indexed access to the box in the contract. For example, change is the name of the box, which can also be used in the ErgoScript conditions instead of OUTPUTS(2). We also use box names to associate spending conditions with the boxes.\n5. Boxes in the wallet In the diagram, we show boxes (darker rectangles) as belonging to the contract wallets (lighter rectangles). Each such box rectangle is connected with a grey transaction rectangle by either orange or green arrows or both. An output box (with an incoming green arrow) may include many lines of text where each line specifies a condition which should be checked as part of the transaction. The first line specifies the condition on the amount of ERG which should be placed in the box. Other lines may take one of the following forms:\n amount: TOKEN - the box should contain the given amount of the given TOKEN R == value - the box should contain the given value of the given register R boxName ? condition - the box named boxName should check condition in its script.  We discuss these conditions in the sections below.\n6. Amount of ERGs in the box Each box should store a minimum amount of ERGs. This is checked when the creating transaction is validated. In the diagram the amount of ERGs is always shown as the first line (e.g. B: ERG or B - minErg - txFee). The value type ascription B: ERG is optional and may be used for readability. When the value is given as a formula, then this formula should be respected by the transaction which creates the box.\nIt is important to understand that variables like amount and txFee are not named properties of the boxes. They are parameters of the whole diagram and representing some amounts. Or put it another way, they are shared parameters between transactions (e.g. Sell Order and Swap transactions from DEX example below share the tAmt parameter). So the same name is tied to the same value throughout the diagram (this is where the tooling would help a lot). However, when it comes to on-chain validation of those values, only explicit conditions which are marked with ? are transformed to ErgoScript. At the same time, all other conditions are ensured off-chain during transaction building (for example in an application using Appkit API) and transaction validation when it is added to the blockchain.\n7. Amount of T token A box can store values of many tokens. The tokens on the diagram are named and a value variable may be associated with the token T using value: T expression. The value may be given by formula. If the formula is prefixed with a box name like boxName ? formula, then it is should also be checked in the guarding script of the boxName box. This additional specification is very convenient because 1) it allows to validate the visual design automatically, and 2) the conditions specified in the boxes of a diagram are enough to synthesize the necessary guarding scripts. (more about this below at \u0026ldquo;From Diagrams To ErgoScript Contracts\u0026rdquo;)\n8. Tx Inputs Inputs are connected to the corresponding transaction by orange arrows. An input arrow may have a label of the following forms:\n name@index - optional name with an index i.e. fee@0 or @2. This is a property of the target endpoint of the arrow. The name is used in conditions of related boxes and the index is the position of the corresponding box in the INPUTS collection of the transaction. !action - is a property of the source of the arrow and gives a name for an alternative spending path of the box (we will see this in DEX example)  Because of alternative spending paths, a box may have many outgoing orange arrows, in which case they should be labeled with different actions.\n9. Transaction A transaction spends input boxes and creates output boxes. The input boxes are given by the orange arrows and the labels are expected to put inputs at the right indexes in INPUTS collection. The output boxes are given by the green arrows. Each transaction should preserve a strict balance of ERG values (sum of inputs == sum of outputs) and for each token the sum of inputs \u0026gt;= the sum of outputs. The design diagram requires an explicit specification of the ERG and token values for all of the output boxes to avoid implicit errors and ensure better readability.\n10. Tx Outputs Outputs are connected to the corresponding transaction by green arrows. An output arrow may have a label of the following formname@index, where an optional name is accompanied with an index i.e. fee@0 or @2. This is a property of the source endpoint of the arrow. The name is used in conditions of the related boxes and the index is the position of the corresponding box in the OUTPUTS collection of the transaction.\nExample: Decentralized Exchange (DEX) Now let's use the above described notation to design a FlowCard for a DEX dApp. It is simple enough yet also illustrates all of the key features of FlowCard diagrams which we've introduced in the previous section.\nThe dApp scenario is shown in the figure below:\nThere are three participants (buyer, seller and DEX) of the DEX dApp and five different transaction types, which are created by participants. The buyer wants to swap ergAmt of ERGs for tAmt of TID tokens (or vice versa, the seller wants to sell TID tokens for ERGs, who sends the order first doesn't matter). Both the buyer and the seller can cancel their orders any time. The DEX off-chain matching service can find matching orders and create the Swap transaction to complete the exchange.\nThe following diagram fully (and formally) specifies all of the five transactions that must be created off-chain by the DEX dApp. It also specifies all of the spending conditions that should be verified on-chain.\nLet's discuss the FlowCard diagram and the logic of each transaction in details:\nBuy Order Transaction A buyer creates a Buy Order transaction. The transaction spends E amount of ERGs (which we will write E: ERG) from one or more boxes in the pk(buyer) wallet. The transaction creates a bid box with ergAmt: ERG protected by the buyOrder script. The buyOrder script is synthesized from the specification (see below at \u0026ldquo;From Diagrams To ErgoScript Contracts\u0026rdquo;) either manually or automatically by a tool. Even though we don't need to define the buyOrder script explicitly during designing, at run time the bid box should contain the buyOrder script as the guarding proposition (which checks the box spending conditions), otherwise the conditions specified in the diagram will not be checked.\nThe change box is created to make the input and output sums of the transaction balanced. The transaction fee box is omitted because it can be added automatically by the tools. In practice, however, the designer can add the fee box explicitly to the a diagram. It covers the cases of more complex transactions (like Swap) where there are many ways to pay the transaction fee.\nCancel Buy, Cancel Sell Transactions At any time, the buyer can cancel the order by sending CancelBuy transaction. The transaction should satisfy the guarding buyOrder contract which protects the bid box. As you can see on the diagram, both the Cancel and the Swap transactions can spend the bid box. When a box has spending alternatives (or spending paths) then each alternative is identified by a unique name prefixed with ! (!cancel and !swap for the bid box). Each alternative path has specific spending conditions. In our example, when the Cancel Buy transaction spends the bid box the ?buyer condition should be satisfied, which we read as \u0026ldquo;the signature for the buyer address should be presented in the transaction\u0026rdquo;. Therefore, only buyer can cancel the buy order. This \u0026ldquo;signature\u0026rdquo; condition is only required for the !cancel alternative spending path and not required for !swap.\nSell Order Transaction The Sell Order transaction is similar to the BuyOrder in that it deals with tokens in addition to ERGs. The transaction spends E: ERG and T: TID tokens from seller's wallet (specified as pk(seller) contract). The two outputs are ask and change. The change is a standard box to balance transaction. The ask box keeps tAmt: TID tokens for the exchange and minErg: ERG - the minimum amount of ERGs required in every box.\nSwap Transaction This is a key transaction in the DEX dApp scenario. The transaction has several spending conditions on the input boxes and those conditions are included in the buyOrder and sellOrder scripts (which are verified when the transaction is added to the blockchain). However, on the diagram those conditions are not specified in the bid and ask boxes, they are instead defined in the output boxes of the transaction.\nThis is a convention for improved usability because most of the conditions relate to the properties of the output boxes. We could specify those properties in the bid box, but then we would have to use more complex expressions.\nLet's consider the output created by the arrow labeled with buyerOut@0. This label tells us that the output is at the index 0 in the OUTPUTS collection of the transaction and that in the diagram we can refer to this box by the buyerOut name. Thus we can label both the box itself and the arrow to give the box a name.\nThe conditions shown in the buyerOut box have the form bid ? condition, which means they should be verified on-chain in order to spend the bid box. The conditions have the following meaning:\n tAmt: TID requires the box to have tAmt amount of TID token R4 == bid.id requires R4 register in the box to be equal to id of the bid box. script == buyer requires the buyerOut box to have the script of the wallet where it is located on the diagram, i.e. pk(buyer)  Similar properties are added to the sellerOut box, which is specified to be at index 1 and the name is given to it using the label on the box itself, rather than on the arrow.\nThe Swap transaction spends two boxes bid and ask using the !swap spending path on both, however unlike !cancel the conditions on the path are not specified. This is where the bid ? and ask ? prefixes come into play. They are used so that the conditions listed in the buyerOut and sellerOut boxes are moved to the !swap spending path of the bid and ask boxes correspondingly.\nIf you look at the conditions of the output boxes, you will see that they exactly specify the swap of values between seller's and buyer's wallets. The buyer gets the necessary amount of TID token and seller gets the corresponding amount of ERGs. The Swap transaction is created when there are two matching boxes with buyOrder and sellOrder contracts.\nFrom Diagrams To ErgoScript Contracts What is interesting about FlowCard specifications is that we can use them to automatically generate the necessary ErgoTree scripts. With the appropriate tooling support this can be done automatically, but with the lack of thereof, it can be done manually. Thus, the FlowCard allows us to capture and visually represent all of the design choices and semantic details of an Ergo dApp.\nWhat we are going to do next is to mechanically create the buyOrder contract from the information given in the DEX flow card.\nRecall that each script is a proposition (boolean valued expression) which should evaluate to true to allow spending of the box. When we have many conditions to be met at the same time we can combine them in a logical formula using the AND binary operation, and if we have alternatives (not necessarily exclusive) we can put them into the OR operation.\nThe buyOrder box has the alternative spending paths !cancel and !swap. Thus the ErgoScript code should have OR operation with two arguments - one for each spending path.\n/** buyOrder contract */ { val cancelCondition = {} val swapCondition = {} cancelCondition || swapCondition } The formula for the cancelCondition expression is given in the !cancel spending path of the buyOrder box. We can directly include it in the script.\n/** buyOrder contract */ { val cancelCondition = { buyer } val swapCondition = {} cancelCondition || swapCondition } For the !swap spending path of the buyOrder box the conditions are specified in the buyerOut output box of the Swap transaction. If we simply include them in the swapCondition then we get a syntactically incorrect script.\n/** buyOrder contract */ { val cancelCondition = { buyer } val swapCondition = { tAmt: TID \u0026amp;\u0026amp; R4 == bid.id \u0026amp;\u0026amp; @contract } cancelCondition || swapCondition } We can however translate the conditions from the diagram syntax to ErgoScript expressions using the following simple rules\n buyerOut@0 ==\u0026gt; val buyerOut = OUTPUTS(0) tAmt: TID ==\u0026gt; tid._2 == tAmt where tid = buyerOut.tokens(TID)\u000b R4 == bid.id ==\u0026gt; R4 == SELF.id where R4 = buyerOut.R4[Coll[Byte]].get script == buyer ==\u0026gt; buyerOut.propositionBytes == buyer.propBytes  Note, in the diagram TID represents a token id, but ErgoScript doesn't have access to the tokens by the ids so we cannot write tokens.getByKey(TID). For this reason, when the diagram is translated into ErgoScript, TID becomes a named constant of the index in tokens collection of the box. The concrete value of the constant is assigned when the BuyOrder transaction with the buyOrder box is created. The correspondence and consistency between the actual tokenId, the TID constant and the actual tokens of the buyerOut box is ensured by the off-chain application code, which is completely possible since all of the transactions are created by the application using FlowCard as a guiding specification. This may sound too complicated, but this is part of the translation from diagram specification to actual executable application code, most of which can be automated.\nAfter the transformation we can obtain a correct script which checks all the required preconditions for spending the buyOrder box.\n/** buyOrder contract */ def DEX(buyer: Addrss, seller: Address, TID: Int, ergAmt: Long, tAmt: Long) { val cancelCondition: SigmaProp = { buyer } // verify buyer\u0026#39;s sig (ProveDlog)  val swapCondition = OUTPUTS.size \u0026gt; 0 \u0026amp;\u0026amp; { // securing OUTPUTS access  val buyerOut = OUTPUTS(0) // from buyerOut@0  buyerOut.tokens.size \u0026gt; TID \u0026amp;\u0026amp; { // securing tokens access  val tid = buyerOut.tokens(TID) val regR4 = buyerOut.R4[Coll[Byte]] regR4.isDefined \u0026amp;\u0026amp; { // securing R4 access  val R4 = regR4.get tid._2 == tAmt \u0026amp;\u0026amp; // from tAmt: TID  R4 == SELF.id \u0026amp;\u0026amp; // from R4 == bid.id  buyerOut.propositionBytes == buyer.propBytes // from script == buyer  } } } cancelCondition || swapCondition } A similar script for the sellOrder box can be obtained using the same translation rules. With the help of the tooling the code of contracts can be mechanically generated from the diagram specification.\nConclusions Declarative programming models have already won the battle against imperative programming in many application domains like Big Data, Stream Processing, Deep Learning, Databases, etc. Ergo is pioneering the declarative model of dApp development as a better and safer alternative to the now popular imperative model of smart contracts.\nThe concept of FlowCard shifts the focus from writing ErgoScript contracts to the overall flow of values (hence the name), in such a way, that ErgoScript can always be generated from them. You will never need to look at the ErgoScript code once the tooling is in place.\nHere are the possible next steps for future work:\n  Storage format for FlowCard Spec and the corresponding EIP standardized file format (Json/XML/Protobuf). This will allow various tools (Diagram Editor, Runtime, dApps etc) to create and use *.flowcard files.\n  FlowCard Viewer, which can generate the diagrams from *.flowcard files.\n  FlowCard Runtime, which can run *.flowcard files, create and send transactions to Ergo network.\n  FlowCard Designer Tool, which can simplify development of complex diagrams . This will make designing and validation of Ergo contracts a pleasant experience, more like drawing rather than coding. In addition, the correctness of the whole dApp scenario can be verified and controlled by the tooling.\n  References  Ergo Ergo Appkit Introduction to Appkit Appkit Examples ErgoDex ScalaDocs ErgoTree Specification  ","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_04_29_flow_cards/","subtitle":null,"title":"FlowCards: A Declarative Framework for Development of Ergo dApps"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_04_29_flow_cards/","permalink":"https://ergoplatform.org/en/news/2020_04_29/","subtitle":"Ergo is pioneering the declarative model as a better and safer alternative to the now popular imperative model of smart contracts.","title":"FlowCards: A Declarative Framework for Development of Ergo dApps"},{"contents":"Because a blockchain is a siloed, self-contained system by design, interacting with other blockchain protocols is challenging. Atomic Swaps enable cross-chain exchange of digital assets, avoiding the need for centralised exchanges.\nBlockchains are excellent at decentralised value transfer within their own domains. That is, you can send BTC to any Bitcoin address securely and easily, and you can send LTC to any Litecoin address securely and easily too.\nBut because blockchains are based on consensus between miners, they are not designed to interface with other blockchains. Trading assets on different blockchains has therefore traditionally involved third parties like exchanges and OTC desks – with all the risks and inefficiencies they bring.\nCross-chain swaps Atomic swaps solve this problem by enabling cryptocurrencies to be traded across blockchains. This allows trustless exchange of assets, quickly and efficiently. Here’s how they work in theory:\n  Alice and Bob agree to exchange some cryptocurrency. Alice will send Bob 1 BTC, and Bob will send Alice 50,000 ERG. Neither party trusts the other, so neither wants to send their crypto first.\n  Alice generates a secret – a long random number – and hashes it. She then creates a transaction on the Bitcoin blockchain with a script attached, locking 1 BTC and specifying a condition: when the secret (pre-image) to the hash she has created is revealed, the BTC will be sent to Bob’s address. The hash can safely be included in the transaction script, because the pre-image cannot be calculated from it.\n  Bob then similarly creates a transaction on the Ergo blockchain, including a script with the same hash Alice has used. When the pre-image is revealed, 50,000 locked ERG will be sent from Bob’s address to Alice’s address. Because Bob doesn’t have the pre-image, he can’t execute Alice’s transaction before he has created his own.\n  Once Alice sees that Bob has created his transaction on the Ergo blockchain, she can publish the secret and execute his transaction. Because the pre-image is now public, Bob can also use it to execute the script that will send him his BTC.\n  Neither party can delete their transactions and scripts once they have been posted to the blockchain. They may include a condition that the transaction will expire within a certain time, to avoid their coins being locked indefinitely if Alice does not reveal the secret.\n  Ergo’s atomic swaps\n  They are called ‘atomic’ swaps because the orders are either executed in their entirety, or not at all – a kind of fill-or-kill order. But while that’s useful up to a point, it doesn’t allow for active trading, like you would be able to do on an exchange.\nErgo’s implementation of atomic swaps develops the concept further. It’s relatively easy to swap coins or custom tokens trustlessly across any Bitcoin-like blockchains. But beyond that, Ergo allows partial swaps. Just like on a regular exchange, orders can be partially filled, if that’s what the trader wants.\nThis means it’s possible to build a fully-fledged decentralised exchange (DEX) that enables cross-chain trading: a totally trustless version of existing crypto exchanges. There’s no need for any gateways, token wrapping or other potential bottlenecks or points of failure.\nYou can find out more about Ergo’s implementation of atomic swaps and intra-chain and cross-chain token swaps in the ErgoScript white paper.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_04_24_atomic_swaps/","subtitle":null,"title":"Building Ergo: Atomic Swaps"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_04_24_atomic_swaps/","permalink":"https://ergoplatform.org/en/news/2020_04_24/","subtitle":"Ergo allows partial swaps. Just like on a regular exchange, orders can be partially filled, if that’s what the trader wants.","title":"Building Ergo: Atomic Swaps"},{"contents":"Blockchains are siloed systems that can only reference their own data, established by consensus. Oracles are the solution to the problem of working with external information, which is vital for many everyday use cases.\nBlockchains are intentionally self-contained. They reference information only recorded within their immediate ecosystem, that has been agreed upon by a majority of miners. Since the whole point of a blockchain, based on consensus, is that there are no sources of centralisation or single points of failure, that poses a problem.\nWhat happens when you want to engage with external information? Many blockchain-based applications need to process data from the real world. That might be financial information, such as market data and prices from exchanges, for DeFi applications; it could be sporting results, for eSports predictions markets; it could even be atmospheric noise information, for random number generators.\nIntroducing Oracles Oracles are the software that serves as a link between these real-world sources of data and the siloed world of the blockchain. They are simple in principle, since they only need to create a series of transactions with the necessary data (ideally formatted in an easily-accessible way) at regular intervals.\nHowever, while anyone can record information to an open blockchain, that is a source of centralisation. So how do you trust an oracle?\nThe answer is: you don’t. Just like the blockchain’s consensus method itself, you need multiple oracles pulling data from multiple sources, then coming to agreement about the value to record to the blockchain. So you don’t need to trust an individual miner, and you don’t need to trust an individual oracle.\nExample: bitcoin price data As an example, let’s say we want to record bitcoin’s closing price every day to the Ergo blockchain, to give us a long-term and reliable source of price data.\nWe could take a dozen – or even a hundred – different data feeds, each pulling data from a major exchange. Coinbase, Bitstamp, Kraken, and so on. We make sure that many exchanges are represented, and while it’s good to have several examples of data from the same exchange, we don’t want any exchange over-represented.\nThen the parties need to reach consensus about the price. Let’s say there are 100 parties and prices involved. There are different ways they could do that:\n Take the mean of all the prices they provide Discard the highest and lowest 20 prices, and take the mean of the remaining 60 prices Select the median price Weight the prices, with the central cluster of prices having greater weight, and take the mean  The aim is to discard or downweight any outliers, which could be due to extreme price fluctuations on a single exchange, API outages, or dishonest oracle data providers, while retaining many good data points to ensure a single reliable record of price.\nOracles are a hugely important part of the blockchain ecosystem. Once you have robust oracles in place, you can create all kinds of DeFi applications – including stablecoins, which are a vital part of the blockchain economy, and one we’ll be exploring on Ergo in the coming months.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_04_04_building_ergo_oracles/","subtitle":null,"title":"Building Ergo: Oracles"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_04_04_building_ergo_oracles/","permalink":"https://ergoplatform.org/en/news/2020_04_23/","subtitle":"Blockchains are siloed systems that can only reference their own data, established by consensus. Oracles are the solution to the problem of working with external information, which is vital for many everyday use cases.","title":"Building Ergo: Oracles"},{"contents":"We’ve designed Ergo with long-term economic sustainability in mind, and storage rent is one of the ways we’re ensuring miners stay profitable well into the future. One community member, Robert, describes this function as ‘on-chain garbage collection’ that reduces the problem of blockchain bloat – and even makes it profitable.\nThe 2020 block reward reduction will probably be the most important halving Bitcoin ever experiences. This is the point where the narrative of programmatic scarcity and digital gold will truly be proven, in the context of the sharpest economic downturn in living memory. In previous halvings, Bitcoin has still been in its infancy, a niche experiment. Future halvings will confirm the principle. But this one is the watershed.\nLooking ahead, though, what happens in 20 or 30 years, when block rewards have fallen so far that miners have to rely on tx fees and potentially other sources of revenue? Will Bitcoin be sustainable? What will be the impact on the ecosystem?\nThe simple answer is that we don’t know.\nMining rewards are a key feature in maintaining the security of proof-of-work blockchains like Bitcoin and Ergo. And so, while we have deliberately kept many of Bitcoin’s tried and tested features, we have updated this one to give miners a boost when block rewards have fallen to zero.\nLost coins Digital scarcity is an important feature of Ergo. Like Bitcoin, ERG are designed to be a finite resource and long-term store of value. We do not agree with the principle of infinite inflation.\nAnd yet, this has to be balanced against the needs to pay miners to secure the blockchain and process transactions. Without adequate compensation for miners, there is no viable blockchain at all. Ergo approaches this by slowly recycling lost coins, in a feature we call ‘Storage rent’.\nStudies suggest that as many as 4 million BTC may have been lost forever. These are coins that were mined in the early days of Bitcoin and stored on hard drives that were subsequently thrown away or destroyed because the owners forgot about them or thought they were worthless, as well as coins in addresses for which the private keys have been lost. (And, of course, there’s Satoshi’s estimated holdings of 1 million BTC, which may never move.)\nWhere coins have genuinely been permanently taken out of circulation in this way, it makes sense to have a mechanism to recover them and put them back into the blockchain economy. That way, we can preserve digital scarcity without unnecessarily accelerating it. In other words, by attempting to stick to the intended algorithmic supply for any given point in time.\nErgo’s halving schedule is faster than Bitcoin’s. Block rewards start at 75 ERG, and decrease steadily after the first two years. There is no ‘long tail’ of emission, and after eight years block rewards will fall to zero. After that, total supply will be fixed. The number of ERG in existence will never be more than 97,739,925.\nStorage fees From that point, however, miners will need further incentives to secure the network. Miners have ongoing costs in terms of bandwidth and storage, and in cases where coins are simply left for years, there is typically no charge for reflecting the value of securing them. The tx fee that is paid up-front in Bitcoin is the only charge ever made for storing those coins.\nIn Ergo, in addition to transaction fees, miners will also be able to collect storage rent fees on UTXOs that have not been moved for four years or more.\nFees will be deducted slowly, over time – the unmoved UTXOs will not simply be appropriated by miners. Anyone who wants to avoid this simply needs to move their balances once every four years, which is not an onerous requirement for helping incentivise miners and avoiding the deflationary consequences of lost coins. You can read more about how fees will be levied in this paper.\nIn this way, Ergo seeks to ensure a balance between maintaining digital scarcity, on the one hand, and giving miners long-term incentives to secure the blockchain, on the other – long past the point where new coins have ceased to be released.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_04_21_ergo_positioning/","subtitle":null,"title":"Building Ergo: Storage rent"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_04_21_ergo_positioning/","permalink":"https://ergoplatform.org/en/news/2020_04_21/","subtitle":"One community member, Robert, describes this function as ‘on-chain garbage collection’ that reduces the problem of blockchain bloat – and even makes it profitable.","title":"Building Ergo: Storage rent"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_04_02_use_cases/","permalink":"https://ergoplatform.org/en/news/2020_04_03_1/","subtitle":"The need to reform the global financial system has been clear since the last crisis in 2008. Now, COVID-19 has forced our hands. We cannot delay, and the best way to start is from the grassroots.","title":"Ergo use case: Local Exchange Trading System (LETS)"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_04_02_use_hot_potato/","permalink":"https://ergoplatform.org/en/news/2020_04_03/","subtitle":"As the next financial crisis takes hold, it’s clear that conventional monetary policy is at its limit. Smart contract platforms like Ergo enable more innovative, targeted implementations of economic stimulation that the conventional banking sector cannot achieve.","title":"Ergo use case: ‘hot potato’ monetary policy"},{"contents":"The need to reform the global financial system has been clear since the last crisis in 2008. Now, COVID-19 has forced our hands. We cannot delay, and the best way to start is from the grassroots.\nAs lockdowns across the world effectively shut down whole sectors and a large part of the economy, we are entering a new era at breakneck pace. Central banks are taking unprecedented action in the form of money printing but, just like last time around, they will almost certainly fail at the ‘last mile’ (intentionally or otherwise): while their efforts will benefit the financial sector and the wealthy, the funds will not reach those small businesses and individuals who need them the most.\nCrossing the last mile Technology like the Ergo platform can address this problem efficiently, building bridges into and within our local economies without the need for commercial or central banks. A key principle of Ergo, and one stated in the white paper, is that it is for regular people. The developers have spent considerable time building technology that can be applied to real-world use cases. (This is the idea behind ‘Smart contracts for the people’, for example.)\nLETS In the present circumstances, a Local Exchange Trading System (LETS) would be a strong use case for Ergo. A LETS is a mutual credit association in which individual members are allowed to borrow from a common pot of money. All the loans are written into a ledger. Naturally, a blockchain system allows for strict and more granular rules around the size of loans and their use, as well as user privacy.\nFor example, let’s assume Alice has a zero balance. She wants to buy a litre of milk from Bob, and borrows the agreed price of 2 euros from the common pot. Alice’s account now registers -2 euros and Bob’s +2 euros. Bob can spend his balance with other participants of the LETS, and the creation of credit allows for economic activity and velocity of money even where people have, temporarily, no cash. Of course, limits on borrowing can be imposed – and even on positive ones, to prevent hoarding within the LETS. Such a system can be built trustlessly on Ergo.\nCrisis measures Systems like this have historically become popular during times of crisis. The first system of this kind was established by Michael Linton in a Canadian town stuck in depression back in 1981. LETS were also popular during the 1998-2002 Argentine Great Depression.\nMost LETS groups consist of 50 to 250 members, with paper-based credit notes and ledgers maintained by a committee. However, it is unsurprising that paper-based LETS have suffered from problems such as counterfeit notes, dishonest activity by administrators, and so on (much like centralised crypto exchanges). A blockchain-based LETS could be vastly superior to any previous system.\nMoreover, building lots of small credit systems on the same blockchain enables interoperability and novel financial products designed to strengthen the system as a whole. Hundreds of different LETS could exist, for individuals and small businesses, with different participation criteria, different credit limits, collateralisation requirements and other parameters. And yet they could still be connected by gateways allowing liquidity to move between different LETS, if required – while avoiding exposure to toxic debt.\nWhat use cases do you have for Ergo to address the broken financial system? Let us know.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_04_02_use_cases/","subtitle":null,"title":"Ergo use case: Local Exchange Trading System (LETS)"},{"contents":"As the next financial crisis takes hold, it’s clear that conventional monetary policy is at its limit. Smart contract platforms like Ergo enable more innovative, targeted implementations of economic stimulation that the conventional banking sector cannot achieve.\nConventional monetary policy is a hammer. It works as far as it goes, but if all you have is a hammer then every problem starts to look like a nail.\nWhen the Global Financial Crisis hit over a decade ago, central banks did what they were used to doing. Cutting interest rates means it’s cheaper to borrow money, so there’s more cash in the system that can be spent and will circulate in the economy – paying for goods and services, funding employment and allowing life to continue something like as normal.\nThat, at any rate, is the theory. It’s what central banks do in recessions to stimulate economic activity. When times are better, they raise interest rates to make it more expensive to borrow money and prevent the economy from overheating (including asset bubbles).\nThe outer limits This is a blunt tool, but it works, up to a point. In the 2008 crisis, the problem was more severe – so severe, in fact, that interest rates were slashed to zero. Banks were still afraid to lend because they didn’t know the quality of the collateral they were offered in return, those notorious mortgage-backed securities.\nSo the central banks undertook a programme of Quantitative Easing (QE). This entailed creating huge amounts of cash that didn’t exist before, then purchasing various assets from the banks. The idea was that the central bank would take on the risk and the assets, and commercial banks would then use this gift of liquidity to lend to small businesses and individuals, allowing them to continue operating as before.\nIt didn’t work. Little of that newly-created money went to small businesses. Instead, banks used it to shore up their own balance sheets and make their own finances safer, investing only in low-risk assets rather than risky SMEs. Ultimately that cash filtered through to assets like the stock market and property, making the wealthy even more wealthy while the poorer were priced out of the market.\nHelicopter money Today, as we experience the greatest financial challenge of our lifetimes – greater than even the Global Financial Crisis – central banks are considering even more unorthodox approaches. One of these is ‘helicopter money’. This involves cash being simply airdropped directly to citizens, either in the form of tax breaks or as money straight into their bank accounts. America has discussed giving $1,200 to every adult. Other nations are exploring the same idea.\nBut there’s a problem with this, too.\nJust like the banks, ordinary citizens are worried about their finances. So instead of going out and spending (where ‘going out’ is even possible), they pay down their debt. That newly-printed money goes nowhere.\nThat’s really as far as central banks can go. But a platform like Ergo can offer different types of money, with different conditions attached via smart contracts, incentivising different behaviour in different circumstances. And that enables a whole different range of monetary policy tools.\n‘Hot potato’ money In normal times, banks seek to maintain an inflation rate of around 2%. This means money is worth less over time. So instead of saving it all, and seeing the value of their savings fall, citizens have the incentive to spend it and circulate it within the economy.\nToo much inflation, of course, is a bad thing. Get money printing wrong and you have hyperinflation like Venezuela or Zimbabwe, and your economy collapses.\nBut what if we kept inflation low, but created a limited amount of a special class of money that had to be used quickly if it was to retain its value at all? We’ll call this ‘hot potato’ money, because it has to be passed on fast.\nUsing a blockchain and smart contracts, this would be a simple matter of creating a new token that could be freely transferred and traded, just like any other token. And it could be backed by reserves (held with the central bank, commercial banks or any other entity). But the difference would be that it has to be spent within a month of receiving it, or those tokens are locked, their value is lost to the holder and the funds that back them are freed up to return to the reserve holder.\nSo this would be regular money that people had to spend: use it or lose it. If they hoard it, it becomes useless. And we can ensure that it is not used to pay down debt by including conditions that ensure it cannot be used by the banking sector. Of course, Ergo’s Sigma protocols can be used to figure out what has been spent, where, without knowing individual spending habits – enabling even more targeted stimulus.\nThis idea likely has far-reaching implications – and possibly unintended consequences. What would the result be, for example, of creating different ‘classes’ of money that were only semi-interchangeable? Would this introduce unwelcome, even dangerous friction?\nThis and other questions would need to be explored further. What’s clear is that central banks are already experimenting with unconventional monetary policy and are fast reaching the end of the road. We can continue that experiment with better, more powerful and targeted tools.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_04_02_use_hot_potato/","subtitle":null,"title":"Ergo use case: ‘hot potato’ monetary policy"},{"contents":"Ergo enables new models of financial interaction, underpinned by smart contracts built on flexible and powerful Sigma protocols but easily accessible to developers.\nOne of the most exciting things about blockchain is the possibility of making digital agreements without any trusted intermediaries. In the simplest use case, pioneered by Bitcoin, Alice can send a payment directly to Bob, wherever the two of them are located around the world, with no bank or any trusted third party needed. However, with the functionality of a modern blockchain like Ergo, it is possible to make far more complex and sophisticated financial agreements than simple payments. Take the following example.\nGold-backed tokens Alice uses ERGs to purchase gold-backed tokens from Bob. Bob stores the gold in a secure vault, and uses the blockchain to issue one token for every Troy ounce of gold he has. Alice can then use these tokens freely in different contracts, transferring and trading them under whatever conditions she specifies in the smart contract code. When Alice wants to sell the tokens for physical gold, she can conduct another transaction with Bob, receiving ERG in return, at market price.\nThe point of blockchain contracts is to eliminate the need for trust. While the purchase transaction is now trustless, in this instance Alice still needs to trust Bob about two things. Firstly, Bob may refuse to swap the gold tokens back to ERG at the correct price when Alice wants to sell. Secondly, Bob may default on his obligations – running away with the gold, or misusing the funds he receives and running a fractional reserve.\nExtending the contracts To address these issues, we can create an Oracle, or decentralised price feed. This uses multiple sources of external data to record the price of gold to the blockchain at regular intervals. This price feed will be the reference point for the redemption contract that manages the sale of Alice’s gold with Bob (or any other participant). Thus the system automatically enforces the right price when a swap takes place.\nThe second situation requires a third-party insurer, Charlie, whose service is also hosted on the blockchain with a smart contract. When Alice purchases gold from Bob, she additionally buys an insurance contract from Charlie. The payment can be dependent on factors including the amount of insurance required, and Bob’s reputation – again, managed by a decentralized feedback mechanism. Now, if Bob defaults, Alice will automatically receive the value of her gold tokens, with Charlie effectively acting as a buyer of last resort.\nProgrammable contracts There are, of course, many other example use cases like this one. We can also extend this use case, adding further economic actors. For example, Charlie may sell shares in his insurance business to Dave and other participants, providing them with a proportion of revenues in return for ensuring he has the capital he needs to cover any liabilities from the outset.\nHowever, even the most complex use case is simpler than general-purpose software that can be used to program any contract. After all, generalised logic must be both far-reaching and secure. Moreover, even a specialised contract is made up of many steps, each of which is fairly simple. Thus another requirement for a general-purpose platform is that it should simplify the process of writing contracts, making them as accessible (and safe) as possible. This can be achieved with the use of template agreements, with customisable parameters. The insurance contract above could be based on a module with flexible parameters, for example. This could be used and reused in many different circumstances.\nErgo’s approach This is essentially the approach that Ergo takes, providing superior support for real-world financial agreements. It does this through:\n Support for multi-stage contracts (watch details for developers) A simple high-level language, ErgoScript, enabling clear descriptions of contractual logic Support for formal verification of contracts for improved security guarantees (Ergo Platform deployed its first formally verified p2p crowdfunding contract just three months after the network launched) Easy Oracle creation Native support for complex signature schemes  In short, creating financial contracts on the blockchain isn’t just about the functionality you provide. It’s about making that functionality safe and accessible, as well as powerful. Ergo achieves this and more.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_03_29_ergo_use/","subtitle":null,"title":"Ergo use cases: safe, simple financial contracts"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.2.2","permalink":"https://ergoplatform.org/en/news/2020_03_24/","subtitle":"Fixes and improvements. Details in the description of the release","title":"Ergo Mainnet 3.2.2 released"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_03_20_ergo_mixer/","permalink":"https://ergoplatform.org/en/news/2020_03_23/","subtitle":"A powerful mixer that works by pooling funds and enabling participants to spend them without anyone knowing who made the transactions","title":"Introducing Σ3 - ErgoMixer"},{"contents":"Ergo’s smart contracts and DeFi functionality are built on Sigma protocols – a powerful, flexible class of zero-knowledge proofs. Find out more about why they’re so important, and how they put Ergo head and shoulders above the competition.\nCryptography is a fascinating area, and one of the most exciting and intriguing concepts it offers are zero-knowledge proofs. In simple terms, a zero-knowledge proof allows someone to prove they know the solution to a problem without actually revealing the solution itself.\nLet’s say someone picks up a phone in a bar. You can prove it’s yours by hiding the screen, entering the unlock code and showing the unlocked screen to the person who found it. This is a simple example of a zero-knowledge proof: you have proven you own the phone without giving away any sensitive information.\nIn cryptography, most practical problems are associated with secrets. The most popular application lies in digital signatures, used by millions of people around the world every day. Essentially, these involve saying: ‘This message proves I know the private key associated with this public key – but I’m not revealing the private key itself’. (Not every digital\nsignature scheme uses zero-knowledge proofs, but the most popular do.)\nSigma protocols Among the hundreds or even thousands of zero-knowledge protocols, there is a sub-class of efficient and composable proof-of-knowledge protocols called Sigma Protocols. These are also known as Generalized Schnorr Proofs. Sigma protocols can be represented as digital signatures in a straightforward way, so we can effectively think of them as signatures in the context of blockchain.\nA Schnorr signature is a simple Sigma protocol signature, then. Schnorr signatures have been proposed as an alternative to Bitcoin’s current signatures. (It is one of the most efficient signature schemes, which is why it would be beneficial for Bitcoin.)\nHowever, there are dozens of other Sigma protocols. One of the great things about them is that they are composable, using simple AND and OR logic. So you can ask for a signature with the following statement: ‘Prove to me knowledge of either this secret OR that secret’ (this is a one-of-two ring signature). Or you can ask, ‘Prove to me knowledge of any two of these three secrets’ (a two-of-three ring signature). Those are just two simple examples; there are many more, and they can be far more complex and sophisticated.\nErgo: Sigma + blockchain When combined with a blockchain, these composable proofs enable some very powerful use cases. The logic for proofs can include conditions based on blockchain state. For example, ‘If the deadline block height has been reached, Alice can provide knowledge of a secret key for a refund. OR a ring signature from Alice and Bob is required to spend coins.’ Or ‘If this account holds a minimum of 100 ERG, Alice OR Bob can remove funds above that amount.’\nThus some very interesting and flexible DeFi applications can be built on Ergo, using secure, straightforward and efficient Sigma protocols.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_03_16_ergo_sigma/","subtitle":null,"title":"Building Ergo: Sigma protocols"},{"contents":"The project uses Ergo’s Sigma protocols to enable efficient, trustless mixing of funds, enabling a high degree of privacy while ensuring security is not compromised.\nErgoMixer command-line demo tool along with detailed technical description can be found at https://github.com/anon92048/ergo-mixer-demo .\nErgo’s Sigma protocols can be used to create many interesting and exciting DeFi use cases, with greater simplicity, efficiency and security than other smart contract platforms offer. Created by one of Ergo’s community members @anon92408, Σ3 (‘Sigma Three’) is a powerful mixer that works by pooling funds and enabling participants to spend them without anyone knowing who made the transactions.\nHow does it work? While understanding the full operation of the mixer will require some in-depth knowledge of cryptography, the root concept is fairly simple. (For those who want to learn the details, you can find out more in the white paper.)\nParticipants send coins to a pool, and these can be spent by different members. However, the use of Sigma protocols – specifically ring signatures – means that it’s impossible to know which member spent them.\nTake the simplest case of a pool in which a ‘box’ of coins can be spent by either Alice or Bob. Either Alice or Bob can sign a transaction and move the coins, but no external observer will be able to tell which of the two signed it. This is different to multi-signature transactions, in which (say) 2 of 3 participants have to sign a tx; with multi-sig, it is known which two do the signing.\nThus anyone observing from the outside would have a 50:50 chance of guessing whether Alice or Bob moved those coins. But that process is iterated, over and over again, with different users. After many rounds, with many users, it’s effectively impossible to know who owns the coins. Still, the coins never leave the control of their original owner – there is no risk of lost funds.\nErgoScript This process can be implemented natively on the blockchain, as is the case with ZCash. This has a similar process hardwired into the blockchain – which works, but imposes limits on the blockchain.\nIt would be possible to implement something similar with Ethereum, since Ethereum has Turing-complete smart contracts and any computational task can be executed. But it would be clunky and inefficient, and the result would be expensive and possibly risky.\nErgo allows this kind of use case to be implemented easily, using Sigma protocols. ErgoScript includes native support for all the cryptographic and blockchain functionality required to create Σ3 on the Ergo chain, securely and efficiently.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_03_20_ergo_mixer/","subtitle":null,"title":"Introducing Σ3 – ErgoMixer"},{"contents":"Ergo takes the most secure and best-established features of Bitcoin and implements advanced new cryptographic features on its rock-solid foundations. This series explores the choices we have made in creating Ergo, with the first article unpacking the advantages of the UTXO model.\nWhen you’re dealing with financial value, you cannot afford to take chances. Every architecture decision in a cryptocurrency platform has implications. While there are different ways to solve the same problem, some solutions are better tested and more reliable than others.\nLike Bitcoin, Ergo uses the ‘UTXO’ (unspent transaction outputs) model, rather than the Account model used by platforms like Ethereum. There are a number of reasons why we have made this choice, but first it’s worth explaining a little about how the UTXO or ‘Box’ model works.\nMost people think that the balance of an account is a simple number that is updated when you send or receive funds. This is the obvious way to approach the problem; after all, it is effectively how money works in the real world. Your bank account has a balance that is increased or decreased when different transfers are made in and out. This is how the ‘Account’ model operates: your balance on the blockchain is altered by transactions to and from the account.\nHow much dough? The UTXO model, pioneered by Bitcoin, is quite different. You can think of this a bit like a person holding a series of lumps of bread dough. Their balance is the sum of these lumps, or UTXOs. Lumps can be divided or combined, before they are sent to a new address, but you always know where they came from. For example:\nAlice has 100g of bread dough (100 ERG). She breaks off a lump of 75g and gives it to Bob, keeping 25g of ‘change’ for herself. Charlie has 250g of dough. He breaks off 150g and gives it to Bob, keeping 100g of change for himself. Bob breaks 20g of dough off the 150g lump he received from Charlie, and combines the resulting 130g with the 75g he received from Alice. He gives the total of 205g to Dave, keeping the 20g change for himself. Dave now has 205g of bread dough, which used to belong to Charlie. Before Charlie owned it, 75g used to belong to Alice, while 130g used to belong to Bob.\nIn the UTXO model, ‘lumps’ of coins can be combined and divided, but unlike bread dough, they aren’t mixed together. You can follow the history of funds right back to the coinbase transaction in which those coins were first mined. That’s very different to the Account model, where the balance of each account is simply changed. (You can, of course, check the blockchain to make sure the Account says what it should, but that’s not intrinsically necessary like it is with the UTXO approach.)\nWhy UTXO? The UXTO model has several implications. For a start, each object is immutable – lumps of coins cannot be ‘edited’ like an Account balance is edited when a transaction is made. The balance is calculated from the transaction history, right back to the point those coins first came into existence.\nThat makes security much simpler, because either a UTXO exists in the form you are expecting, or it does not exist at all. With the account model, you need to carefully check that the account you’re dealing with is in the state it should be (and developers typically don’t do that properly). This also makes UTXOs more friendly for offchain protocols, like sidechains and the Lightning Network.\nAccounts make it easier to store the ‘state’, but easy doesn’t always mean better. With Ergo’s extended UTXO model, state transitions are more explicit and so they are cleaner – there are no unwanted surprises. It might be a little bit more burdensome to deal with, but it’s a lot better and more straightforward in terms of security.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_03_03_building_utxo/","subtitle":null,"title":"Building Ergo: UTXO vs Account"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_03_03_building_utxo/","permalink":"https://ergoplatform.org/en/news/2020_03_03/","subtitle":"This series explores the choices we have made in creating Ergo, with the first article unpacking the advantages of the UTXO model","title":"Building Ergo: UTXO vs Account"},{"contents":"  Ergo Platform Roadmap for 2020 has been released, the plan is minimum and very realistic https://ergoplatform.org/en/blog/2020_02_02/\n  Miners tested raising computational cost limit per block via voting with success\n  \u0026ldquo;Bypassing Non-Outsourceable Proof-of-Work Schemes Using Collateralized Smart Contracts\u0026rdquo; https://ia.cr/2020/044 was presented by Alex Chepurnoy at WTSC workshop associated with Financial Cryptography and Data Security 2020 in Malaysia\n  Few AMA sessions have been held with the Ergo team by Probit, ViteXExchange, and CryptoDaku. https://bitcointalk.org/index.php?topic=5150971.msg53894939#msg53894939\n  Anon92048 is working on non-custodial and non-interactive mixer implementing ErgoMix\n  Frontpage was updated https://ergoplatform.org/en/\n  Welcome to Smart Money article published https://ergoplatform.org/en/blog/2020_02_12_welcome_to_smart_money/\n  Dev meeting summary https://twitter.com/ergoplatformorg/status/1230119289878872064\n  Finally Coingecko has updated info about Ergo https://www.coingecko.com/en/coins/ergo\n  Ergo Mainnet 3.2.1 released https://github.com/ergoplatform/ergo/releases/tag/v3.2.1\n  Ergo Playgrounds - Run contracts + off-chain code in the browser https://www.ergoforum.org/t/ergo-playgrounds-run-contracts-off-chain-code-in-the-browser/185\n  Coinbarn, a simple wallet for Ergo has been published in the Chrome store! https://chrome.google.com/webstore/detail/coinbarn-wallet/pachdpadffdgjhmmgpdjkpnlhkdhbfgf Desktop versions can be found here https://github.com/coinbarn/coinbarn-extension/releases/\n  The new bounty campaign, in partnership with Magnum wallet went live https://twitter.com/Magnum_Wallet/status/1232959453529616385\n  http://erg.ezpool.io/ went out of private testing mode and is offering both Nvidia and AMD optimized miners. Congratulations to the pool creator who broke non-outsourceable PoW scheme\n  Most active exchanges - Probit, Tidex, Waves Exchange https://ergoplatform.org/en/exchanges/\n  Please join the Ergo community to help with development and promotion! Our Telegram: https://t.me/ergoplatform | Discord: https://discordapp.com/invite/gYrVrjS | Twitter: https://twitter.com/ergoplatformorg | Github: https://github.com/ergoplatform\n  ","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_03_03_digest/","subtitle":null,"title":"Ergo Platform Ecosystem Digest - February 2020"},{"contents":"","link":"https://chrome.google.com/webstore/detail/coinbarn-wallet/pachdpadffdgjhmmgpdjkpnlhkdhbfgf","permalink":"https://ergoplatform.org/en/news/2020_02_26/","subtitle":"Desktop versions can be found here https://github.com/coinbarn/coinbarn-extension/releases/","title":"Coinbarn, a simple wallet for Ergo has been published in Chrome store"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.2.1","permalink":"https://ergoplatform.org/en/news/2020_02_19/","subtitle":"Mempool and miner made friendly to transactions spending outputs of offchain transactions, parameter for syncing detection during headers-chain download and more","title":"Ergo Mainnet 3.2.1 released"},{"contents":"It’s the smartest crypto you’ve never heard of. Ergo takes the best of Bitcoin and integrates Sigma protocols so powerful they make Ethereum look like it would lose a game of chess against your cat. If you’re tired of spin and hype over solid tech, Ergo will remind you that in crypto, it’s always been fashionable to be intelligent. Bright is the new black, people, and Ergo is set to dazzle you.\nDeFi is set to be the major blockchain trend for 2020. Many new smart contract platforms are positioning to become one of the handful of big players in the space. With a strong head start, competent development team and impressive network, Ethereum’s place in this billion-dollar (and growing) movement is assured. The others must offer something different – dramatically different – to differentiate themselves against this background. Ergo is a smart contracts and DeFi platform that may have what it takes to carve out a niche in this fast-moving and competitive new sector.\nPowerful But Safe Contracts Ethereum is an exceptional platform, but there are things it does not do well. Its Turing-complete smart contracts are powerful, but dangerous – as incidents from The DAO to the Parity wallet exploits have proven, with tens of millions of dollars in collateral damage. With complexity comes uncertainty, and potentially catastrophic vulnerabilities. Contracts can be expensive to run, and depending on network conditions may execute unpredictably – or not at all.\nErgo takes a fundamentally different approach to smart contract development. The team, which has extensive experience with blockchain platforms, frameworks and organisations from Nxt and Waves to Scorex and IOHK, has adopted a declarative model for programming whereby it’s always known in advance how much code will cost to run – and, indeed, whether it will run precisely as intended. While that might on the surface limit code complexity, it’s nevertheless possible to create Turing-complete scripts by iterating processes across multiple blocks. That means Ergo can support versatile dApps that run predictably, with known costs, and don’t have any of the dangers of unrestricted functionality.\nSigma protocols The platform is unashamedly conservative, basing as many features as possible on Bitcoin – after all, Bitcoin is the most battle-tested crypto network in existence. Ergo’s UTXO model, PoW mining and finite supply draw on Bitcoin’s approaches to consensus and economic incentives.\nBut Ergo also incorporates cutting-edge research into new cryptographic processes, using Sigma protocols to enable DeFi applications that would be either complex and messy or simply impossible on other platforms. Sigma protocols are a well-known class of zero-knowledge proofs that allow developers to implement very powerful processes very elegantly. For example, what if you want to build a privacy service that allows any one of a dozen different accounts to spend funds from an address – but no one can tell who has made each transfer? Such a ‘ring contract’ is possible with Ethereum, but it would require a clunky and expensive workaround. With Ergo’s Sigma protocols, it’s possible to implement this kind of use case and many others quickly, efficiently and – above all – securely. Sigma protocols have not been deployed in such generic form within crypto before. Yet this kind of out-of-the-box functionality is hugely valuable, especially when no other DeFi platform offers it.\nGet involved Ergo’s team has been working on the project for over two years, attracting interest from some major players in the crypto space (including Cardano’s Charles Hoskinson) but avoiding mainstream attention until now. With the platform’s core functionality now substantially complete, the developers are seeking to expand the network, form new partnerships and make a mark in the nascent DeFi movement.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_02_12_welcome_to_smart_money/","subtitle":null,"title":"Welcome to Smart Money"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_02_04_january_digest/","permalink":"https://ergoplatform.org/en/news/2020_02_04/","subtitle":"January 2020","title":"Ergo Platform Ecosystem Digest"},{"contents":"  Ergo Foundation has been established (https://ergoplatform.org/en/foundation/)\n  Security audit of most critical parts of the reference protocol client is done, report is available (https://ergoplatform.org/en/blog/2020_01_12_security_audit/)\n  New paper is out, \u0026ldquo;Bypassing Non-Outsourceable Proof-of-Work Schemes Using Collateralized Smart Contracts\u0026rdquo; (https://eprint.iacr.org/2020/044.pdf). This paper describes how to build a pool for Ergo based on smart contracts with collaterals.\n  Public Discord server has been created (https://discordapp.com/invite/gYrVrjS), please join!\n  Ergo Platform reference protocol client 3.2.0 released (https://github.com/ergoplatform/ergo/releases/tag/v3.2.0). Updates are coming reguralry!\n  CoinBarn wallet is still under review in ChromeStore, but released a desktop version (https://twitter.com/coinbarn/status/1211026427686064133). CoinBarn is the simplest wallet for Ergo, and it is supporting custom tokens!\n  Ergo now has a command-line wallet also, called ErgoTool. An introductory article on the ErgoTool: https://ergoplatform.org/en/blog/2019_12_31_ergo_tool/\n  ErgoCast #2 published: https://ergocast.io/\n  ","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_02_04_january_digest/","subtitle":null,"title":"Ergo Platform Ecosystem Digest - January 2020"},{"contents":"Ergo community made a lot in 2019:  Very stressful but successful mainnet launch A lot of updates for Ergo protocol reference client to improve its stability and enhance functionality. Wallets: Magnum, CoinBarn (coming to ChromeStore, binaries available), UI panel in the node First applications, in form of command-line scripts, so not for regular users yet: a tool for crowdfunding campaigns, Ergo Notary, Ergo Oracle. Few Ergo improvement proposals, already implemented! Few tools to build applications, such as ErgoAppKit, ErgoTool, Kiosk. A lot of contracts proposed on the forum, such as interest-free loan contract, zero-coupon bond scheme (the Yield protocol), auction and so on. It seems Ergo is very suitable for decentralized finance, even more, for simple and self-sovereign interacting peer-to-peer financial contracts! First crowdfunding campaign (https://www.ergoforum.org/t/simple-crowdfunding/70) and mixing (https://www.ergoforum.org/t/lets-play-with-ergomix/108) done! Few new research papers published or presented, namely \u0026ldquo;Multi-stage UTXO contracts\u0026rdquo;, \u0026ldquo;On Contractual Money\u0026rdquo;, \u0026ldquo;Bypassing Non-Outsourceable Proof-of-Work Schemes Using Collateralized Smart Contracts\u0026rdquo;, (see documents).  , not to say about progress in social aspects of ecosystem development (establishing Dev Fund Board, Ergo Foundation, first grants given, and so on).\nSo we are showing possibilities of Ergo, not just talking about them. However, most of demonstrations are not for a regular user yet.\nWith that in mind, Ergo Foundation would like to propose the following development plan for 2020:  UI for crowdfunding Implementation of ErgoMix, the first non-interactive mixing scheme utilizing Ergo's support for complex cryptographic protocols, and UI for it (for desktop and mobiles, at least Android). More mixing schemes to be developed in 2021. Implementation of decentralized exchange (DEX) based on atomic swaps, contracts are described in the smart contract language whitepaper. Ring, threshold and composite signatures support in the node. Ergo Development Fund members are already co-singing spendings using threshold signatures preserving zero-knowledge, now the time to bring such exciting possibilities to the mass adoption. New smart contract development stack with possibility of writing contracts in a subset of Scala language along and support for formal verification. Ledger or Trezor support.  Please note that this plan is minimum and very realistic. For example, the new smart contract development stack with formal verification is mostly done already.\nErgo Foundation is trying to maximize broader participation in ecosystem growth. Howeever, the ecosystem is still in the process of bootstrapping. So core developers will start or lead development where needed. Foundation is willing to provide grants to achieve the goals to increase external participation. The Foundation also accepts donations to increase its possibilities towards implementing the roadmap.\nWith this minimum set of tools we will be ready to have more in 2021: mutual credit systems, p2p loan contracts, bonds, algorithmic stablecoins etc. However, this things could be implemented right now, so please join the ecosystem and build for it! Also, in 2021 we can get the \u0026ldquo;Universal dApp Interface \u0026amp; Package Standard\u0026rdquo; (https://www.ergoforum.org/t/universal-dapp-interface-package-standard/153) implemented, which could be a real game-changer in the dApp industry!\n ","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_02_02/","subtitle":null,"title":"Ergo Platform Roadmap for 2020"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_02_02/","permalink":"https://ergoplatform.org/en/news/2020_02_02/","subtitle":"Please note that this plan is minimum and very realistic","title":"Ergo Platform Roadmap for 2020"},{"contents":"","link":"https://discordapp.com/invite/gYrVrjS","permalink":"https://ergoplatform.org/en/news/2020_01_23/","subtitle":"You are welcome to join us","title":"Ergo Platform Discord Server has been created"},{"contents":"","link":"https://eprint.iacr.org/2020/044.pdf","permalink":"https://ergoplatform.org/en/news/2020_01_17/","subtitle":"In this work, we propose a concrete example of such a mechanism which is using collateralized smart contracts","title":"Bypassing Non-Outsourceable Proof-of-Work Schemes Using Collateralized Smart Contracts"},{"contents":"","link":"https://ergoplatform.org/en/foundation/","permalink":"https://ergoplatform.org/en/news/2020_01_17_2/","subtitle":"Join us and help build the decentralized future","title":"Introducing the Ergo Foundation, a community-driven entity"},{"contents":"We would like to announce that Ergo has successfully passed security audit of certain (most critical) parts of the code. This time the audit was done by Jean-Philipee Aumasson (aka veorq, https://aumasson.jp/ ).\nThe detailed report is below. Nothing critical is found. Comments on issues found:\n  On wallet password, we'll provide a recommendation in next versions of the protocol client. Not sure hard enforcement on password will take place, but we'll do more consultations on this.\n  Changing \u0026ldquo;n\u0026rdquo; and \u0026ldquo;k\u0026rdquo; parameters makes sense when launching new network only. Changing this parameters in mining node will make blocks produced invalid for other nodes. Changing this parameters in protocol client means going on another fork (blocks coming from the honest protocol participants will be rejected). So no need for extra checks maybe, as people launching new networks will set \u0026ldquo;n\u0026rdquo; and \u0026ldquo;k\u0026rdquo; properly.\n  Currently the Ergo node (as well as other blockchain protocol clients and wallets we're aware of, as well as cryptographic libraries we're using) do not provide protection from side-channel attacks running locally (e.g. timing attacks or memory inspection by malware or viruses). So please protect machines you're running wallets on!\n  ==========================================================================================================\n% Ergo security assessment % Jean-Philippe Aumasson % 07/Dec/19\nSummary We were solicited by Ergo to perform a security assessment of several components of their Ergo Platform:\n Sigma protocol proofs creation and verification Wallet's secure storage of secrets Proof-of-Work validation  ​This brief report summarizes our assessment and describes our findings and mitigation recommendations.\nSigma protocol proofs ​The Ergo protocol relies on ErgoScript, a scripting language supporting sigma-statements, which can be proven and verified through non-interactive proofs of knowledge.\nThese proofs are statements described as a tree of AND, OR, and threshold conditions, whose leaves are proofs of knowledge of a discrete-logarithm problem.\nThe proof of the sigma-statement is then made non-interactive thanks to the Fiat-Shamir transform.\nThis logic is specified in the ErgoScript paper, and the specific proving and verification routines described in its Appendix A.\n​Implementation challenges are then to:\n  Define encoding of the proofs that are safe and efficient, and implement serialization and deserialization that always succeeds in processing valid input, and that always gracefully fails to process invalid input.\n  Implement the proving and verification functionalities correctly, in compliance with the specification, and most importantly such that no invalid statement can successfully pass verification.\n  We reviewed these two aspects, based on the code in the repository sigmastate-interpreter, and on the ErgoScript paper, carefully comparing the intended behavior (in Appendix A) with the actual behavior as implemented.\n​We notably reviewed code from the SigSerializer, Interpreter, and ProverInterpreter traits and objects.\n​We mainly sought bugs from the following classes:\n ​Unsafe processing of malformed input Unsafe processing of unusually long or short input Behavior when large tree depth or recursion level Unsafe use Scala types and structures Inappropriate variable types Integer overflows Race conditions Logic bugs  ​Despite extensive review, we did not identify any security issue.\nThe protocol's logic and internals are nonetheless relatively complex, and we believe the highest risk is in the parsing and verification of proofs. To exploit such issues, however, an attacker would have to create a semantically correct script that somehow benefits them, yet that passes verification when it does not ought to.\nRegarding software security, Scala eliminates certain classes of bugs, but Scala code may still suffer from bugs due to Scala's specific behavior or to unhandled errors.\nWallet Ergo's wallet functionality enables its users to store a secret on disk and recover it, initializing the wallet with a new seed when it's first used.\n​This logic is mainly defined in ErgoWalletActor, and a key component regarding secrets\u0026rsquo; storage is JsonSecretStorage.\n​The first time a wallet is create, the InitWallet command does the following:\n  Generate settings.walletSettings.seedStrengthBits random bits, as initial entropy. By default, 160 bits are generated.\n  Generate a BIP39 from the random bits generated, which can be seen as an encoding of the entropy bits. The standard BIP39 logic is used, with optional password.\n  Derive a seed from the mnemonic using BIP39's PBKDF2-based derivation logic.\n  Encrypt this seed to disk with AES-GCM, using a random nonce, and a key derive from the password using PBKDF2-HMAC-SHA256 with 128000 iterations, using a random salt.\n  To unlock a wallet already created, a user provides the password and the wallet attempts to decrypt the stored data.\n​To restore an existing account from a BIP39 passphrase, a similar process as initialization is performed, except that the wallet will derive the seed from the mnemonic instead of picking random mnemonic.\n​The two risks we identified here are:\n  The absence of checks on the password's length: since the password is sufficient to access the seed given the wallet's on-disk stored secret, the password should in theory have at least as much entropy as the mnemonic, and in practice should be practically hard to crack. We thus recommend to enforce a minimal password length, for example of 16 characters.\n  Copies of secret values (password, seed, and derive private keys) are likely to remain in memory after wallet software execution, which is an intrinsic limitation garbage-collected languages such as Scala.\n  Another process or user sharing the same memory address space could potentially recover the secrets, and they could also appear in crash dumps. To the best of our knowledge, there is no effective mitigation in pure Scala.\n​\nPoW validation ​After previously reviewing the security of the Autolykos PoW, we performed another round of review focusing on its latest verification logic, and notably the changes in the commit eb0f85a.\n​The main relevant file is AutolykosPowScheme,and other important operations are for example implemented in HeadersProcessor and ModifierValidator.\n​We checked that the implemented verification logic is consistent with that specified in the Autolykos specifications, and that it is properly integrated in the block header validation logic.\n​We believe the following points should be addressed:\n  Stricter validation of k and n: although the class enforces k\u0026lt;=32 (number of elements in the solution) and n\u0026lt;31 (log2 of the total number of elements), weak could still be created from the authorized parameters. The validate() function may therefore have additional validation that n and k are equal to the intended values.\n  Assert that k and n are positive values, since currently negative ones (as Ints) would pass the assert statements.\n  ","link":null,"permalink":"https://ergoplatform.org/en/blog/2020_01_12_security_audit/","subtitle":null,"title":"Security Audit (by Jean Philippe Aumasson)"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_01_12_security_audit/","permalink":"https://ergoplatform.org/en/news/2020_01_12/","subtitle":"We would like to announce that Ergo has successfully passed security audit of certain (most critical) parts of the code","title":"Security Audit (by Jean Philippe Aumasson)"},{"contents":"","link":"https://twitter.com/chepurnoy/status/1214518013418000384","permalink":"https://ergoplatform.org/en/news/2020_01_08/","subtitle":"Alexander Chepurnoy: \"your paper Bypassing Non-Outsourceable Proof-of-Work Schemes Using Collateralized Smart Contracts has been accepted for publication at WTSC@FC20\"","title":""},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.2.0","permalink":"https://ergoplatform.org/en/news/2020_01_07/","subtitle":"This release introduces breaking changes and improvements, ~3-4x faster-bootstrapping 👍 Resync needed, more details in the description of the release 🔥 ","title":"Ergo Mainnet 3.2.0 released"},{"contents":"","link":"https://twitter.com/coinbarn/status/1211026427686064133","permalink":"https://ergoplatform.org/en/news/2020_01_04/","subtitle":"Download binaries for MacOS, Windows and Linux","title":"Coinbarn wallet now has its desktop version"},{"contents":"","link":"https://ergoplatform.org/en/blog/2019_12_31_ergo_tool/","permalink":"https://ergoplatform.org/en/news/2020_01_04_2/","subtitle":"ErgoTool is a command line interface (CLI) for Ergo blockchain","title":"Make Your Own Ergo Wallet: Managing Ergo Coins with ErgoTool"},{"contents":"Introduction ErgoTool is a command line interface (CLI) for Ergo blockchain. You can use ErgoTool without running your own Ergo node. Even though running a node is the most secure way to communicate with the Ergo blockchain network, ErgoTool however, aims to provide more foundational tools at your disposal. Surely, you still can use it with your own running node.\nIn this post we will walk through simple steps to generate a mnemonic phrase, create a local secret storage and use it to send ERGs between addresses, all with the help of ErgoTool commands.\nGetting Started First of all we need to install ErgoTool on our system from sources by following the installation instructions. In the directory where we cloned ErgoTool there is ergo-tool.sh script which we are going to use to run commands. Run the following command to check ErgoTool is installed correctly.\n$ ./ergo-tool.sh help command name is not specified (run ergo-tool without arguments to list commands) Command Name:\thelp Usage Syntax:\tergo-tool help \u0026lt;commandName\u0026gt; Description:\tprints usage help for a command Doc page:\thttps://aslesarenko.github.io/ergo-tool/api/org/ergoplatform/appkit/ergotool/HelpCmd.html Let's see what we get here. ErgoTool outputs the error message with the information about help command. This is a typical output of ErgoTool when one of the known commands is specified, but it is used incorrectly. As we can learn from the message, the help command requires us to specify additional \u0026lt;commandName\u0026gt; argument. Also, each command has an API doc page with all the details about command execution, so its url is shown here.\nCreate a New Mnemonic Phrase Mnemonic is a random sequence of characters which is used to generate a master key according to Hierarchical Deterministic Wallets specification. For convenience random sequence of english words is used, but this is not required. Run the following command to generate a new mnemonic phrase:\n$ ./ergo-tool.sh mnemonic bird harbor wheat innocent business disease busy quick yellow trust time oil enter situate moon Write it down on a paper and keep in a safe and secret place. As an additional security measure you can create an arbitrary mnemonic password. In some sense it can serve like an additional non-vocabulary word in the mnemonic. Mnemonic password is optional and is used for additional security. If you decide to use mnemonic password you should also write it down and keep in a secret and probably different from mnemonic place.\nImportant, both mnemonic phrase and mnemonic password are required to restore secret keys, if you lose any of them then you will not be able to regenerate you master key again.\nNext let's use the generated mnemonic to create a storage with a master secret key.\nCreate a New Encrypted Storage For better security neither mnemonic phrase nor password is required by ErgoTool to perform the transaction signing. Instead, the secret key from the encrypted storage is required to sign spending transaction. We can generate a secret key and store it in an encrypted storage using createStorage command.\n$ ./ergo-tool.sh help createStorage Command Name:\tcreateStorage Usage Syntax:\tergo-tool createStorage [\u0026lt;storageDir\u0026gt;=\u0026#34;storage\u0026#34;] [\u0026lt;storageFileName\u0026gt;=\u0026#34;secret.json\u0026#34;] Description:\tCreates an encrypted storage file for the mnemonic entered by the user Doc page: https://aslesarenko.github.io/ergo-tool/api/org/ergoplatform/appkit/ergotool/CreateStorageCmd.html $ ./ergo-tool.sh createStorage Enter mnemonic phrase\u0026gt; bird harbor wheat innocent business disease busy quick yellow trust time oil enter situate moon Mnemonic password\u0026gt; Repeat mnemonic password\u0026gt; Storage password\u0026gt; Repeat storage password\u0026gt; Storage File: storage/secret.json A master secret key is generated from the (mnemonic phrase, mnemonic password) pair and saved encrypted in the storage/secret.json file. Mnemonic itself is not stored in the file and there is no way to restore it from the file, even if you know the passwords.\nPlease take care to enter correct mnemonic password, the one you chose and saved before. Since a mnemonic password is optional you can leave it empty by pressing enter.\nIf you forget the storage password (aka encryption password), you will not be able to use that storage file anymore, however, you can always restore your secret keys from (mnemonic phrase, mnemonic password) pair and thus create a new storage file with a new password.\nKeep your storage file and storage password in secret, anyone who obtain both your storage file and storage password will be able to decipher it and access secret keys.\nExtracting Data From Storage Secret storage contains master secret key and as a result can be used to compute both the public key and the pay-to-public-key address which correspond to that secret key. The extractStorage command is doing just that.\n$ ./ergo-tool.sh help extractStorage Command Name:\textractStorage Usage Syntax:\tergo-tool extractStorage \u0026lt;storage file\u0026gt; address|masterKey|publicKey|secretKey mainnet|testnet Description:\tReads the file, unlocks it using password and extract the requested property from the given storage file. Doc page:\thttps://aslesarenko.github.io/ergo-tool/api/org/ergoplatform/appkit/ergotool/ExtractStorageCmd.html $ ./ergo-tool.sh extractStorage storage/secret.json address mainnet Storage password\u0026gt; 9iHiSAg3ko2ZGxR2vhc1Aem3tShqfzEPDAF7XK5cdtbZ3Ut2CCf Here the command transforms the secret key to the corresponding public key and then creates the pay-to-public-key address on the mainnet.\nThe same way we can obtain public key, private key and other data from the storage.\n$ ./ergo-tool.sh extractStorage storage/secret.json secretKey mainnet Storage password\u0026gt; 55dfde63c9b6b4f47683592e85ee997ba2e93507f38ba3f9c82933bcfbc677ca $ ./ergo-tool.sh extractStorage storage/secret.json publicKey mainnet Storage password\u0026gt; 03f07aecb145a85920bf6e9be80efe5f1cd1a165b45ad3aa8e5c4ca3ba50856bb8 Listing Unspent Boxes ErgoTool has the special command to list all available (aka unspent) boxes for a given address.\n$ ./ergo-tool.sh listAddressBoxes 9f4QF8AD1nQ3nJahQVkMj8hFSVVzVom77b52JU7EW71Zexg6N8v BoxId NanoERGs 4840cb6facc20b765085db0ad24768ed0c5e7afd413e8e58e597c33a993f8119 4987000000 if we specify --print-json option, then ErgoTool will output all the boxes in json format\n$ ./ergo-tool.sh listAddressBoxes --print-json 9f4QF8AD1nQ3nJahQVkMj8hFSVVzVom77b52JU7EW71Zexg6N8v [{\u0026#34;boxId\u0026#34;:\u0026#34;4840cb6facc20b765085db0ad24768ed0c5e7afd413e8e58e597c33a993f8119\u0026#34;,\u0026#34;value\u0026#34;:4987000000,\u0026#34;ergoTree\u0026#34;:\u0026#34;0008cd02472963123ce32c057907c7a7268bc09f45d9ca57819d3327b9e7497d7b1cc347\u0026#34;,\u0026#34;creationHeight\u0026#34;:125646,\u0026#34;assets\u0026#34;:[],\u0026#34;additionalRegisters\u0026#34;:{},\u0026#34;transactionId\u0026#34;:\u0026#34;820c688f4b9d709924ba0186ee930a7df374d8852920bc769fc1f1d0b313e5ab\u0026#34;,\u0026#34;index\u0026#34;:2}] Transfer Coins Now, with secret key stored securely in the encrypted storage file, we can use ErgoTool to transfer coins from our address to some other recipient address. The command to do that is send.\n./ergo-tool.sh help send Command Name:\tsend Usage Syntax:\tergo-tool send \u0026lt;storageFile\u0026gt; \u0026lt;recipientAddr\u0026gt; \u0026lt;amountToSend\u0026gt; Description:\tsend the given \u0026lt;amountToSend\u0026gt; to the given \u0026lt;recipientAddr\u0026gt; using the given \u0026lt;storageFile\u0026gt; to sign transaction (requests storage password) Doc page:\thttps://aslesarenko.github.io/ergo-tool/api/org/ergoplatform/appkit/ergotool/SendCmd.html The storage file is necessary in order to access secret key and generate a signature. The storage password will be requested by ErgoTool to unlock and decipher the file content. The command send supports the --dry-run option which forces ErgoTool to create the signed transaction, but instead of sending it to the blockchain, ErgoTool prints the transaction on the console.\n$ ./ergo-tool.sh send --dry-run storage/E1.json 9hHDQb26AjnJUXxcqriqY1mnhpLuUeC81C4pggtK7tupr92Ea1K 5000000 Storage password\u0026gt; Creating prover... Ok Loading unspent boxes from at address 9f4QF8AD1nQ3nJahQVkMj8hFSVVzVom77b52JU7EW71Zexg6N8v... Ok Signing the transaction... Ok Tx: { \u0026#34;id\u0026#34;: \u0026#34;2633733a1d81b8fc747d984bdc36fac42cb52118b5057375b081b4c543c62b0e\u0026#34;, \u0026#34;inputs\u0026#34;: [ { \u0026#34;boxId\u0026#34;: \u0026#34;4840cb6facc20b765085db0ad24768ed0c5e7afd413e8e58e597c33a993f8119\u0026#34;, \u0026#34;spendingProof\u0026#34;: { \u0026#34;proofBytes\u0026#34;: \u0026#34;060e7c99c9c9cecf89ec5c3e7b692075e0b3415318f8064c64f7f01401ac29c6637b44535151e51d43d4cd25e05ad459dbe33718a99a22dd\u0026#34;, \u0026#34;extension\u0026#34;: {} } } ], \u0026#34;dataInputs\u0026#34;: [], \u0026#34;outputs\u0026#34;: [ { \u0026#34;boxId\u0026#34;: \u0026#34;4eaed414ae763158126859bbf912fa9ffb9ea67ac13d81d473b1c81ec65b06fd\u0026#34;, \u0026#34;value\u0026#34;: 5000000, \u0026#34;ergoTree\u0026#34;: \u0026#34;ErgoTree(0,WrappedArray(),Right(ConstantNode(SigmaProp(ProveDlog(ECPoint(6ba5cf,8ae5ac,...))),SSigmaProp)),80,[B@1117fff48)\u0026#34;, \u0026#34;creationHeight\u0026#34;: 130508, \u0026#34;assets\u0026#34;: [], \u0026#34;additionalRegisters\u0026#34;: {}, \u0026#34;transactionId\u0026#34;: \u0026#34;2633733a1d81b8fc747d984bdc36fac42cb52118b5057375b081b4c543c62b0e\u0026#34;, \u0026#34;index\u0026#34;: 0 }, { \u0026#34;boxId\u0026#34;: \u0026#34;059b426fe2aaef10b6a9a618f0c5b4e97d4dd9931328bf4f52bcf92b0943a42c\u0026#34;, \u0026#34;value\u0026#34;: 1000000, \u0026#34;ergoTree\u0026#34;: \u0026#34;ErgoTree(16,WrappedArray(IntConstant(0), IntConstant(0), ConstantNode(Coll(16,2,4,-96,11,8,-51,2,121,-66,102,126,-7,-36,-69,-84,85,-96,98,-107,-50,-121,11,7,2,-101,-4,-37,45,-50,40,-39,89,-14,-127,91,22,-8,23,-104,-22,2,-47,-110,-93,-102,-116,-57,-89,1,115,0,115,1),Coll[SByte$]), ConstantNode(Coll(1),Coll[SInt$]), IntConstant(1)),Right(BoolToSigmaProp(AND(ConcreteCollection(WrappedArray(EQ(Height$(163),SelectField(ExtractCreationInfo(ByIndex(Outputs$(165),ConstantPlaceholder(0,SInt$),None)),1)), EQ(ExtractScriptBytes(ByIndex(Outputs$(165),ConstantPlaceholder(1,SInt$),None)),SubstConstants(ConstantPlaceholder(2,Coll[SByte$]),ConstantPlaceholder(3,Coll[SInt$]),ConcreteCollection(WrappedArray(CreateProveDlog(DecodePoint(MinerPubkey$(172)))),SSigmaProp))), EQ(SizeOf(Outputs$(165)),ConstantPlaceholder(4,SInt$))),SBoolean)))),4836,[B@111805c40)\u0026#34;, \u0026#34;creationHeight\u0026#34;: 130508, \u0026#34;assets\u0026#34;: [], \u0026#34;additionalRegisters\u0026#34;: {}, \u0026#34;transactionId\u0026#34;: \u0026#34;2633733a1d81b8fc747d984bdc36fac42cb52118b5057375b081b4c543c62b0e\u0026#34;, \u0026#34;index\u0026#34;: 1 }, { \u0026#34;boxId\u0026#34;: \u0026#34;0638ddb0fe6a8cc6ca4f981f71777f4a6e8aad72d57fdf945b24e0ef4ca714e1\u0026#34;, \u0026#34;value\u0026#34;: 4981000000, \u0026#34;ergoTree\u0026#34;: \u0026#34;ErgoTree(0,WrappedArray(),Right(ConstantNode(SigmaProp(ProveDlog(ECPoint(472963,7c85fd,...))),SSigmaProp)),80,[B@111816258)\u0026#34;, \u0026#34;creationHeight\u0026#34;: 130508, \u0026#34;assets\u0026#34;: [], \u0026#34;additionalRegisters\u0026#34;: {}, \u0026#34;transactionId\u0026#34;: \u0026#34;2633733a1d81b8fc747d984bdc36fac42cb52118b5057375b081b4c543c62b0e\u0026#34;, \u0026#34;index\u0026#34;: 2 } ] } Note the \u0026ldquo;ergoTree\u0026rdquo; scripts are deserialized and printed as abstract syntax trees. This printing format can be regulated by additional options so that the scripts can be printed as human readable ErgoScript. (Not yet implemented, but somewhere on the roadmap.)\nIf we exclude --dry-run option, the transaction will be sent and included in the blockchain.\n$ ./ergo-tool.sh send storage/E1.json 9hHDQb26AjnJUXxcqriqY1mnhpLuUeC81C4pggtK7tupr92Ea1K 5000000 Storage password\u0026gt; Creating prover... Ok Loading unspent boxes from at address 9f4QF8AD1nQ3nJahQVkMj8hFSVVzVom77b52JU7EW71Zexg6N8v... Ok Signing the transaction... Ok Sendng the transaction... Ok Server returned tx id: \u0026#34;c5710af17f5124a232a5ef731fdf94a493025334c2a7d5a79e9923210972b962\u0026#34; The newly created transaction will be broadcast all over the blockchain and miners start to include it in a new block. Once the new block with our transaction is mined and accepted by the network our transfer is confirmed and we can see it in Explorer.\nWe can also list boxes of the recipient address and see the coin we created among others (until it is spent by the recipient)\n$ ./ergo-tool.sh listAddressBoxes 9hHDQb26AjnJUXxcqriqY1mnhpLuUeC81C4pggtK7tupr92Ea1K BoxId NanoERGs 252c5ce38fc367001ea48fa6813e6252ebc169288d9b5392c572edb55380b3cd 5000000 6df9dbf08b4859b7e280afbd0822dcf20dba5bf8e3e33b78fe278df6597276f1 2000000 d47f958b201dc7162f641f7eb055e9fa7a9cb65cc24d4447a10f86675fc58328 1000000 e050a3af38241ce444c34eb25c0ab880674fc23a0e63632633ae14f547141c37 1000000 b50ed8c2953fd33b52af816c4caa63ec5b6d236a262a5a192534695c3478da78 1000000 26d6e08027e005270b38e5c5f4a73ffdb6d65a3289efb51ac37f98ad395d887c 10000000000 Security Notes ErgoTool is created with security in mind and tries its best to safeguard the usage of sensitive information like mnemonic phrases (which are never stored persistently), passwords (which are never shown on the screen) etc. In addition, secret keys are never stored on local disk unencrypted and surely never sent anywhere.\nConclusion ErgoTool is designed to look and feel like a typical CLI utility:\n which is easy to use and fast to run from command line can be scriptable via shell scripts has built-in usage help  At the same time ErgoTool is designed to be easily extensible:\n implemented in high-level language Scala reuses the core libraries which are used in Ergo network client open-sourced and fully documented  This last point is especially important as many new commands can be easily added to ErgoTool, thanks to its architecture. If you need a specific feature or a command please file an issue or maybe even a PR.\nThe extensibility of ErgoTool is a subject of the next planned blog post, stay tuned!\nReferences  Ergo Site Ergo Sources Ergo Appkit Ergo Tool  ","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_12_31_ergo_tool/","subtitle":null,"title":"Make Your Own Ergo Wallet: Managing Ergo Coins with ErgoTool"},{"contents":"Ergo GPU Mining This article will help you start mining Ergo using a GPU.\nErgo mining is based on Autolykos, a Proof-of-Work algorithm designed to be ASIC and pool resistant. Miners have to perform memory-hard computations~(at least 4 GB memory is needed, but the current most efficient implementation utilizes between 8 GB of vRAM) that makes Ergo friendly for GPU mining. In addition, Autolykos requires access to private keys, thereby preventing mining pool formation. As soon as a correct solution is found, the miner broadcasts the block along with the solution and is able to collect the block reward after a delay of 720 blocks using the secret he used during mining. The rest of the network verifies the solution using the miner's public key and this verification can be done very efficiently, requiring less than a kilobyte of memory.\nPrerequisites In order to mine, you need the following setup:\n A full node with wallet initialized and fully synced. A computer with a GPU that is recognized by your OS. Ergo mining software for your operating system. Ergo supports both AMD and NVidia GPUs.  Ergo mining requires a configured and synchronized Ergo node and at least one GPU for mining. You may use multiple GPUs if you wish (to multiply your hashing power) but you only need one Ergo node.\nNote that Ergo no longer works in Java 8 due to its lack of strong cryptography. You must use Java \u0026gt;= 9\nThe links for setting up the mining software are:\n Nvidia Miner AMD Miner  !!!WARNING!!! Since Autolykos utilizes private keys, you should never use untrusted mining software. Check that the software is open-source and validated by the community\nSync node and Initialize Wallet Follow the steps of setting up a node as described in the tutorial.\nEdit the config file of the node and add the following line.\nergo.node.mining = true\nEnsure that the wallet is initialized and you are in possession of the correct mnemonic sentence.\nFinally, ensure that the node is synced as described here.\nConfigure and run the miner On the computer where the miner will be running, create a file called config.json with the following content\n{ \u0026#34;seed\u0026#34;: \u0026#34;Attention!!! Replace this with your mnemonic sentence and keep it secret or you will get robbed\u0026#34;, \u0026#34;node\u0026#34;: \u0026#34;http://192.168.1.100:9053\u0026#34;, \u0026#34;keepPrehash\u0026#34;: false } where:\n seed is the mnemonic sentence from your node's wallet obtained in the previous step. node is the URL of your node. keepPrehash is an optimization parameter. If set to true, the miner will consume at most 8GB of memory. If set to false the miner will consume at most 4GB of memory, but its performance will be for about 25% lower.  Run your miner using the command ./auto.out config.json (for Linux) or miner.exe config.json (for Windows) and enjoy receiving block rewards!\nOnce you have received any mining rewards, you can view the balance as described here and then withdraw the funds as described here.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_12_22_mining_for_fun/","subtitle":null,"title":"Mining Ergo for Fun and Profit"},{"contents":"","link":"https://twitter.com/avslesarenko/status/1209432757128089600","permalink":"https://ergoplatform.org/en/news/2019_12_24/","subtitle":null,"title":"ErgoTool: A Command Line Interface for Ergo blockchain"},{"contents":"","link":"https://twitter.com/ergoplatformorg/status/1209173611124330501","permalink":"https://ergoplatform.org/en/news/2019_12_24_2/","subtitle":"https://github.com/robkorn/blockchain-ruminations/blob/master/universal_dApp_interface.md","title":"Universal dApp Interface \u0026 Package Standard"},{"contents":"","link":"https://twitter.com/chepurnoy/status/1209124149802745856","permalink":"https://ergoplatform.org/en/news/2019_12_23/","subtitle":"(combining cryptographic sigma-protocols with predicates on blockchain state and spending transaction)","title":"Early description of Ergo contractual approach"},{"contents":"","link":"https://twitter.com/chepurnoy/status/1209027361150308352","permalink":"https://ergoplatform.org/en/news/2019_12_23_2/","subtitle":"Ergo is using highly efficient AVL+ tree implementation for authenticating the state, proof size is few times smaller than in Ethereum! details: https://eprint.iacr.org/2016/994","title":"Ergo is using highly efficient AVL+ tree"},{"contents":"","link":"https://twitter.com/chepurnoy/status/1208820234406318080","permalink":"https://ergoplatform.org/en/news/2019_12_22/","subtitle":"https://github.com/ergoplatform/ergo/wiki/Mining-Ergo-for-Fun-and-Profit","title":"New tutorial: 'Mining Ergo for Fun and Profit'"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.1.5","permalink":"https://ergoplatform.org/en/news/2019_12_19/","subtitle":"Node UI (/panel) updated, cross-build for Scala 2.11 and few fixes. Details in the description of the release","title":"Ergo Mainnet 3.1.5 released"},{"contents":"Since the launch of the Ergo mainnet half a year ago, there has been an incredible amount of development and progress in the Ergo ecosystem. Auction smart contracts, crowdfunding, zero interest loans, privacy preserving protocols, and much more. Every week or two there's some truly novel idea or development put out, however if you're just an average blockchain enthusiast it's likely you haven't heard too much.\nWhy is that? The reason is that the Ergo ecosystem is making incredible strides forward in the technology side of things, however there is a distinct lack of content to consume for the average user who is interested. Great, Ergo has NiPoPoW support, but what the heck does that mean and why does it matter?\nTo aid in mending this, I am proud to announce the launch of the Ergo Cast.\nThe Ergo Cast is the Ergo ecosystem's premier podcast where we dive into the nitty-gritty details in a fun and approachable format. The goal is to bring life to the technology by explaining why it's so unique while showing off the distinct personalities behind the avatars who are developing it all.\nI, Robert Kornacki, am the host of the podcast and will be guiding you through understanding Ergo one episode at a time with the help of other key members in the community who will come on.\nA lot of time was spent in getting this project from a mere idea in the back of my head, all the way to now being publicly released so that we could have this as a small Christmas present for the community who have been very supportive of the project as a whole.\nThe podcast will start out on a monthly schedule and is available via Youtube, MP3 RSS Feed, and Itunes Podcasts, all of which you can easily find by going to https://ergocast.io. Each episode has time stamps so that you can easily skim through and learn about all the topics that you actually care about.\nIn, Episode #1: Understanding Ergo And It's History , I was joined by Alex Chepurnoy who is one of the core developers and as a matter of fact, the original person who came up with the idea of building Ergo in the first place. We went in depth on why Ergo matters, why it was a necessity that it came to be, what are some of key differentiating benefits of Ergo, and we even covered the history behind what caused Alex to start an entire new cryptocurrency project from the ground-up.\nIf that got you interested, here is a list of all of the topics we hit during the whole episode:\n The Science Behind Ergo Ergo Smart Contracts At A High Level Ergo's ASIC \u0026amp; Pool Resistant PoW Algorithm Summary Of Numerous Innovations Ergo Implements Ergo Smart Contract Implementation Successes What Inspired You To Create Ergo In The First Place How To Join The Ergo Community Biggest Roadblock And Success In Launching Ergo Who Is Ergo For? Local Currencies On Ergo (Kenya Ex. Potential Use Case) Blockchains Actually Becoming Useful \u0026amp; Why Ergo Exists Closing Remarks  All of the topics above are linked timestamps so you can jump right in by going to the Ergo Cast Website.\nI'll be looking forward to helping break down Ergo into digestible episodes month-by-month, and hope to hear from you, the community, on what you'd like to see in the following episodes.\nHope you enjoy the episode and have a great Christmas holiday,\n-Robert Kornacki\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_12_16_podcast/","subtitle":null,"title":"The Ergo Cast: Understanding Ergo One Episode At A Time"},{"contents":"","link":"https://ergoplatform.org/en/blog/2019_12_12_new_quest/","permalink":"https://ergoplatform.org/en/news/2019_12_12/","subtitle":"Part I: Technical Aspects","title":"A New Quest for Decentralization"},{"contents":"While most active conversations today in the space are about wider adoption of the blockchain technology (which often means selling out to the Wall St.) and competition with systems like Visa and Mastercard (which often means giving up with decentralization or introducing unclear security assumptions in the name of efficiency), there is the obvious need to revisit the roots of the cryptocurrency movement, which are mostly about decentralization. Many questions to be answered in clear here. Is it okay when 90% of mining power in Bitcoin can gather in one room? Is it okay when 2 or 3 mining pools control majority of hashing power, so can do censorship? Is it okay when almost all the new nodes avoid processing a blockchain from its genesis block? Is it okay when a Proof-of-Work coin developers are doing a hard-fork changing the consensus algorithm to make it GPU-friendly again? Can we summarize all the issues with decentralization? Can we cover most of issues with technical means?\nDecentralization is about many issues lying in many fields, of technical, social, and hybrid kinds. Researchers and developers are trying to find technical solutions, preferably, elegant and efficient. However, for many issues such solutions are not known, thus social solutions are also needed.\nIn this article I will cover only technical aspects of decentralization, namely, decentralization of mining and decentralization of verification.\nDecentralization of Mining The two biggest concerns about decentralization of mining are specialized hardware (such as ASICs) and centralized pools.\nWith ASICs, a big player capable to invest enough money into R\u0026amp;D can get unfair advantage from privately owned efficient hardware. In principle, for any kind of computational activity it is always possible to develop specialized hardware performing better than commodity computing units, such and CPUs and GPUs. However, for different computational tasks R\u0026amp;D efforts and possible outcome could vary a lot. Reasoning behind a search for a perfect (or close enough to perfect) could be quite complex (see e.g. 30 pages long Equihash paper).\nFor most of Proof-of-Work cryptocurrencies (including Bitcoin, Ethereum, ZCash), 2 to 4 centralized mining pools\ncontrol majority of mining power. This could mean easy censorship or frontrunning on applications (for example, reordering exchange orders), as in centralized pools only pool decides block candidate for the whole pool to work on. As a possible outcome, non-outsourceable mining schemes can prevent centralized pools formation. Only Ergo Platform is known for deploying a practical non-outsourceable Proof-of-Work scheme (based on a supposedly memory-harder problem from the Equihash paper) called Autolykos.\nAs an example where social decentralization issues meet the decentralization of mining, sometimes developers of Proof-of-Work are introducing hard-forks to make a Proof-of-Work algorithm GPU-friendly again once ASICs are going to dominate in the mining market for the coin, however, it is always not quite clear why totally legit activity is banned and why developers (along with some users) can do hard-fork for this particular reason.\nDecentralization of Verification Decentralization of verification is about possibility to check validity of blockchain history. Such check provides confidence that nothing bad (i.e not conforming to a protocol) was injected to the blockchain and thus give a user a right to reject malicious chain even if it has absorbed more work than alternatives. There were many talks about such the right in the Bitcoin community when it was partly hot about User-Activated Soft Fork (UASF) idea, and recent article \u0026ldquo;Who secures Bitcoin?\u0026quot; is summarizing this way of thinking well.\nIf verification can be done in reasonable time only by an entity able to spend millions on renting a datacenter, obviously a network is not decentralized. Ideally, it should be possible to check integrity of the whole blockchain on commodity hardware, like a decent laptop.\nHowever, new blockchains also tend to absorb more and more features, and they are not coming for free. Then the huge topic in the research community is about how to make possible to check integrity of the whole blockchain with pruned blocks or system state (or both) under plausible assumptions. Possible solutions here are about bootstrapping state snapshot and blockchain suffix on top of it (popular in Ethereum protocol clients, and formalized in an academic paper even), stateless clients (partially stateless, as implemented in Ergo Platform or fully stateless which do exist only in research papers currently).\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_12_12_new_quest/","subtitle":null,"title":"A New Quest for Decentralization, Part I: Technical Aspects"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.1.4","permalink":"https://ergoplatform.org/en/news/2019_12_04_2/","subtitle":"This minor release includes new API method /script/executeWithContext and new integration tests.","title":"Ergo Mainnet 3.1.4 released"},{"contents":"","link":"https://github.com/coinbarn/ergo-ts","permalink":"https://ergoplatform.org/en/news/2019_12_04_1/","subtitle":"The library for Ergo platform, written in TypeScript, and compiled to JavaScript","title":"Typescript library for Ergo with the support of custom tokens and complex transactions"},{"contents":" With thanks to Robert Kornacki and Denys Zadorozhnyi.\n Ergo Appkit is a library for polyglot development of Ergo Applications based on GraalVM. GraalVM has many great use cases. Expanding on that, in this article we will go through some of the Appkit features inherited from GraalVM and take you step-by-step in learning how to take advantage of them.\n 0. Example Scenario 1. Java Ergo App Development 2. Low-footprint, Fast-startup Ergo Applications 3. Develop Ergo Applications in JavaScript, Python, Ruby 4. Ergo Native Shared Libraries 5. Debug Your Polyglot Ergo Application  Example Scenario We will create a simple console application (called FreezeCoin) in Java which uses the Appkit library. By using Appkit, we will be able to easily send a new transaction to an Ergo node programatically. The transaction will transfer a given amount of Erg into a new box protected by the following Ergo contract written in ErgoScript (see this introduction and more advanced examples to learn more about ErgoScript).\n// Freezer Contract { // Parameters  // freezeDeadline: Int - some future block number after which the box can be spent  // ownerPk: SigmaProp - public key of the new box owner  sigmaProp(HEIGHT \u0026gt; freezeDeadline) \u0026amp;\u0026amp; ownerPk } In short, a box (and therefore the funds within the box) are locked under a contract (or script) on the Ergo blockchain. In order for the box to be spent, the contract must evaluate to true. Thus the individual who wishes to spend the box must ensure that the contract evaluates to true based off of the encoded logic within it.\nOur Freezer contract above checks the following conditions before allowing the box to be spent:\n  The current block number of the Ergo blockchain (aka blockchain HEIGHT) is greater than the specified deadline\n  The spending transaction must be signed by the owner of the secret key corresponding to the ownerPk public key.\n  The first condition forbids anyone from spending the box before the Ergo blockchain grows to the given height. Because new blocks on the blockchain are mined approximately every 2 minutes on average, using the current blockchain height it is easy to define any duration of delay we wish such as 1 day, 1 week, or 1 month. (i.e. (60 / 2) * 24 * 7 = 5040, which is the # of blocks per week).\nWe will now be going in depth on how we can take this Freezer Contract and integrate it with the Apkit library in order to create the FreezeCoin console application so that anyone and everyone can choose to freeze their coins if they so wish. (Granted, this contract/dApp is not actually useful, however it is an effective simple example for displaying how this technology stack works so that you yourself can build useful dApps down the line.)\n1. Java Ergo App Development Appkit aims to provide a set of interfaces which can be used idiomatically in Java. You will feel right at home using Appkit if you are a Java veteran.\nPlease follow the setup instructions for GraalVM and Appkit if you wish to reproduce the examples below.\nTo use Appkit in our Java implementation of FreezeCoin we must add the following dependency in the gradle file\ndependencies { implementation(\u0026#34;org.ergoplatform\u0026#34;, \u0026#34;ergo-appkit_2.12\u0026#34;, \u0026#34;3.1.0\u0026#34;, \u0026#34;compile\u0026#34;) ... } Furthermore at runtime Appkit/our application needs to connect with an Ergo Node via REST API. Often, the node will be running locally and made available at http://localhost:9052/. This is the standard scenario for anyone who has set up a full-node by following these instructions and is using the default configuration.\nHenceforth we will assume that you have setup and started your Ergo Node so that it is available for testing of the application.\nNext, our application will need to know how to be able to a connect to our local running node, in addition to other various settings in order to function properly. We will use a json file with the following configuration parameters which our FreezeCoin app will load at startup.\nfreeze_coin_config.json:\n{ \u0026#34;node\u0026#34;: { \u0026#34;nodeApi\u0026#34;: { \u0026#34;apiUrl\u0026#34;: \u0026#34;http://localhost:9052/\u0026#34;, \u0026#34;apiKey\u0026#34;: \u0026#34;put your secret apiKey generated during node setup here\u0026#34; }, \u0026#34;wallet\u0026#34;: { \u0026#34;mnemonic\u0026#34;: \u0026#34;the mnemonic key used to initialize or restore the wallet of the node\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;the password you chose to protect the wallet\u0026#34;, \u0026#34;mnemonicPassword\u0026#34;: \u0026#34;the password you chose to protect the mnemonic\u0026#34; }, \u0026#34;networkType\u0026#34;: \u0026#34;TESTNET\u0026#34; }, \u0026#34;parameters\u0026#34;: { \u0026#34;newBoxSpendingDelay\u0026#34;: \u0026#34;30\u0026#34;, \u0026#34;ownerAddress\u0026#34;: \u0026#34;3WzR39tWQ5cxxWWX6ys7wNdJKLijPeyaKgx72uqg9FJRBCdZPovL\u0026#34; } } Here apiKey is the secret key required for API authentication which can be acquired as described here. Your mnemonic is the secret phrase obtained during setup of a new wallet.\nHow our app will work is that the user will launch it from the command line and provide one argument. This argument is the amount of value (in NanoErgs) which they wish to freeze/lock under the Freezer contract which we wrote above.\nOur first step for our FreezeCoin app will be to read the configuration json file we just created and to accept the command line argument from the user:\npublic static void main(String[] args) { long amountToSend = Long.parseLong(args[0]); // positive value in NanoErg  ErgoToolConfig conf = ErgoToolConfig.load(\u0026#34;freeze_coin_config.json\u0026#34;); // the rest of the code discussed below  ... } With these acquired, we can now obtain the spending delay and the owner address which were defined in the json config file.\nint newBoxSpendingDelay = Integer.parseInt(conf.getParameters().get(\u0026#34;newBoxSpendingDelay\u0026#34;)); Address ownerAddress = Address.create(conf.getParameters().get(\u0026#34;ownerAddress\u0026#34;)); Next we need to connect to the running Ergo node from our Java application so that we can use the data we just parsed and post something on-chain. This is done by creating an ErgoClient instance which uses our pre-defined values for our node from the json config file as well.\nErgoNodeConfig nodeConf = conf.getNode(); ErgoClient ergoClient = RestApiErgoClient.create(nodeConf); Now that we have an instance of ErgoClient, we can execute any block of code and have access to the current blockchain context.\nString txJson = ergoClient.execute((BlockchainContext ctx) -\u0026gt; { // use ctx here to create and sign a new transaction  // then send it to the node }); The lambda passed to execute is called when the current blockchain context is loaded from the Ergo node. In this lambda we shall put our application logic.\nFirst we start with some auxiliary steps.\n// access the wallet embedded in the Ergo node // (using the wallet specified via mnemonic we put in freeze_coin_config.json) ErgoWallet wallet = ctx.getWallet(); // calculate total amount of NanoErgs we need to send to the new box // including paying for transaction fees long totalToSpend = amountToSend + Parameters.MinFee; // request for unspent boxes that cover the required amount of NanoErgs from the wallet Optional\u0026lt;List\u0026lt;InputBox\u0026gt;\u0026gt; boxes = wallet.getUnspentBoxes(totalToSpend); if (!boxes.isPresent()) throw new ErgoClientException( \u0026#34;Not enough coins in your specified wallet to pay \u0026#34; + totalToSpend, null); // create a \u0026#34;prover\u0026#34;, which is a special object that will be used for signing the transaction // the prover should be configured with your wallet\u0026#39;s secrets, which are necessary to generate signatures (aka proofs) ErgoProver prover = ctx.newProverBuilder() .withMnemonic( nodeConf.getWallet().getMnemonic(), nodeConf.getWallet().getPassword()) .build(); At this point we have the input boxes chosen for our spending transaction, but we now need to create an output box with the specified amountToSend and locked under the Freezer contract.\n// the only way to create a transaction is using the tx builder obtained from the context // the builder uses the context to access necessary blockchain data. UnsignedTransactionBuilder txB = ctx.newTxBuilder(); // create new box using new builder obtained from the transaction builder // in this case we compile a new ErgoContract from the Freezer ErgoScript code OutBox newBox = txB.outBoxBuilder() .value(amountToPay) .contract(ctx.compileContract( ConstantsBuilder.create() .item(\u0026#34;freezeDeadline\u0026#34;, ctx.getHeight() + newBoxSpendingDelay) .item(\u0026#34;ownerPk\u0026#34;, ownerAddress.getPublicKey()) .build(), \u0026#34;{ sigmaProp(HEIGHT \u0026gt; freezeDeadline) \u0026amp;\u0026amp; ownerPk }\u0026#34;)) .build(); Note, in order to compile ErgoContract from the Freezer script source code the compileContract method requires that we provide values for named constants which are used within the script. If no such constants are used, then ConstantsBuilder.empty() can be passed to it.\nIn this case we pass the public key of the new box owner into the ownerPk placeholder in the script. To repeat from earlier, this means that the box can only be spent by the owner of the corresponding secret key.\nNext, we create an unsigned transaction using all the data we've put together thus far.\n// provide the transaction builder with which boxes we are going to spend, which outputs // should be created, the total transaction fees, and the address for change to be sent to UnsignedTransaction tx = txB.boxesToSpend(boxes.get()) .outputs(newBox) .fee(Parameters.MinFee) .sendChangeTo(prover.getP2PKAddress()) .build(); And finally we:\n Use the prover to sign the built transaction Thus obtain a SignedTransaction instance Use the blockchain context to send the signed transaction to the Ergo node.  The resulting txId can be used to refer to this transaction later however we do not use it here.\nSignedTransaction signed = prover.sign(tx); String txId = ctx.sendTransaction(signed); return signed.toJson(true); As you may have noticed, for our final step we show off that it is possible to serialize the signed transaction into a Json string with pretty printing turned on. Look at the full source code of the example for more details and for using it as a template in your own application.\n Now with all of the code set in stone, we can run our FreezeCoin application using the following steps (assuming you are in the directory where you cloned ergo-appkit-examples).\n$ pwd the/directory/you/cloned/ergo-appkit-examples $ ./gradlew clean shadowJar This will assemble the build/libs/appkit-examples-3.1.0-all.jar file containing our FreezeCoin Java application and all of its dependencies in a single fat jar. Note, this step has to be repeated after any changes are made to the Java source code of our application.\nHaving created our application, we can now use our FreezeCoin app:\n$ java -cp build/libs/appkit-examples-3.1.0-all.jar \\  org.ergoplatform.appkit.examples.FreezeCoin 1000000000 You will get something along the lines of this output in the console.\nAnd with that your transaction was accepted by the Ergo node and broadcast into the network where it shall lay await in the transaction pool to be added to a block. Once a miner selects and adds it to a block, your coins will be officially \u0026ldquo;frozen\u0026rdquo; within the newly created box based off of the values you provided to the FreezeCoin application.\nThe example assumes the Ergo node (and the embedded wallet) is owned by the FreezeCoin user. However this is not strictly required and the Appkit interfaces can be used to create and send new transactions using arbitrary public Ergo nodes.\n2. Low-footprint, Fast-startup Ergo Applications As you may know, using Java for short-running processes has a lot of drawbacks. Applications tend to suffer from long startup times and relatively high memory usage.\nLet's run FreezeCoin using the time command to get the real (wall-clock elapsed time) it takes the entire program to run from start to finish. We use the -l flag to print the memory usage as well.\n$ /usr/bin/time -l java -cp build/libs/appkit-examples-3.1.0-all.jar \\  org.ergoplatform.appkit.examples.FreezeCoin 1000000000 ... 4.97 real 8.41 user 0.69 sys 513703936 maximum resident set size 0 average shared memory size 0 average unshared data size 0 average unshared stack size 125010 page reclaims 1216 page faults 0 swaps 0 block input operations 0 block output operations 13 messages sent 86 messages received 1 signals received 2384 voluntary context switches 17409 involuntary context switches As seen above, this tiny application took 2 parallel threads almost 4 seconds to run. Most of that time can be attributed to the JVM startup and the background JIT compiler running. This is quite sub-par performance, and we know we can do a lot better.\nLuckily, GraalVM provides us with the perfect solution.\nWe can solve this inherent issue with the JVM by compiling the Java code ahead-of-time into a native executable image via GraalVM. This skips over the need to use the Java just-in-time compiler at runtime.\nThe experience for us (the developer using GraalVM) is quite similar to a conventional compiler like gcc. Note, we may need to run ./gradlew clean shadowJar first.\n$ ./gradlew clean shadowJar $ native-image --no-server \\  -cp build/libs/appkit-examples-3.1.0-all.jar\\  --report-unsupported-elements-at-runtime\\  --no-fallback -H:+TraceClassInitialization -H:+ReportExceptionStackTraces\\  -H:+AddAllCharsets -H:+AllowVMInspection -H:-RuntimeAssertions\\  --allow-incomplete-classpath \\  --enable-url-protocols=http,https org.ergoplatform.appkit.examples.FreezeCoin freezecoin [freezecoin:3133] classlist: 35,217.78 ms [freezecoin:3133] (cap): 6,063.07 ms [freezecoin:3133] setup: 8,268.99 ms [freezecoin:3133] (typeflow): 60,238.25 ms [freezecoin:3133] (objects): 33,009.06 ms [freezecoin:3133] (features): 4,796.86 ms [freezecoin:3133] analysis: 102,876.01 ms [freezecoin:3133] (clinit): 11,642.43 ms [freezecoin:3133] universe: 13,718.96 ms [freezecoin:3133] (parse): 5,053.18 ms [freezecoin:3133] (inline): 18,317.24 ms [freezecoin:3133] (compile): 44,806.82 ms [freezecoin:3133] compile: 72,288.24 ms [freezecoin:3133] image: 7,955.29 ms [freezecoin:3133] write: 2,872.25 ms [freezecoin:3133] [total]: 243,813.30 ms The simple command above produces a complete native executable called freezecoin.\nTo emphasize, this executable isn’t a mere launcher for the JVM. In fact it doesn’t link to the JVM or bundle the JVM in any way. native-image compiles the FreezeCoin code, as well as any Java libraries it depends on, all the way down to simple machine code.\nIf we look at the libraries which freezecoin uses you can see that it only uses standard system libraries. Thus, we can move just this one executable to another system which doesn't have a JVM installed and it will run there without issue.\n$ otool -L freezecoin # ldd freezecoin on Linux freezecoin: /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.50.4) /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1455.12.0) /usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11) If we time this new freezecoin executable, we can see that it starts approximately 8x faster, and uses around 6x less memory. What this means is that you don’t feel that palpable pause you always get when running a short-running program with the JVM.\n$ DYLD_LIBRARY_PATH=$GRAAL_HOME/jre/lib /usr/bin/time -l ./freezecoin 1800000000 0.43 real 0.15 user 0.03 sys 81289216 maximum resident set size 0 average shared memory size 0 average unshared data size 0 average unshared stack size 20079 page reclaims 0 page faults 0 swaps 0 block input operations 0 block output operations 13 messages sent 86 messages received 0 signals received 11 voluntary context switches 138 involuntary context switches This is just one of the great benefits of GraalVM which we get to take advantage of with Appkit.\n3. Develop Ergo Applications in JavaScript, Python, Ruby GraalVM supports so called polyglot programming in which different components of an application can be developed using the most suitable language and then seamlessly combine together at runtime. In this way a unique library written in say Java can be used in a node.js application written in JavaScript for example.\nTo support polyglot programming GraalVM platform has it's own high performance implementations of popular languages. We are going to take advantage of this for our FreezeCoin example project to show you how easy this is to use your preferred language.\nBefore running the examples below (in JavaScript, Python and Ruby) please make sure that you have the Java version of FreezeCoin working locally in order to ensure everything is set up correctly.\nJavaScript GraalVM can run JavaScript and Node.js applications out of the box. It is compatible with the ECMAScript 2019 specification. Additionally, js and node launchers accept special --jvm and --polyglot command line options which allow JS scripts to access Java objects and classes.\nGiven that being the case, a JS implementation of FreezeCoin can be easily written using the Appkit API interface. Please see the full source code of FreezeCoin JS implementation for details. The following command use node launcher to execute FreezeCoin.js script.\n$ node --jvm --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\  js-examples/FreezeCoin.js 1000000000 Note, the paths in the command are relative to the root of ergo-appkit-examples project directory.\nPython GraalVM can run Python scripts, though the Python implementation is still experimental (see also compatibility section for details).\nPython example of FreezeCoin can be executed using the following command\n$ graalpython --jvm --polyglot --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\  python-examples/FreezeCoin.py 1900000000 Ruby GraalVM can run Ruby scripts using TruffleRuby implementation, which is however still experimental (see also compatibility section for details). TruffleRuby aims to be fully compatible with the standard implementation of Ruby, MRI, version 2.6.2\nRuby example of FreezeCoin can be executed using the following command\n$ truffleruby --polyglot --jvm --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\  ruby-examples/FreezeCoin.rb 1900000000 4. Ergo Native Shared Libraries Another great benefit of GraalVM is that we can compile Java classes down into a native shared library instead of an executable.\nTo do this we declare one or more static methods as the @CEntryPoint.\npublic class FreezeCoin { ... /** * Entry point callable from C which wraps {@link FreezeCoin#sendTx} */ @CEntryPoint(name = \u0026#34;sendTx\u0026#34;) public static void sendTxEntryPoint( IsolateThread thread, SignedWord amountToSendW, CCharPointer configFileNameC, CCharPointer resBuffer, UnsignedWord bufferSize) throws FileNotFoundException { long amountToSend = amountToSendW.rawValue(); // Convert the C strings to the target Java strings.  String configFileName = CTypeConversion.toJavaString(configFileNameC); String txJson = sendTx(amountToSend, configFileName); // put resulting string into provided buffer  CTypeConversion.toCString(txJson, resBuffer, bufferSize); } ... } We can then compile down to a shared library and an automatically generated header file. Notice the use of the --shared option.\n$ native-image --no-server \\  -cp build/libs/appkit-examples-3.1.0-all.jar\\  --report-unsupported-elements-at-runtime\\  --no-fallback -H:+TraceClassInitialization -H:+ReportExceptionStackTraces\\  -H:+AddAllCharsets -H:+AllowVMInspection -H:-RuntimeAssertions\\  --allow-incomplete-classpath \\  --enable-url-protocols=http,https --shared -H:Name=libfreezecoin -H:Path=c-examples $ otool -L c-examples/libfreezecoin.dylib c-examples/libfreezecoin.dylib: .../c-examples/libfreezecoin.dylib (compatibility version 0.0.0, current version 0.0.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.50.4) /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1455.12.0) /usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11) Now we have the ability to write a C program which uses the library. The interface to our native library does have a bit of boilerplate (because the VM needs to manage a heap, threads, a garbage collector and more), and thus we need to create an instance and provide it our main thread.\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;libfreezecoin.h\u0026gt; int main(int argc, char **argv) { graal_isolate_t *isolate = NULL; graal_isolatethread_t *thread = NULL; if (graal_create_isolate(NULL, \u0026amp;isolate, \u0026amp;thread) != 0) { fprintf(stderr, \u0026#34;graal_create_isolate error\\n\u0026#34;); return 1; } char * configFileName = \u0026#34;freeze_coin_config.json\u0026#34;; // get amountToSend from cmd args and call transaction creation  long amountToSend = atol(argv[1]); char result[1024 * 16]; sendTx(thread, amountToSend, configFileName, result, sizeof(result)); // print out serialized result  printf(\u0026#34;%s\\n\u0026#34;, result); if (graal_detach_thread(thread) != 0) { fprintf(stderr, \u0026#34;graal_detach_thread error\\n\u0026#34;); return 1; } return 0; } We can compile this with our standard system tools and easily run our executable (set LD_LIBRARY_PATH=. on Linux).\n$ clang -Ic-examples -Lc-examples -lfreezecoin c-examples/freezecoin.c -o call_freezecoin $ otool -L call_freezecoin $ DYLD_LIBRARY_PATH=$GRAAL_HOME/jre/lib ./call_freezecoin 1000000000 5. Debugging Your Polyglot Ergo Application You can debug JS, Python and Ruby in IntelliJ, but if for some reason this doesn't work for you or fit with your preferred editor, GraalVM offers another option.\nAll of the GraalVM languages (except for Java) are implemented using the common Truffle framework. Truffle allows for tooling like debuggers to be implemented once and be available for all supported languages.\nAs such we can run our program with the flag --inspect which will give us a link to open in Chrome and will pause the program in the debugger.\n$ ruby --polyglot --jvm --inspect --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\  ruby-examples/FreezeCoin.rb 1900000000 Debugger listening on port 9229. To start debugging, open the following URL in Chrome: chrome-devtools://devtools/bundled/js_app.html?ws=127.0.0.1:9229/30c7da1e-7558a47d09b ... From here we can set breakpoints and continue execution. When it breaks we’ll see values of the variables, can continue again until the next breakpoint, and do everything we've come to expect from debuggers.\nConclusions And with all of that said and done, we see just how easy it is to use Appkit to develop Ergo Applications. Appkit relies on the same exact core libraries which were used in implementing the Ergo consensus protocol. These libraries include the ErgoScript compiler, cryptography, byte code interpreter, data serialisers and the other core components. Using GraalVM we are able to reuse these tried and tested components in different application contexts without any modification or rewriting them ourselves.\nNo matter if you are using Java, JavaScript, Python or Ruby, you can take advantage of Appkit with GraalVM to drastically simplify the process of interacting with the Ergo blockchain while creating native-running (d)Apps.\nStay tuned. In future posts we will introduce you to other interesting potential applications powered by Appkit.\nReferences  Ergo Site Ergo Sources Ergo Appkit Ergo Appkit Examples GraalVM  ","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_12_03_top5/","subtitle":null,"title":"5 Ways Ergo Application Development Is Changed Forever Thanks To Appkit"},{"contents":"","link":"https://ergoplatform.org/en/blog/2019_12_03_top5/","permalink":"https://ergoplatform.org/en/news/2019_12_03_2/","subtitle":"Appkit: A Library for Polyglot Development of Ergo Applications","title":"5 Ways Ergo Application Development Is Changed Forever Thanks To Appkit and GraalVM"},{"contents":"","link":"https://ergoplatform.org/en/blog/2019_12_03_how_to_setup/","permalink":"https://ergoplatform.org/en/news/2019_12_03_1/","subtitle":"Simplified tutorial for new users","title":"How to set up and configure a full Ergo node"},{"contents":"This tutorial explains how to install and run a full Ergo node. It does not cover mining.\nNode security There are a few important aspects of node usage that your wallet and money's safety depends on:\n An Ergo node requires storing security-critical parameters in the configuration file. You should never make this file public. An Ergo node provides a REST API for interacting with the built-in wallet. Sensitive API methods require a security token, which should never be sent over untrusted channels. Access to the Ergo REST API must be restricted to known hosts. In particular, the API must not be accessible from the Internet.  Prerequisites To run an Ergo node you need JRE version \u0026gt;= 8 to be installed. One way to install it is to use Oracle implementation of Java.\nThe next step is to download the latest Ergo client release jar file and create a node configuration file.\nNote that instead of downloading the jar, you can clone the repository and create the jar yourself using SBT by issuing the sbt assembly command.\nDenote by ergo_folder the folder where the jar is kept.\nRunning the node for the first time Create a configuration file ergo.conf with the following text in ergo_folder.\nergo { directory = ${ergo.directory}\u0026#34;/.ergo\u0026#34; node { mining = false } wallet.secretStorage.secretDir = ${ergo.directory}\u0026#34;/wallet/keystore\u0026#34; } The parameter ${ergo.directory} points to the directory where the jar will be run from. Open a command prompt and cd to ergo_folder. Then issue the following command to run the node for the first time:\njava -jar ergo-\u0026lt;release\u0026gt;.jar --mainnet -c ergo.conf The node will start syncing immediately after this. Wait for a few minutes for the API to start and go to the next step.\nNote: You can use any name for the file instead of ergo.conf. All configuration parameters are to be passed through this file and you only need to rewrite parameters that you want to change from the default values. The above config file actually has the default values.\nCompute the hash of your secret First, select a secret to protect your API. Then go to http://127.0.0.1:9053/swagger#/utils/hashBlake2b and call the API to compute the hash of your secret. Refer to the image below.\nCopy the response containing the hash for use in the next step (see below image). In our example, the secret is hello whose hash corresponds to 324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf.\nIMPORTANT You must use a different and strong secret.\nUpdate config file with API key hash Edit the config file ergo.conf and paste the hash copied in the previous step. The file should look as follows:\nergo { directory = ${ergo.directory}\u0026#34;/.ergo\u0026#34; node { mining = false } wallet.secretStorage.secretDir = ${ergo.directory}\u0026#34;/wallet/keystore\u0026#34; } scorex { restApi { # Hex-encoded Blake2b256 hash of an API key. # Should be 64-chars long Base16 string. # below is the hash of the string \u0026#39;hello\u0026#39; # replace with your actual hash apiKeyHash = \u0026#34;324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\u0026#34; } } Initialize wallet Restart the node and go to http://127.0.0.1:9053/panel to access the panel. Then set the API key secret from the previous step. Note that you need to set the secret and not the hash from the config file. In our example, this is the string hello.\nFinally, click on initialize wallet:\nIn the pop-up that opens, you must enter a wallet password. The mnemonic password is optional. After you click send, the wallet will return a mnemonic sentence as shown below.\nYou must copy this sentence and save it in a safe place. This sentence will be needed to restore the wallet on a different computer.\nGet wallet addresses This is a test to ensure you have set up the node properly. It will return the current addresses in the wallet. In the panel at http://127.0.0.1:9053/panel click on the Wallet tab on the left and then on Get all wallet addresses to view the addresses currently maintained by the wallet. It should return at least one address if the node is set correctly.\nUse the Swagger UI A Swagger UI is available at http://127.0.0.1:9053/swagger. You had already used it earlier to compute the hash of your secret. You can also use this UI to make API calls for advanced operations that are not (yet) available in the panel. Some examples of this are:\n Creating non-standard transactions with registers and context variables. Creating transactions that issue tokens. Creating transactions that use certain boxes as inputs.  A future article will discuss each of these operations in detail.\nNote that most methods in the API are protected and you would need to use your secret (from earlier) to access these methods. The following images show the process of setting this secret in the Swagger UI.\nNavigate to the top of the page and click the \u0026ldquo;Authorize\u0026rdquo; button. Enter your secret in the form that pops-up as shown in the figure below. After the password is entered and you have clicked \u0026ldquo;Authorize\u0026rdquo;, you will be shown the popup below: Now navigate to http://127.0.0.1:9053/swagger#/wallet/walletAddresses and click on \u0026ldquo;Try it out\u0026rdquo;. You should see the same list of addresses as you saw earlier from the panel.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_12_02_how_to_setup/","subtitle":null,"title":"How to set up and configure a full Ergo node"},{"contents":"","link":"https://www.probit.com/app/exchange/ERG-BTC","permalink":"https://ergoplatform.org/en/news/2019_10_30/","subtitle":"We're happy to announce that ERGO ($ERG) is listed on Probit Exchange","title":"ERGO ($ERG) is listed on Probit Exchange"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.1.3","permalink":"https://ergoplatform.org/en/news/2019_10_29/","subtitle":"This release includes simplified wallet UI, improved memory footprint due to more efficient ErgoTree interpreter, and some bugfixes","title":"Ergo Mainnet 3.1.3 released"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.1.2","permalink":"https://ergoplatform.org/en/news/2019_10_14/","subtitle":"This release includes rebroadcasting of mempool transactions. API route to generate P2SH address disabled","title":"Ergo Mainnet 3.1.2 released"},{"contents":"","link":"https://twitter.com/Hotbit_news/status/1181492203035643904","permalink":"https://ergoplatform.org/en/news/2019_10_08_hotbit/","subtitle":"Deposits and trading open at: 2019-10-09 15:00（UTC+8）","title":"ERGO ($ERG) is listed on HOTBIT Exchange"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.1.1","permalink":"https://ergoplatform.org/en/news/2019_10_08/","subtitle":"New UI available(e.g. 127.0.0.1/panel). A simplified wallet UI will be added in next versions. New API methods to get wallet status and address from a script","title":"Ergo Mainnet 3.1.1 released"},{"contents":"","link":"https://github.com/bisq-network/bisq/releases/tag/v1.1.6","permalink":"https://ergoplatform.org/en/news/2019_09_16/","subtitle":"BISQ, the decentralized P2P exchange network, added support for ERG","title":"BISQ has officially added ERG"},{"contents":"","link":"https://p2pb2b.io/trade/ERG_BTC","permalink":"https://ergoplatform.org/en/news/2019_09_14/","subtitle":"We're happy to announce that ERGO ($ERG) is listed on P2PB2B Exchange","title":"ERGO ($ERG) is listed on P2PB2B Exchange"},{"contents":"What is Crowdfunding? Crowdfunding is a way of raising capital through the collective efforts of individuals. The campaigns are mostly started via the world wide web and allow projects and businesses to be funded by raising small amounts of money from a large number of people. One of the best known examples for successful crowdfunding startups is Oculus Rift, a virtual reality headset. The company Oculus VR initiated its campaign in 2012 and was only two years later acquired by Facebook for $2 billion total. Besides the usual startups, there are also a lot of blockchain projects which went the way of crowdfunding, for example, Ethereum, Tron and EOS. Today, numerous platforms exist that allow you to publish your campaign. Some of the bigger ones are Indiegogo, Kickstarter, and Gofundme, only to name a few. Crowdfunding has a lot of benefits: a wide reach, efficiency, and marketing aspects being the most convincing\u0026hellip; But for now, let's get onto what's really important!\nIntroducing Crowdfunding on Ergo A few days ago, on August 28th, core developer Kushti stated on the (Ergo forum)[www.ergoforum.org] that he managed to successfully write and implement code that allows users to start a crowdfunding campaign on top of the Ergo blockchain (as mentioned in the whitepaper page 6. This code even works with the current wallet API. Here is a quick guide on how to set up the wallet. In this article, you will learn how to do exactly that: crowdfunding on top of Ergo! It also takes you through the proposal of the first campaign ever, which is to fund the post-EIP1 crowdfunding script development. If you want to go into all the details, please read the following section, “The Script”. Otherwise, you can simply skip to reading the “How To Donate”, \u0026ldquo;How To Collect Donations\u0026rdquo;, and “Crowdfunding Project Proposal” sections below that.\nThe Script The simplest crowdfunding script, according to the ErgoScript White Paper (page 6), is “a script for the following crowdfunding situation: a project backer (with key backerPubKey) wishes to give money to a project (with key projectPubKey), but only if the project raises enough money (at least minToRaise) from other sources by a deadline (expressed in terms of HEIGHT). To give money to the project, the backer will create an output box protected by the following script. The script contains two conditions: one for the case the deadline has passed (enabling the backer to get the money back) and one for the case it succeeded (enabling the project to spend the money if the amount is at least minToRaise before the deadline).\nIn order to ensure enough money has been raised, the script will search the output collection for a box with a sufficient value going to the projectPubKey. To check where the value of the output box is going, the script will read the script protecting the output box and compare it to the script corresponding to proveDlog(projectPubKey); this script can be obtained byprojectPubKey.propBytes.\nAs currently the API does not support embedding of custom environment variables (only predefined ones like HEIGHT), the only way to compile the script is to replace such variables in the script from the white-paper with concrete values. For example, consider that a crowdfunding campaign is successful if it is raising 500 Ergs before block number 50,000. For backerPubKey and projectPubKey we can use PK() function which accepts only P2PK serialized keys at the moment. Then the modified script from the WhitePaper becomes the following:\n{ val backerPubKey = PK(\u0026#34;9h7DHKSDgE4uvP8313GVGdsEg3AvdAWSSTG7XZsLwBfeth4aePG\u0026#34;) val projectPubKey = PK(\u0026#34;9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq\u0026#34;) val deadline = 50000 val minToRaise = 500L * 1000000000 val fundraisingFailure = HEIGHT \u0026gt;= deadline \u0026amp;\u0026amp; backerPubKey val enoughRaised = {(outBox: Box) =\u0026gt;outBox.value \u0026gt;= minToRaise \u0026amp;\u0026amp; outBox.propositionBytes == projectPubKey.propBytes } val fundraisingSuccess = HEIGHT \u0026lt; deadline \u0026amp;\u0026amp; projectPubKey \u0026amp;\u0026amp; OUTPUTS.exists(enoughRaised) fundraisingFailure || fundraisingSuccess } How to Donate First of all, JSON is not supporting multi-line strings, so you need to replace line breaks with \\n. Also, quotes are to be escaped, so use \u0026quot; instead of \u0026ldquo;. The resulting JSON will be sent to /script/p2sAddress. To donate to a project, first get your address from /wallet/addresses, take e.g. the first of them. Put the address into the backerPubKey, so a request to /script/p2sAddress will look like the following after this step:\n{ \u0026#34;source\u0026#34;: \u0026#34;{ val backerPubKey = PK(\\\u0026#34;9...\\\u0026#34;) val projectPubKey = PK(\\\u0026#34;9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq\\\u0026#34;) val deadline = 50000 val minToRaise = 500L * 1000000000 val fundraisingFailure = HEIGHT \u0026gt;= deadline \u0026amp;\u0026amp; backerPubKey val enoughRaised = { (outBox: Box) =\u0026gt; outBox.value \u0026gt;= minToRaise \u0026amp;\u0026amp; outBox.propositionBytes == projectPubKey.propBytes } val fundraisingSuccess = HEIGHT \u0026lt; deadline \u0026amp;\u0026amp; projectPubKey \u0026amp;\u0026amp; OUTPUTS.exists(enoughRaised) fundraisingFailure || fundraisingSuccess }\u0026#34; } with your address instead of “9…”.\nSend the string to /script/p2sAddress to get a response like:\n{ \u0026#34;address\u0026#34;: \u0026#34;GB3kh2izpWKvyZfMboQwsEscjPaZcz9WrzGqZB4ZrkzRreiFMV6HZYWXGMK3rqCjDCoPgWGNzfnYSUhivW4a1VRYPE7uZXwKnBcqWcRkiuTx6QW55EcPcWeELUsumwdtKoFtWY583nWnKZff\u0026#34; } Copy address string (GB3… in our example) and send the money to it via /wallet/payment/send . A request to the API method to send 10 Ergs (10 Billion nanoErgs) will be like following:\n[ { \u0026#34;address\u0026#34;: \u0026#34;GB3kh2izpWKvyZfMboQwsEscjPaZcz9WrzGqZB4ZrkzRreiFMV6HZYWXGMK3rqCjDCoPgWGNzfnYSUhivW4a1VRYPE7uZXwKnBcqWcRkiuTx6QW55EcPcWeELUsumwdtKoFtWY583nWnKZff\u0026#34;, \u0026#34;value\u0026#34;: 10000000000 } ] That’s all!\nNow the wallet will automatically find the box on the blockchain, as it contains the public key which belongs to the wallet in the refund condition. The wallet then periodically checks whether the box is spendable by constructing a simplest transaction with the box as an input and just one output (to the same address). After refund height (50,000 in our example) the wallet will be able to spend the box and so the box value will be added to /wallet/balances. Please note that this will not be the case after EIP-1 3 implementation as the wallet will use narrow recognition patterns by then.\nHow to Collect Donations The wallet which is associated with the project public key will find incoming boxes on the blockchain. However, it will fail to make sure that boxes are spendable, as the wallet currently is using a simplest transaction for that, and the script is failing for such a spending transaction. Before /wallet/boxes/uncertain method being implemented, the only way for a project to find incoming boxes. Then /wallet/transaction/send with manually provided (in “inputsRaw”) serialized boxes (use /utxo/byIdBinary to get the serialized box by its identifier).\nKushti did that by himself and got the following transaction.\nPlease note that EIP-1 will break this workflow as well.\nKushti proposes to raise 500 Ergs before block 50,000 to develop command-line scripts (in Python) for organizing and participating in crowdfunding campaigns after EIP-1 implementation. Command-line scripts are more suitable than doing requests manually and also could be used for building graphic interfaces on top of them.\nThe treasury did provide half of the funds, so others need to contribute the missing 250 Erg collectively. In case of a campaign failure refunds will be given automatically. As collecting pledges is not trivial at the moment, Kushti will lead the project role, so please use the following key, which is controlled by him:\n9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq\nIn order to donate any amount of money, please follow the “How To Donate” section above with replacing backerPubKey with your public key, and pledge amount with a proper value (please note that it is in nanoErgs, 1 Erg = 1.000.000.000 nanoErgs).\nAs always, if you have further questions, suggestions or want to participate in the movement, please join our social media channels or forum.\nt.me/ergoplatform | t.me/ergo_mining | www.ergoforum.org\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_09_06_crowdfund/","subtitle":null,"title":"Ergo and crowdfunding"},{"contents":"","link":"https://twitter.com/Hotbit_news/status/1169883351093694464","permalink":"https://ergoplatform.org/en/news/2019_09_06/","subtitle":"We're happy to announce that ERGO ($ERG) will be listed on Hotbit exchange","title":"Ergo will be listed on Hotbit exchange"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.1.0","permalink":"https://ergoplatform.org/en/news/2019_08_27/","subtitle":"This release is introducing an improved database layer - faster bootstrap, reduced storage size and memory footprint. Full resync is needed","title":"Ergo Mainnet 3.1.0 released"},{"contents":"","link":"https://twitter.com/VGATE2/status/1163718592505925632","permalink":"https://ergoplatform.org/en/news/2019_08_20_1/","subtitle":"We're happy to announce that ERGO ($ERG) is listed on Vgate Exchange","title":"ERGO ($ERG) is listed on Vgate Exchange"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.7","permalink":"https://ergoplatform.org/en/news/2019_08_20/","subtitle":"This release includes fixes and introduces new API methods. Details in the description of the release","title":"Ergo Mainnet 3.0.7 released"},{"contents":"This tutorial will provide you with the information needed to get your AMD cards mining ERGO on either Windows or Linux.\nDeveloper MH Samadani published his AMD Miner just three days after the official launch and is continuously updating it since. To keep track of his updates you can join the Ergo Mining Telegram Channel and search for #amdminer. You can download and look into the miner here.\nThe code is based on OpenCL and completely open source. If you are using Nvidia cards, you can find the CUDA miner here.\nPlease, be aware that it is unsafe to use any closed source miners. The mining specifics of ERGO require you to disclose your secret key to the miner so make sure who to trust before exposing any vulnerable data!\nThese are the reported Hashrates for AMD cards:\n rx570-8g: 22-24Mh/s rx580-8g: 23-25Mh/s rx Vega56: 24-26Mh/s  Before going any further I want to give credits to MH Samadani and his head developer Amin Moradi for providing the miner and the base for this tutorial.\nNow let's get started!\nConfiguration Copy these files into the same folder as your executable file and add your seed string and your node's address to config.json. In addition to that set keepPrehash: true in the same file.\n Miningkernel.cl Prehashkernel.cl Ocldecs.h Ocldefs.h Libcurl.dll( in windows) Config.json  Requirements for Linux 1. Install the AMDGPU-PRO driver by downloading the AMDGPU-PRO package for your specific Linux distribution from amd.com. Unpack this file and in a terminal window run: $ amdgpu-pro-install --opencl=legacy,pal --headless 2. Install OpenCL headers $ apt install libcurl4-openssl-dev 3. Install OpenSSL 1.02 $ apt install libssl-dev Requirements for Windows 1. You need at least one AMD GPU with its driver installed amd.com 2. Download and Install AMD APK from mhssadini's github here 3. If not already available, build libcurl from sources with Visual Studio toolchain instruction 4. Download and install OpenSSL 1.0.2 here Building in Linux 1. Edit the ErgoOpenCL.cpp in the master directory and comment #define TEST or uncomment define TEST to either build the miner or tester. 2. Change the directory to ergoAMDminer/Ubuntu and run make. ./makefile 3. If everything was done correctly, you should now find ErgoOpenCL in ergoAMDminer/Ubuntu/. Go ahead and run it to start mining. ./ErgoOpenCL Pre-Built Version for Windows Download the github, head over to the win64 folder and execute either ErgoOpenCL_miner.exe or ErgoOpenCL_tester.exe. If everything was set up correctly (see requirements and configuration) it should start mining.\nBuilding in Windows Open ErgoOpenCL.sln Visual Studio. Add the OpenCL, LibCurl and OpenSSL libraries.\nInclude directories:\nAnd include additional directories:\nAdditional library directories:\nAdditional dependencies:\nNow, in the ErgoOpenCL.cpp file, comment #define TEST to build the miner or uncomment define TEST to build the tester.\nIf you have any additional questions, suggestions, want to send flowers to @mhs_sam to or simply feel like joining the community, head over to our telegram channels - Ergo Mining or Ergo Platform - and say hello.\nHappy mining!\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_08_07_amd/","subtitle":null,"title":"Mining ERGO on AMD Cards"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.6","permalink":"https://ergoplatform.org/en/news/2019_08_06/","subtitle":"This release is introducing a filter for cumulative transaction input scripts complexity for the miners. Wallet, API methods and Swagger UI updated","title":"Ergo Mainnet 3.0.6 released"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.5","permalink":"https://ergoplatform.org/en/news/2019_07_30/","subtitle":"This release is introducing an improved box selector aka transaction assembler and memory footprint reduction thanks to optimized (de)serialization 🔥","title":"Ergo Mainnet 3.0.5 released"},{"contents":"In today's article, we will have a closer look into the Ergo address formatting. In addition to that we are going to explain how they work specifically as well as what makes them preferable to other types of blockchain addresses.\nLet's start at the very beginning.\nThe moment you install any cryptocurrency wallet you automatically create an address with it. Very loosely speaking you can compare a wallet to a traditional bank account and an address to the matching account number. It is precisely one of these alphanumeric addresses that's needed to either send money from person A to person B, receive money or withdraw your mining rewards. If you want to get started using the Ergo wallet and dive deeper into its functions go check out the following link.\nNow, what exactly are addresses?\nAddresses are short strings that correspond to certain scripts and are used to protect a box (this post that core developer kushti published on our forum explains very well what a \u0026ldquo;box\u0026rdquo; is). Unlike a (hex-encoded) binary representation of a script, an Ergo address is using a Base58-encoding and therefore has some very useful characteristics to it which the binary representation do not offer:\n The integrity of an address can easily be checked via an integrated checksum (which is a \u0026ldquo;small-sized datum derived from a block of digital data for the purpose of detecting errors that may have been introduced during its transmission or storage\u0026rdquo;, according to Wikipedia). A prefix of the address is showing you the network and address type. In particular, the network prefix prevents you from mistakenly sending mainnet tokens to the testnet address. The address is using an encoding (namely, Base58 as mentioned) which is avoiding similarly looking characters and is friendly to double-clicking and also line-breaking in emails. An address is encoding network type, address type, checksum, and enough information to correspond with particular scripts.  Let's look at the prefix byte which contains information about the network and address types:\nPossible network types are:\n Mainnet - 0x00 Testnet - 0x10  Address types are (semantics described below):\n 0x01 - Pay-to-PublicKey(P2PK) address 0x02 - Pay-to-Script-Hash(P2SH) 0x03 - Pay-to-Script(P2S)  For an address type, we form content bytes as follows:\n P2PK - serialized (compressed) public key P2SH - first 192 bits of the Blake2b256 hash of serialized script bytes P2S - serialized script (this is where mining rewards go!)  For example, sending 10 Ergs to a P2PK address usually means that a corresponding transaction will contain a box in which 10 Ergs are locked by a public key encoded in the P2PK address. Similarly, in case of a P2S address the box will be locked by a script encoded in the address. In the most complicated case of a P2SH script, the box will be protected by a special predefined script which is taking first 192 bits of Blake2b256 hash value for a script which should be shown by an input spending the box.\nHere is an example of how particular addresses are going to look on the testnet:\n 3 - P2PK (3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN) ? - P2SH (rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB) ? - P2S (Ms7smJwLGbUAjuWQ)  And here is how they are looking on our mainnet:\n 9 - P2PK (9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA) ? - P2SH (8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg) ? - P2S (4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ)  In short summary:\n Prefix byte = network type + address type (for example, P2S script on the testnet starts with 0x13 before Base58) checksum = leftmost_4_bytes (blake2b256 (prefix byte || content bytes)) address = prefix byte || content bytes || checksum  If any of this sparked your interest, you are very welcome to join our community and ask further questions on our telegram channel and/or forum. See you there!\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_07_24_ergo_address/","subtitle":null,"title":"Ergo Addresses"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.4","permalink":"https://ergoplatform.org/en/news/2019_07_19/","subtitle":"This release is introducing a timestamp bugfix in block candidate generation algorithm. Highly recommended for miners","title":"Ergo Mainnet 3.0.4 released"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.3","permalink":"https://ergoplatform.org/en/news/2019_07_18/","subtitle":"This release includes fixes and introduces new API methods. Details in the description of the release","title":"Ergo Mainnet 3.0.3 released"},{"contents":"","link":"https://twitter.com/Magnum_Wallet/status/1148948899618598915","permalink":"https://ergoplatform.org/en/news/2019_07_11/","subtitle":"We're happy to announce that ERGO ($ERG) is integrated with Magnum Wallet","title":"ERG is available in Magnum Wallet"},{"contents":"Firstly, we would like to thank many enthusiasts, developers, miners, other folks, and our families for measureless help with Ergo development and launching. The launch finishes a few years period of initial research and development by the Team, and also starts a new epoch, where the core technology is mostly set in stone and gradual improvements in protocol implementations and infrastructure projects become the main focus.\nThe current core Ergo Core Team remains fully committed to the project (at least, while the Foundation Treasury enables that). With that in mind, let me give the light on current status of the project and future plans.\nCurrent status In the first place, let me remind some keypoints of Ergo:\n  It is still a conservative Proof-of-Work blockchain with a strictly limited coin supply, a Bitcoin-like transactional model, a cautiously chosen target delay between blocks, and so on. In that sense Ergo is similar to Bitcoin, and time has proven that this is the best choice for those who value decentralization and sound money.\n  Despite Bitcoin-like transactional model (with one-time unspent transaction outputs), Ergo supports enhanced contractual money possibilities without sacrificing security. We already have examples for crowdfunding, ICO, cold wallet contract, and so on. Also, Ergo provides best access to generic discrete log based zero-knowledge proofs, and thus it is better (in some cases, the only choice) for protocols to be built on top of it. For example, there is 2-out-of-3 multi-signature already done in the network, and this signature preserves zero-knowledge (so no third-party observer can ascertain which two parties actually signed the transaction input). In the same way, ring signatures (1-out-of-N signatures preserving zero-knowledge) are coming for free. Also please take a look at Ergomix, a non-interactive mixing scheme, and maybe the first practical non-interactive mixing proposal.\n  Ergo has native support for custom tokens. Also it has support for authenticated data structures which can be trusted (modification of a dataset happening outside the blockchain by a trusted party) or trustless (modifications are happening on-chain as defined by a contract, but only very compact dataset digest is stored in UTXO set anyway).\n  It has pool-resistant and (somewhat) ASIC-resistant Autolykos Proof-of-Work scheme, which is targeting top-level GPUs, with best performance being on GPUs with 8gb+ RAM.\n  For better decentralization in regards with possible full-nodes count decline with time, Ergo for first time supports stateless fully secure clients. Efficient SPV clients support is also done, but via NIPoPoW technology, not the FlyClient used in Grin.\n  No need for hot debates on changing block size and many other parameters. Just using block size as an example, a miner can simply start voting at the beginning of an epoch (consisting of 1,024 blocks), and if 50+% of miners within the epoch support a change (1% block size increase or decrease in block size), it will happen. For many aspects of the protocol, soft-fork updates are possible, if 90+% of mining power votes are for a soft fork. Here Ergo is finishing what Bitcoin, with its soft-forkability, and Ethereum, with its dynamic gas limit per block readjustment, have started.\n  All of these features are probably not very visible now, just one week after launch, but they will define unique Ergo characteristics in the long-term. Please note, for success in the long-term, you need to go from first principles. Ergo is doing that, and not in the tech only: please note that Ergo has well-defined social contract described in Section 2 of the whitepaper.\nFurther Ergo Core Team Duties While the reference node implementation is working more or less well, its interface could be confusing even for skilled users, and there is no infrastructure, such as wallets, frameworks to develop applications etc. Thus the core team will spend coming months on delivering needed frameworks and API improvements and supporting wallets and exchanges, some of which are already in-process. Also note that many components of the node are not efficient now, so performance of the node will be significantly increased in the observable future. At the same time, external teams continue to do security audits. The most critical parts of protocol design and reference implementation have already been audited, sometimes by more than one party.\nHardforking policy Ergo is trying to avoid hard-forks. Emission, proof-of-work, basics of transactional model and other core things should not be changed at all as any change about core parts of design means another chain. However, developers may propose hard-forks within first 12 months if (and only if):\n a hard-fork is about security fixes only. The only exception is about making cost of particular instructions adjustable via miners voting, which was planned but not delivered in the current mainnet. a hard-fork is supported by 90+% of miners. a hard-fork is not breaking old contracts, freezing or moving any funds.  Community Matters! Development should become more transparent and open to external contributors, with gradual switching to EPIPs (EPIP stands for Ergo Platform Improvement Proposal), formal documents appearing and discussed before implementation like Bitcoin and Ethereum are already using BIPs and EIPs, respectively.\nErgo is also in need of an ecosystem of frameworks and applications around it. A part of the treasury will be spent on grants for ecosystem developers. Details of the grant program will be announced later, however, you may contact the Ergo Core Team right now with any proposals. Also, the team would be happy to help with advice, needed API improvements, and so on. From an investor perspective, investing in projects on top of Ergo may be more valuable in comparison with other blockchains, considering the commitments to protocol stability made by the team.\nAlso, please spread the word about Ergo! We are a nascent blockchain getting it's feet off the ground and are looking for contributors who are interested in writing documentation, articles, and other material.\nErgo and Ergo Data Initially, it was announced (couple of years ago) that two chains will be launched, Ergo and Ergo Data. Technology would be the same (or very similar), but parameters are different. The main idea behind Ergo Data is to serve needs of data-intensive applications, such as land registries, certificate directories etc.\nCurrently, Ergo Data plans are unclear. The network will be launched only in case users will show demand for it. Also, Ergo Data would most likely be a sidechain of Ergo. Also, it will not be launched soon in any case, and only after Ergo having established a solid infrastructure base. In case of Ergo Data chain being launched, EFYT holders at the moment of Ergo launch will get ErgoData tokens. A snapshot of EFYT holders at the moment of launch has already been done.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_07_09_after_launch/","subtitle":null,"title":"After-Launch Thoughts and Ergo Roadmap"},{"contents":"","link":"https://ergoplatform.org/en/blog/2019_07_09_after_launch/","permalink":"https://ergoplatform.org/en/news/2019_07_09/","subtitle":"Big thank you to all enthusiasts, developers, miners, other folks, and our families for measureless help with Ergo development and launching.","title":"After-Launch Thoughts and Ergo Roadmap"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.2","permalink":"https://ergoplatform.org/en/news/2019_07_04/","subtitle":"This release includes API improvements.","title":"Ergo Mainnet 3.0.2 released"},{"contents":"","link":"https://tidex.com/exchange/erg/btc","permalink":"https://ergoplatform.org/en/news/2019_07_02/","subtitle":"We're happy to announce that ERGO ($ERG) is listed on Tidex Exchange","title":"ERGO ($ERG) is listed on Tidex Exchange"},{"contents":"Spending mining reward This text is to help miners to withdraw funds mined.\nA lot of folks launched a node and also a miner, with pubkeyHex from the miner embedded in the node config. Now information on how to recognize the coins mined and withdraw them to another address.\nOn keys. A miner can see a lot of keys in different formats.\nFirst, mining software and also mining support in the node (namely, ergo.node.miningPubKeyHex setting in the config) are using a Base16-encoded \u0026ldquo;raw\u0026rdquo; public key, which is just an encoded serialized point on elliptic curve. This key is enough for a miner (which can avoid then supporting Base58, address forming etc).\nSecond, a node wallet shows Pay-To-Public-Key (P2PK) addresses, which are starting with \u0026ldquo;9\u0026rdquo;. P2PK adress contains not just elliptic curve point, but also network prefix and checksum, similarly to Bitcoin P2PK and P2PKH addresses.\nThird, there is minig/rewardAddress API method, which is intended for external tools generating block candidates. This API method shows something like 88dhgzEuTXaSfKEbxfa6vghvEGdBH39sn9h7As2Y2Z6SGd8bKXCXmRLY5JtU4g4RYBP4WcZWb3JwjXDK, which is a special script to pay a miner in encoded form.\nAnyway, if you put pubkeyHex from you miner into your node, everything is okay, just don't worry about different keys seen.\nGetting you balance shown \u0026amp; withdrawals Probably you don't see mined coins after wallet initialization, if its done on height after blocks mined. Please note, the node is not scanning blocks backwards, it is only scanning new blocks after the initialization. Thus in order to find mined coins, full blockchain rescan is needed atm (or, if you mine, launch another node on another machine, or on the same machine with different ports set in the config, namely, set new values to scorex.restApi.bindAddress and scorex.network.bindAddress fields; also please use version 3.0.1 as it is easier to configurate).\nIn order to spend rewards you need to follow the steps below: 1. Clear node state, if you're going to stop working node. In order to clear the state of your node you need to stop the node and then remove all contents of .ergo directory (it could be hidden from you on Mac and Linux, try ls -a command in the directory you ran the node from).\n2. Restoring a local wallet from the seed-phrase used in the Autolykos miner Remember that mnemonic sentence you set in the config.json when configuring your Autolykos miner - now you need to restore build-in wallet from it. In order to restore your wallet start the node again and send a POST request to http://[your_node_ip]:9053/wallet/restore containing the application/json content-type body like:\n{ \u0026#34;pass\u0026#34;: \u0026#34;your_wallet_pass\u0026#34;, \u0026#34;mnemonic\u0026#34;: \u0026#34;mnemonic_sentense_from_your_miner\u0026#34;, \u0026#34;mnemonicPass\u0026#34;: \u0026#34;mnemonic_pass_if_set\u0026#34; } , where pass is a new unique pass to be used to encrypt wallet data on your local disk, and mnemonic is a mnemonic phrase you copied from your Autolykos miner config (config.json). Please especially pay your attention to mnemonicPass field - this is a password of your mnemonic phrase, it's optional and you could have configured it when generating your mnemonic. So add this field to the request only in case your mnemonic is really protected with a pass, remove this field otherwise.\nDon't forget to authorize your request setting correct api_key HTTP header corresponding to the apiKeyHash your configured in the node config file.\nATTENTION: In order to let the wallet scan all the blocks from the genesis you need to restore the wallet before your node would have started downloading full blocks (Check fullHeight in /info API method response - while it is null your node haven't start downloading full blocks)\n3. Check your balance When your node got synced with the network check /wallet/balances API method. The response should look like:\n{ \u0026#34;height\u0026#34;: 3560, \u0026#34;balance\u0026#34;: 67500000000, \u0026#34;assets\u0026#34;: {} } Pay attention to the height field first - it should equal fullHeight displaying by /info API route. balance is a confirmed balance found by your wallet.\n4. Make a transaction spending your reward In order to withdraw a reward from your wallet, create a new payment transaction using /wallet/payment/send API route. In order to perform this operation send a POST request containing an application/json content-type body like:\n{ \u0026#34;address\u0026#34;: \u0026#34;your_address\u0026#34;, \u0026#34;value\u0026#34;: 10000000 } , where address is the address you want to move your funds to and value is how many nanoERGs you wish to move.\nWhen the request is sent the node would return transation id in response. You can use explorer to check when your transaction gets to the block.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_07_03_mining_withdrawal/","subtitle":null,"title":"Ergo Withdrawal"},{"contents":"","link":"https://ergoplatform.org/en/blog/2019_07_03_mining_withdrawal/","permalink":"https://ergoplatform.org/en/news/2019_07_03/","subtitle":"This guide will help miners to withdraw mined funds.","title":"Ergo Withdrawal Instructions"},{"contents":"","link":"https://explorer.ergoplatform.com","permalink":"https://ergoplatform.org/en/news/2019_07_01_1/","subtitle":"Ergo mainnet is launced. Check here - https://explorer.ergoplatform.com","title":"Ergo mainnet is launched"},{"contents":"","link":"https://explorer.ergoplatform.com","permalink":"https://ergoplatform.org/en/news/2019_07_01/","subtitle":"The Ergo explorer provides detailed information about addresses, blocks and transactions on the Ergo network","title":"Ergo explorer released"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.1","permalink":"https://ergoplatform.org/en/news/2019_07_01_2/","subtitle":"This release includes hard-coded proof-of-no-premine and genesis state root hash. Thanks to all who made it for mainnet launch","title":"Ergo Mainnet 3.0.1 released"},{"contents":"","link":"https://twitter.com/p2pb2b/status/1144642629361160194","permalink":"https://ergoplatform.org/en/news/2019_06_28_2/","subtitle":"Ergo native token (ERG) will be listed soon after the mainnet launch.","title":"Ergo will be listed on P2PB2B exchange"},{"contents":"Joining the Ergo main network at the very beginning In order to join the network at its very beginning and compete to mine the genesis block, you need to follow the steps described below. If you're not going to participate in Ergo mining and just want to set up a full node, you need to follow steps 3 and 5.\nPreparations 1. Build mining software Check the guide first.\nBuild a miner according to its readme instruction (for Ubuntu) or using Windows manual.\nTry to run it like ./auto.out config.json with test config:\n{ \u0026#34;mnemonic\u0026#34;: \u0026#34;noise peasant subway frozen illegal pretty oak agent train valid wash title burst column yard decide move coin gas asset pretty hire happy fuel\u0026#34;, \u0026#34;node\u0026#34;: \u0026#34;http://159.203.36.162:9052\u0026#34;, \u0026#34;keepPrehash\u0026#34;: true } and see something like:\n2019-06-27 14:44:58,626 INFO [main thread] Using 1 GPU devices 2019-06-27 14:44:58,626 INFO [main thread] Using configuration file mine162.json 2019-06-27 14:44:58,628 INFO [main thread] Block getting URL: http://159.203.36.162:9052/mining/candidate 2019-06-27 14:44:58,628 INFO [main thread] Solution posting URL: http://159.203.36.162:9052/mining/solution 2019-06-27 14:44:58,629 INFO [main thread] Generated public key: pk = 0x03 F5214F2F6D87C714 4A2E12F8D4C4E110 1C59FF7D9AEABC11 77C4CB50FA8497E7 2019-06-27 14:44:58,714 INFO [main thread] Got new block in main thread, block data: { \u0026#34;MSG\u0026#34; : \u0026#34;3637B40440681781F92EDC92B33E623330F05705446168952CBD3720BA922442\u0026#34;, \u0026#34;B\u0026#34; : 3462030106355215694294694818737961234095984491840283822105474632310, \u0026#34;PK\u0026#34; : \u0026#34;03F5214F2F6D87C7144A2E12F8D4C4E1101C59FF7D9AEABC1177C4CB50FA8497E7\u0026#34; } 2019-06-27 14:44:58,956 INFO [GPU 0 miner] GPU 0 allocating memory 2019-06-27 14:44:58,964 INFO [GPU 0 miner] Preparing unfinalized hashes on GPU 0 2019-06-27 14:45:13,443 INFO [GPU 0 miner] GPU 0 read new block data 2019-06-27 14:48:02,298 INFO [main thread] Average hashrates: GPU0 24.8537 MH/s Total 24.8537 MH/s The above notifications show that your miner is built correctly.\n2. Generate mnemonic phrase for mining Run ./auto.out -G to generate a new mnemonic phrase if you don't have one.\n$ ./auto.out -G 2019-06-28 12:08:32,915 INFO [main thread] !!!Generated new mnemonic, put it in your config.json file!!! job great stage urge elite purity surprise any cram matrix typical table panel honey curious enlist fault matrix !!!Generated new mnemonic, put it in your config.json file!!! 2019-06-28 12:08:32,918 INFO [main thread] Generated public key: pk = 0x03 61F8098779E5EC8C 2A851E3EF57C471E 9A6803F60666E93E EB0BDD67411439D0 In the example above your generated mnemonic phrase is job great stage urge elite purity surprise any cram matrix typical table panel honey curious enlist fault matrix while your public key is 0361F8098779E5EC8C2A851E3EF57C471E9A6803F60666E93EEB0BDD67411439D0. Save your mnemonic phrase (e.g. by writing down to a piece of paper) and keep it in secret at all times, anyone who have access to it will be able to steal your funds. Write down your public key, you will need it in the next steps.\n3. Configure and start your miner Create a settings.json config file with the following content (don't forget to replace sections in \u0026lt;\u0026gt; braces):\n{ \u0026#34;mnemonic\u0026#34;: \u0026#34;\u0026lt;mnemonic generated at step 2\u0026gt;\u0026#34;, \u0026#34;node\u0026#34;: \u0026#34;http://\u0026lt;ip address of your node\u0026gt;:9053\u0026#34;, \u0026#34;keepPrehash\u0026#34;: true } and run a miner like ./auto.out settings.json. It should initialize and start requesting a node for the block candidate.\n2019-06-27 15:14:02,267 INFO [main thread] Using 1 GPU devices 2019-06-27 15:14:02,267 INFO [main thread] Using configuration file mainnet-conf.json 2019-06-27 15:14:02,269 INFO [main thread] Block getting URL: http://\u0026lt;ip address of your node\u0026gt;:9053/mining/candidate 2019-06-27 15:14:02,269 INFO [main thread] Solution posting URL: http://\u0026lt;ip address of your node\u0026gt;:9053/mining/solution 2019-06-27 15:14:02,269 INFO [main thread] Generated public key: pk = 0x02 F611D5F6AAB70C05 4A530C6420395B3C 4521642DC7125A93 49AAA2D9BB89D7AF 2019-06-28 12:21:36,035 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 2019-06-28 12:21:36,835 INFO [main thread] Waiting for block data to be published by node... 2019-06-28 12:21:36,876 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 2019-06-28 12:21:37,676 INFO [main thread] Waiting for block data to be published by node... 2019-06-28 12:21:37,718 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server No more actions are required with the miner.\n4. Configure and run your full node Check guide first.\nCreate a settings.conf config file with the following content (don't forget to replace sections in \u0026lt;\u0026gt; braces):\nergo { node { mining = true miningPubKeyHex = \u0026#34;\u0026lt;your public key from step 2\u0026gt;\u0026#34; } chain { initialDifficultyHex=\u0026#34;011765000000\u0026#34; } } scorex { network { nodeName = \u0026#34;\u0026lt;some name to identify your node\u0026gt;\u0026#34; } restApi { # you may wish to configure an apiKeyHash to use your wallet. Check https://ergoplatform.org/en/blog/2019_06_04_wallet-documentation/ for wallet documentation.  apiKeyHash = \u0026#34;1111\u0026#34; } } Download the latest mainnet release from here and run it like nohup java -jar -Xmx3G -Dlogback.stdout.level=DEBUG ergo-3.0.1.jar --mainnet -c settings.conf and you if you see similar to the below:\n17:02:11.449 INFO [main] o.e.settings.ErgoSettings$ - Running in mainnet network mode 17:02:12.262 INFO [main] org.ergoplatform.ErgoApp - Entering coordinated network bootstrap procedure .. 17:02:12.933 INFO [main] o.e.BootstrapController - Wrong response format, retrying in 10s 17:02:22.933 INFO [main] o.e.BootstrapController - Wrong response format, retrying in 10s You node is already configured correctly and no more action is required with it.\n5. Wait for the mainnet launch After these steps you're ready to participate in Ergo mining and should just wait. Your miner is waiting for block candidate from your node, while your node is waiting for the proof-of-no-premine that will be broadcasted by the Ergo Development Team according to the main network launch schedule. The proof‐of‐no‐premine will contain headlines from the media (The Guardian, Vedomosti, Xinhua), as well as the latest block identifiers from Bitcoin and Ethereum. When the launch time comes, we'll distribute the no-premine proof and the mining will start.\nTo ensure that your node is mining, you may check your node log. It should stop to write logs from BootstrapController and write Boot settings received. Starting the node, so the logs file will looks like:\n17:21:39.417 INFO [main] o.e.BootstrapController - Wrong response format, retrying in 10s 17:21:49.437 INFO [main] o.e.BootstrapController - Wrong response format, retrying in 10s 17:21:59.500 INFO [main] org.ergoplatform.ErgoApp - Boot settings received. Starting the node .. 17:21:59.554 INFO [ctor.default-dispatcher-3] s.c.n.NetworkController - Declared address: None 17:21:59.558 INFO [ctor.default-dispatcher-3] s.c.n.NetworkController - Registering handlers for List((1,GetPeers message), (2,Peers message)) 17:21:59.559 INFO [ctor.default-dispatcher-3] s.c.n.NetworkController - Successfully bound to the port 9030 17:21:59.565 INFO [ctor.default-dispatcher-4] o.e.n.state.ErgoState$ - Generating genesis UTXO state 17:21:59.568 INFO [ctor.default-dispatcher-2] o.e.local.ErgoMiner - Trying to use key from wallet for mining 17:21:59.583 INFO [ctor.default-dispatcher-3] s.c.u.NetworkTimeProvider - New offset adjusted: 2 17:21:59.585 WARN [ctor.default-dispatcher-3] o.e.n.ErgoReadersHolder - Got GetReaders request in state (None,None,None,None) 17:21:59.598 INFO [ctor.default-dispatcher-2] s.c.n.NetworkController - Registering handlers for List((55,Inv), (22,RequestModifier), (33,Modifier), (65,Sync)) 17:21:59.729 INFO [ctor.default-dispatcher-4] s.c.a.a.b.VersionedIODBAVLStorage - Update storage to version ByteArrayWrapper[6813BCA7232C6E156FB6229ECF165D157640A8576A5B320506E4C1B66011253402]: 14 elements to insert, 1 elements to remove 17:21:59.846 INFO [ctor.default-dispatcher-4] o.e.n.state.ErgoState$ - Genesis UTXO state generated with hex digest 6813bca7232c6e156fb6229ecf165d157640a8576a5b320506e4c1b66011253402 At the same time your miner should write you something like:\n2019-06-28 12:21:36,035 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 2019-06-28 12:21:36,835 INFO [main thread] Waiting for block data to be published by node... 2019-06-28 12:21:36,876 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 2019-06-28 12:21:37,676 INFO [main thread] Waiting for block data to be published by node... 2019-06-27 15:26:20,328 INFO [main thread] Got new block in main thread, block data: { \u0026#34;MSG\u0026#34; : \u0026#34;0777078E22BB64C771DE8A8D3B1E454847A91024D98AB86949091C8019FA7453\u0026#34;, \u0026#34;B\u0026#34; : 964934076977634961863091541739065898773646368992290869855043026179318012, \u0026#34;PK\u0026#34; : \u0026#34;02F611D5F6AAB70C054A530C6420395B3C4521642DC7125A9349AAA2D9BB89D7AF\u0026#34; } 2019-06-27 14:44:58,956 INFO [GPU 0 miner] GPU 0 allocating memory 2019-06-27 14:44:58,964 INFO [GPU 0 miner] Preparing unfinalized hashes on GPU 0 2019-06-27 14:45:13,443 INFO [GPU 0 miner] GPU 0 read new block data 2019-06-27 14:48:02,298 INFO [main thread] Average hashrates: GPU0 24.8537 MH/s Total 24.8537 MH/s 2019-06-27 15:27:11,033 INFO [GPU 0 miner] GPU 0 found and trying to POST a solution: ","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_06_28_mainnet-bootstrap/","subtitle":null,"title":"Joining the Ergo main network at the very beginning"},{"contents":"","link":"https://ergoplatform.org/en/blog/2019_06_28_mainnet-bootstrap/","permalink":"https://ergoplatform.org/en/news/2019_06_28_3/","subtitle":"In order to join the network at its very beginning and compete to mine the genesis block, you need to follow the steps included in this guide.","title":"Joining the Ergo main network at the very beginning"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.2.0","permalink":"https://ergoplatform.org/en/news/2019-06-27/","subtitle":"Sigma-State language updated, new API methods","title":"Testnet 2.2.0 released"},{"contents":"","link":"https://twitter.com/ergoplatformorg/status/1143824003632685056","permalink":"https://ergoplatform.org/en/news/2019-06_26/","subtitle":"Instructions on how to join mainnet right after launch is coming shortly.","title":"Mainnet launch - Monday, July 1, 10:00 AM UTC"},{"contents":"","link":"https://t.me/ergo_mining","permalink":"https://ergoplatform.org/en/news/2019-06-24/","subtitle":"Both CPU and GPU miners are welcome to join","title":"Ergo Mining Telegram group is now open"},{"contents":"","link":"https://twitter.com/Tidex_Exchange/status/1139282057643905024","permalink":"https://ergoplatform.org/en/news/2019_06_1/","subtitle":"Ergo native token (ERG) will be listed right after the mainnet launch.","title":"EFYT (Ergo First Year Token) is listed on Tidex Exchange"},{"contents":"","link":"https://twitter.com/ergoplatformorg/status/1139164264168591362","permalink":"https://ergoplatform.org/en/news/2019_06_13_2/","subtitle":"Due to delays with exchange listings and new issues found we've decided to postpone the mainnet launch till June 28. Thank you for your patience and continued support!","title":"Mainnet launch postponed"},{"contents":"","link":"https://badcryptopodcast.com/2019/06/13/crypto-for-good-276/","permalink":"https://ergoplatform.org/en/news/2019_06_13/","subtitle":"Episode 276: Crypto for Good with The Giving Block","title":"The Bad Crypto Podcast featuring Ergo"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.1.2","permalink":"https://ergoplatform.org/en/news/2019_06_12/","subtitle":"Support of coordinated network bootstrapping. Fixes of multiple genesis processing and network byte in addresses.","title":"Testnet 2.1.2 released"},{"contents":"","link":"https://www.youtube.com/watch?v=bsqcyLT8ddY","permalink":"https://ergoplatform.org/en/news/2019_06_11/","subtitle":"Bitcoin | The Next Evolution of Money by DataDash","title":"Interview with Ergo, a platform who's building the framework for contractual money"},{"contents":"","link":"https://twitter.com/SwftCoin/status/1136293239219113986","permalink":"https://ergoplatform.org/en/news/2019_06_05/","subtitle":"ERG will be listed soon after mainnet launch and will be available for payment and swap with over 170 crypto!","title":"Agreement with SWFT Blockchain"},{"contents":"","link":"https://bitcointalk.org/index.php?topic=5150971","permalink":"https://ergoplatform.org/en/news/2019-06-05-1/","subtitle":"Following up the PRE-ANN thread on Bitcointalk which was started almost two years ago, the Ergo team would like to announce the upcoming launch of Ergo, a resilient platform for contractual money.","title":"New Bitcointalk thread"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.1.0","permalink":"https://ergoplatform.org/en/news/2019-06-05-2/","subtitle":"Voting for soft-forkability feature implemented, Sigma-State language updated. More details in the description of the release.","title":"Testnet 2.1.0 released"},{"contents":"An Ergo node provides a built-in wallet for storing private keys and signing transactions. The following describes how to set up and protect your Ergo wallet.\nThe wallet uses the BIP39 standard to generate a seed from a mnemonic sentence, which is then used to generate the private keys according to the BIP32 standard  (Hierarchical Deterministic Wallets). You can use your own mnemonic sentence composed of the words from one of these wordists if you want to. The allowed sentence lengths are 12, 15, 18, 21, 24 representing respectively, 128, 160, 192, 224, 256 bits of security. In order to initialize a wallet with such a mnemonic, you should use the wallet/restore API endpoint. However, it is far more secure to use the mneomnic generated by the wallet.\nAt this stage, all interactions with the wallet can only be done through the node's REST API. Please ensure that you have set an API key in your node before performing the next steps.\nConfiguring the wallet The wallet is configured through the node configuration file. Below are the configuration parameters worth paying attention to when configuring wallet for the first time:\n ergo.wallet.seedStrengthBits - Bit-length of a seed in case it will be generated by the node. Note: the stronger the seed the longer the mnemonic sentence length is. Options: 128, 160, 192, 224, 256 ergo.wallet.secretStorage.secretDir - Directory where secret will be stored in encrypted form ergo.wallet.mnemonicPhraseLanguage - Language to be used in mnemonic sentence. Options: \u0026quot;chinese_simplified\u0026quot;, \u0026quot;chinese_traditional\u0026quot;, \u0026quot;english\u0026quot;, \u0026quot;french\u0026quot;, \u0026quot;italian\u0026quot;, \u0026quot;japanese\u0026quot;, \u0026quot;korean\u0026quot;, \u0026quot;spanish\u0026quot;  Using the wallet for the first time The wallet needs to be initialized via the REST API when running the node for the first time. Two options are available here:\n Initialize it from scratch (seed will be generated by the node) by making a POST request to /wallet/init with data body: {\u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;, \u0026quot;mnemonicPass\u0026quot;: \u0026quot;abc\u0026quot;}. Don't forget to save the mnemonic phrase that the node responds with. (Note: The parameter mnemonicPass in request body is optional and is used for protecting the mnemonic phrase). Restore the wallet from an existing seed. You will have to provide your mnemonic phrase When using this option. This is done by making a POST request to /wallet/restore with data body: {\u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;, \u0026quot;mnemonic\u0026quot;: \u0026quot;abandon abandon ...\u0026quot;, \u0026quot;mnemonicPass\u0026quot;: \u0026quot;abc\u0026quot;} (Note: the mnemonicPass field is required only in case your mnemonic phrase was protected by an additional password at creation).  Unlocking the wallet After initialization and before every use the wallet needs to be unlocked by making a POST request to /wallet/unlock with data body: {\u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;}. (Note: use the password you had chosen at initialization stage)\nYou must perform this step every time the node is restarted or the wallet is locked. In particular, the wallet must be unlocked for the following operations:\n Using internal miner Signing transactions Tracking boxes  Locking the wallet A wallet is automatically locked after some time, which means that all currently loaded secrets are flushed from the memory. You can also use the REST API to lock the wallet by making a GET request to /wallet/lock. It is recommended to lock the wallet when it is not in use. After locking, you will need to unlock the wallet to use it again.\nManaging keys A wallet implements BIP32 (\u0026ldquo;Hierarchical deterministic wallets\u0026rdquo;). When the wallet is initialized the only root key is created. In order to derive additional key pair corresponding to a specific derivation path (method: POST, request body: {\u0026quot;derivationPath\u0026quot;: \u0026quot;m/1/2\u0026quot;}) the /wallet/deriveKey API route can be used. In order to simply create additional key pair use a /wallet/deriveNextKey API route (method: GET).\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_06_04_wallet-documentation/","subtitle":null,"title":"Wallet documentation"},{"contents":"","link":"https://docs.ergoplatform.com/cn/whitepaper_cn.pdf","permalink":"https://ergoplatform.org/en/news/2019-06-03/","subtitle":"We continue to reach out to the Chinese crypto community. Chinese website coming soon.","title":"Ergo whitepaper(Chinese)"},{"contents":"","link":"https://ergoplatform.org/blog/2019_05_29-exchange/","permalink":"https://ergoplatform.org/en/news/2019-05-30/","subtitle":"A Local Exchange Trading System (LETS) is aimed at developing local economy and is usually used by people of a locality in the vicinity of each other.","title":"A Trustless Local Exchange Trading System on top of Ergo"},{"contents":"A Local Exchange Trading System (LETS) is aimed at developing local economy and is usually used by people of a locality in the vicinity of each other. For a brief overview of LETS see this link, which also describes an ErgoScript implementation of a committee managed LETS. We call such a system a managed or permissioned, since it depends on a committee of trusted members to enroll new members into the LETS. Here we describe a trustless LETS, i.e., one where there is no management committee needed for enrolment.\nOverview LETS involves several parties that agree to use some form of \u0026ldquo;local currency\u0026rdquo;, usually pegged to the country's main currency at a 1:1 rate. Assume that our LETS is based in a European country where the currency is Euros, and the exchange is done in \u0026ldquo;local Euros\u0026rdquo;, which are considered to be equivalent to national Euros.\nEach user in LETS has an account, which contains the LETS balance of that user (in Local Euros). On joining, each user has a balance of zero. The balance is stored in a (possibly decentralized) ledger. An interesting feature of LETS is that a user with zero balance can also \u0026ldquo;withdraw\u0026rdquo; money, but only for paying another LETS user. At any time the sum of LETS balances of all the users is zero.\nAs an example, Alice with zero balance wishes to purchase one liter of milk for 2 Euros from Bob who is also a member of LETS with zero balance. She transfers 2 Euros from her account to Bob's, making her balance -2 and Bob's +2. Bob can then transfer some or all of his balance to another LETS user in exchange for goods or services.\nTrustless LETS Since we desire a trustless LETS, we cannot depend on any trusted group of people to admit users. Note that we will still have a committee to perform some tasks such as setting up the LETS parameters (local currency, the maximum number of members, etc) and consuming any joining fee.\nWe will only assume a trusted pricing oracle that gives the current rate of euros to ergs identified by some global id (rateTokenID) and a singleton box containing exactly one token with this id. A singleton box, described here, is a box containing a singleton token, i.e., a token with only one quantity in existence. This box also contains the rate of ergs to euros at any given period of time. The rate is updated by spending this box and creating another singleton box with the new rate.\nAt any instance, our LETS is uniquely defined by a global token box that contains some membership tokens with id letsTokenID. This box defines the LETS parameters such as the location, the currency unit, rateTokenID, etc. The token box is initially started with, say, 10000 membership tokens. Users can spend this box and create their individual LETS boxes as outputs of the transaction, such that each such output has exactly one membership token and the balance membership tokens are put in a newly created token box.\nA LETS box represents a LETS member and must be used in every transaction. For simplicity, this article restricts all LETS transaction to involve exactly two members, one being the sender and the other the receiver, such that the sender transfers some positive amount of the LETS currency (local euros) to the receiver. Such a transaction consumes the member's boxes and recreates them as output with the updated balance.\nThe Basic Variant To prevent spam and DDoS attacks, we require at least some minimum number of ergs (minErgsToJoin) to be locked in the newly created member's box. The ergs will be locked until at least minWithdrawTime number of blocks have been mined. A box is allowed to have a negative LETS balance upto the amount that can be covered by the locked ergs (using the rate at the time of trade).\n// a tokenBox stores the membership tokens and has this script val tokenBox = OUTPUTS(0) // the first output must also be a tokenBox // first output contains remaining LETS tokens  def isLets(b:Box) = { // returns true if b is a LETS box  // A LETS box must have exactly 1 membership token in tokens(0)  b.tokens(0)._1 == letsTokenID \u0026amp;\u0026amp; b.tokens(0)._2 == 1 \u0026amp;\u0026amp; blake2b256(b.propositionBytes) == memberBoxScriptHash \u0026amp;\u0026amp; SELF.R4[Long].get == 0 \u0026amp;\u0026amp; // start the box with zero LETS balance  b.value \u0026gt;= minErgsToJoin \u0026amp;\u0026amp; // the box must contain some minimum ergs  b.R6[Long].get \u0026lt;= HEIGHT // store the creation height in R6 } // how many lets boxes creared in the tx val numLetsBoxes = OUTPUTS.filter({(b:Box) =\u0026gt; isLets(b)}).size // In the transaction following is preserved for the token box ... tokenBox.tokens(0)._1 == SELF.tokens(0)._1 \u0026amp;\u0026amp; // token id tokenBox.tokens(0)._2 == SELF.tokens(0)._2 - numLetsBoxes \u0026amp;\u0026amp; // quantity tokenBox.propositionBytes == SELF.propositionBytes // script A LETS member's box is protected by the script below, whose hash memberBoxScriptHash is used above. The script requires exactly one (sender, receiver) pair per transaction.\nval validRateOracle = CONTEXT.dataInputs(0).tokens(0)._1 == rateTokenID val rate = CONTEXT.dataInputs(0).R4[Int].get val inBalance = SELF.R4[Long].get // LETS balance of current input val pubKey = SELF.R5[SigmaProp].get // owner of the current input val createdAt = SELF.R6[Long].get // height at which current input was mined  val index = getVar[Int](0).get // index of the corresponding output val out = OUTPUTS(index) val outBalance = out.R4[Long].get // LETS balance of the output  // A LETS box is one that has the same script as the current box val isMemberBox = {(b:Box) =\u0026gt; b.propositionBytes == SELF.propositionBytes} val letsInputs = INPUTS.filter(isMemberBox) // all LETS input boxes val letsOutputs = OUTPUTS.filter(isMemberBox) // all LETS output boxes  // The current input belongs to the receiver if its LETS balance increases // There may be some ergs in receiver\u0026#39;s input box. We need to ensure that // the receiver\u0026#39;s output box also contains the same amount of ergs as input val receiver = outBalance \u0026gt; inBalance \u0026amp;\u0026amp; out.value == SELF.value val getBalance = {(b:Box) =\u0026gt; b.R4[Long].get} // returns LETS balance of a box  val letsBalIn = letsInputs.map(getBalance).fold(0L, {(l:Long, r:Long) =\u0026gt; l + r}) val letsBalOut = letsOutputs.map(getBalance).fold(0L, {(l:Long, r:Long) =\u0026gt; l + r}) // sender box can contain less amount of ergs (sender may withdraw ergs provided // that any negative LETS balance of sender in out is backed by sufficient ergs) val correctErgs = out.value \u0026gt;= -outBalance * rate \u0026amp;\u0026amp; ( out.value \u0026gt;= SELF.value || SELF.R6[Long].get + minWithdrawTime \u0026gt; HEIGHT ) // for the receiver, we don\u0026#39;t touch the erg balance, // since a receiver is not actively involved in the transaction  inBalance != outBalance \u0026amp;\u0026amp; // some transaction should occur; balance must change SELF.tokens(0)._1 == letsTokenID \u0026amp;\u0026amp; // the current input has the right token out.tokens(0)._1 == letsTokenID \u0026amp;\u0026amp; // corresponding output has the right token validRateOracle \u0026amp;\u0026amp; // oracle providing rate has the correct \u0026#34;rate token\u0026#34; letsBalIn == letsBalOut \u0026amp;\u0026amp; // total LETS balance is preserved in the transaction letsInputs.size == 2 \u0026amp;\u0026amp; letsOutputs.size == 2 \u0026amp;\u0026amp; // only two LETS inputs, outputs out.propositionBytes == SELF.propositionBytes \u0026amp;\u0026amp; // out is a LETS box ... out.R5[SigmaProp].get == pubKey \u0026amp;\u0026amp; // ... with the right pub key out.R6[Long].get == SELF.R6[Long].get \u0026amp;\u0026amp; // ... and creation height (receiver || // either current input belongs to receiver ...  (pubKey \u0026amp;\u0026amp; correctErgs) // ... or out has correct ergs and tx has signature ) The transaction spending a box with the above script requires:\n The sum of the LETS balance of inputs and outputs is preserved There are two LETS inputs and two LETS outputs The public keys (stored in R5) is preserved in the corresponding output The creation height (stored in R6) be preserved in the corresponding output  We say that some public key is the receiver if the LETS balance of its output is higher than that of its input.\nThe last condition requires that either the input and output boxes belong to the receiver (so that the ergs are preserved), or, in case they belong to the sender, a signature is provided and the output is backed by the required number of ergs if its LETS balance is negative. Furthermore, it requires that the sender's ergs balance cannot be reduced until at least minWithdrawTime number of blocks have been mined after the ergs were locked.\nCompared to the managed LETS, the above system has the following differences:\n No membership record: Unlike the managed LETS, We don't store any membership information here. Multiple-boxes: A person can create multiple membership boxes, which is permitted. We only require that any negative balance be backed by the corresponding number of ergs locked in it.  LETS-1: Zero Sum, Collateral The above is the basic variant, which we call LETS-1. It has the following features:\n Time-locked Joining-Fee: To prevent spam attacks, a member has to pay a certain minimum fee in ergs at the time of joining. This fee is refundable but only after a predefined number of blocks. Zero Sum: The sum of the LETS balances of all member boxes is zero. Member boxes are allowed to have a negative balance as long as it is within a certain limit. Collateral: For the sender's output, ergs are used as collateral to cover negative LETS balance at the current exchange rate.  The following are some variations of LETS-1.\nLETS-2: Zero Sum, No collateral This is a slight variation of LETS-1 as follows:\n Non-refundable joining fee: Similar to LETS-1, a joining fee is needed to prevent spam attacks. However, unlike LETS-1, this fee is non-refundable and must be sent to some predefined management committee. Zero Sum: As in LETS-1.  LETS-3: Positive-Sum, Collateral The above two variants require the total LETS balance to be always zero. Here we consider a positive value for this sum. In particular, this variant has the following properties:\n Time-locked Joining Fee: As in LETS-1. Positive Sum: The LETS balance of every member must always be non-negative. This ensures that the sum of the LETS balances of all member boxes is positive. The initial LETS balance is set to a positive value based on the joining fee at the current rate, capped to some maximum value. Collateral: Any reduction in ergs balance of the sender must be accompanied by a reduction of the corresponding LETS balance at the current exchange rate.  We can also allow topping up the LETS balance during a transaction by adding the equivalent amount of ergs.\nLETS-4: Positive-Sum, No collateral This is similar to LETS-3 but with some small variations:\n Non-refundable Joining Fee: As in LETS-2 Positive-Sum: As in LETS-3  The following table summarizes the variants:\n    Zero Sum Positive Sum     Collateral LETS-1 LETS-3   No collateral LETS-2 LETS-4    We considered LETS transactions involving a single sender-receiver pair. More advanced models can allow multiple senders and receivers, and need not be in pairs.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_05_29-exchange/","subtitle":null,"title":"A Trustless Local Exchange Trading System"},{"contents":"Overview Ergo’s native token is called Erg and its emission schedule may be of keen interest to users and miners of the platform. Ergs also have some unique characteristics which are highlighted in this post. Most basically and leaving out technical details, Ergo has a strictly limited supply, an 8‐year emission schedule and a declining rate of emission over these 8 years. All tokens are mined through an original Asic and Pool‐resistant Proof‐of‐Work (“PoW”) algorithm called Autolykos. Therefore, there are 0 Ergs in existence at launch of mainnet as there was no ICO nor pre‐mine. At the end of 8 years, the final Erg supply will be 97,739,925 Ergs. The Ergo block interval is 2 minutes and for the first 2 years, each block will release a total of 75 Ergs to be shared between the miners and the Treasury (Treasury discussed below). But starting at year 2, the rate of emission will fall by 3.0 Ergs and thereafter further decline every 3 months by an additional 3.0 Ergs, which will result in an end to emission 8 years after launch. There will be no additional inflation and the Erg monetary base will remain fixed. The Emission Chart below illustrates this.\nThe Ergo Treasury To fund development, promotion, events, to swap Ergo’s Ergo First Year Tokens (“EFYT”, further discussed below) into Ergs and to fund other activities which may advance the platform, Ergo has in place a Treasury which will receive 4.43% of the Ergs released during emission. During the first 2 years post‐mainnet launch, the Treasury will receive 7.5 Ergs per block. Given that the block reward for each block is 75 Ergs total, the Treasury’s allocation of Ergs is equivalent to 10% of the total block reward over the first 2 years and leaves miners with a block reward of 67.5 Ergs per block. After 2 years, the Treasury will continue to receive the part of the block reward that exceeds 67.5 Erg, however, this will be 0 after year 2.5 when the block reward becomes 66 Ergs per block. Readers familiar with some other PoW protocols with a Treasury, such as ZCash, may find this to be similar, however, it should be noted that the amount of Ergs going to the Treasury comprise a total of only 4,330,791.5, or 4.43% of the total monetary base, and is completed in just 2.5 years. This compares with ZCash’s Treasury, which was 10% of the ZCash total monetary base and 20% of all issued ZCash coins during the first 4 years. With Ergo, it is hoped that by 1 year post‐mainnet launch, Ergo will have achieved a high level of decentralization with a diverse developer, miner and user base. For the first year, the Treasury will be used for swapping of the EFYT on the Waves platform for Erg. For the remaining 1.5 years, a community voting mechanism will be put in place to determine how Treasury funds are spent.\nThe Ergo Emission Chart and Code The code for the emission schedule can be found here\nThe Ergo First Year Token (“EFYT”) EFYT was airdropped and distributed on Waves DEX starting with a 100,000 EFYT airdrop 2 years ago in May, 2017. EFYT served the dual purposes of helping to build an early community of stake holders and enthusiasts for Ergo and of raising a small amount of funds for the platform before launch to fund development, promotion etc. EFYT is strictly a Waves token and is not the same as an Erg, which is the Ergo mainnet native token mined after Ergo’s mainnet launch.\nEFYT will be swapped with a fraction of the Ergs mined within the first 1 year post mainnet launch. The planned mechanism for executing the swap is first, a new payment gateway will be set up on Waves for Ergo’s mainnet token, Erg. More on Waves payment gateways can be found here. After the gateway is set up, as the Ergo Treasury receives Ergs from the mining reward, the Treasury will deposit these Ergs to Waves via the gateway, at which time, the Treasury will make a bid in the market at fixed price of 1.00 ERG / 1.00 EFYT and owners of EFYT can then swap their EFYTs for Ergs and do as they wish with their Ergs including holding them on Waves, trading on Waves or transferring their Ergs out of Waves via the gateway to their own wallet for use elsewhere. All EFYT purchased by the Treasury in this process will be burned.\nThe current distribution of EFYT can be found here. It should be noted that the max supply of EFYT is 1,970,945.0. This is 10% of the first year of Ergo token emission and the same number of Ergs that the Treasury will receive, meaning that the Treasury will have received 1,970,945.0 Ergs during year 1, sufficient to swap the max supply of EFYT for Erg.\nHow can Ergo Issue the Entire Erg Supply in only 8 years whereas other PoW blockchains all have much longer emission schedules? Other than Ergo, few, if any, PoW protocols have such a short emission schedule as 8 years and it is worth mentioning what makes this possible for Ergo. Firstly, to briefly compare with just a few prominent PoW and recently issued PoW tokens, Erg supply is 100% issued after 8 years, with no long tail of emission, whereas emission of:\n Bitcoin is approximately 75% issued after 8 years with a long tail of emission to follow; ZCash and Ravencoin follow the same emission schedule as Bitcoin; Beam will be 75% issued after 8 years and has a long tail of emission; Grin inflation extends out indefinitely  Ergo’s short emission schedule is made possible through its new economic model, namely, the storage rent fee component of its protocol. Miners will have an additional source of income and a paper on that is available here. In summary, miners are able to deduct a storage rent fee every 4 years denominated in Erg from an unspent box (similar to a UTXO in Bitcoin) in exchange for the cost of keeping such box in state which resides in high cost memory. Therefore, miners will be highly incentivized to secure the network even in the absence of a block reward subsidy and this will lead to a more stable mining reward than just relying on transaction fees alone which miners will also receive. Other benefits from having the storage rent fee include prevention of “state bloat”, building of an economy around state (users must pay to keep unspent boxes in miners’ memory for the long‐term) and a gradual return of any lost coins back into circulation. Note that in Ergo, miners can use on‐chain voting to gradually change many key parameters including the storage rent fee, block size and maximum computational cost of a block.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_05_20-curve/","subtitle":null,"title":"The Ergo Emission Schedule"},{"contents":"","link":"https://ergoplatform.org/blog/2019_05_20-curve/","permalink":"https://ergoplatform.org/en/news/2019-05-20/","subtitle":"Ergo’s native token is called Erg and its emission schedule may be of keen interest to users and miners of the platform.","title":"The Ergo Emission Schedule"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.0.5","permalink":"https://ergoplatform.org/en/news/2019-05-17/","subtitle":"Wallet persistence added. Stateful validation of transactions via API.","title":"Testnet 2.0.5 released"},{"contents":"","link":"/docs/whitepaper.pdf","permalink":"https://ergoplatform.org/en/news/2019-05-15-whitepaper/","subtitle":"A deep general-purpose overview of the Ergo platform.","title":"Ergo whitepaper"},{"contents":"Step 1: Tools Visual Studio\nChoose free community version, you will need to select desktop development with C++ package during install.\nCUDA toolkit Choose your system version, install with default options, it will update your graphics driver to a compatible version.\nCurl\nGeneric version without SSL, binary won`t work. Choose generic source, zip and click on show mirrors. Download and unpack.\nOpenSSL 1.0.2\nDownload and install, select the OpenSSL binaries (/bin) directory during install.\nAutolykos GPU miner\nClick on clone or download and download zip and unpack.\nStep 2: Building libcurl Open the command line, go to c:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\vc\\Auxiliary\\Build\\ and run this script: vcvarsall.bat x64\nOpen the command line, go to unpacked Curl directory, then cd winbuild and run this command: nmake /f Makefile.vc mode=dll MACHINE=x64\nAfter a successful build, go to Curl directory, \\curl\\builds\\libcurl-vc-x64-release-dll-ipv6-sspi-winssl\\bin and copy libcurl.dll to \\Autolykos\\secp256k1 directory.\nStep 3: Building miner Open the command line, go to c:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\vc\\Auxiliary\\Build\\ and run this script: vcvars64.bat\nOpen command line and go to unpacked Autolykos GPU miner directory, then cd secp256k1 and edit winbuild.cmd file, change OPENSSL_DIR, LIBCURL_DIR to your OpenSSL and Curl main directories. You can change CUDA_COMPUTE_ARCH to GPU code architecture you want.\nRun winbuild.cmd and build your miner. After succesful build you should discover miner.exe in the same directory.\nStep 4: Mining Before you can mine, you have to configure your node, wallet and miner\nAfter your node is synced, wallet is configured and unlocked, you have to create mining configuration file config.json with following structure: { \u0026quot;seed\u0026quot; : \u0026quot;YourSeedString\u0026quot;, \u0026quot;node\u0026quot; : \u0026quot;https://127.0.0.1:9052\u0026quot;, \u0026quot;keepPrehash\u0026quot; : true } in the \\Autolykos\\secp256k1 directory.\nOpen the command line and go to \\Autolykos\\secp256k1 directory. Run miner.exe config.json\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_05_07_mining/","subtitle":null,"title":"How to mine Ergo on Windows(x64)"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/news/2019-05-07-release/","subtitle":"Due to delays in (mostly) testing and the security audit, we've decided to postpone the mainnet launch until June 20.","title":"Release postponed"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/foundation/","subtitle":"Foundation page","title":"Foundation"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/legal/","subtitle":"Legal page","title":"Legal"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/privacy/","subtitle":"Privacy page","title":"Privacy"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/use_cases/","subtitle":"Use Cases page","title":"Use Cases"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/wallets/","subtitle":"Wallets page","title":"Wallets"},{"contents":"","link":"https://docs.ergoplatform.com/teaser.pdf","permalink":"https://ergoplatform.org/en/news/2019-04-24-teaser/","subtitle":"High-level overview of the vision, consensus, clients, survivability, economy, and applicability.","title":"Ergo teaser"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/exchanges/","subtitle":"Exchanges page","title":"Exchanges"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/software/","subtitle":"Software page","title":"Software"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/tools/","subtitle":"Tools page","title":"Tools"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/basics/","subtitle":"Basics page","title":"Basics"},{"contents":"A local exchange trading system (LETS) is a local mutual credit association which members are allowed to create common credit money individually, with all the deals in the system written into a common ledger. As an example, assume that Alice with zero balance is willing to buy a liter of raw milk from Bob. First, they agree on a price, for example, assume that the price is about 2 Euro (as Alice and Bob are living in Ireland). After the deal being written into a ledger, Alice's balance becomes -2 (minus two) Euro, and Bob's balance becomes 2 Euro. Then Bob may spend his 2 Euro, for example, on home-made beer from Charlie. Often, such systems impose limits on negative balances, and sometimes even on positive ones, in order to promote exchange in the community.\nHistorically, such systems become popular during crisis times. The first system was established by Michael Linton in a Canadian town stuck in depression back in 1981. Local exchange trading systems were extremely popular during 1998-2002 Argentine Great Depression. Most LETS groups range from 50 to 250 members, with paper-based credit notes and ledger maintained by a core committee. However, paper-based LETS currencies have shown some problems, such as counterfeit notes, possible rogue behavior of system managers, and so on. Therefore, blockchain-based LETS could be superior to the old systems. More information on LETS could be found in \u0026ldquo;The Ecology of Money\u0026rdquo; book (by Richard Douthwaite) and Wikipedia.\nIn this article we show how LETS could be implemented on top of Ergo. To the best of our knowledge, this is the first implementation of such kind of community currency on top of a blockchain. Our reference implementation is simple and consists of two contracts, namely, a management contract and an exchange contract. We skip Ergo preliminaries, so please read the ICO article and ErgoScript tutorials(basic and advanced) for starters. Nevertheless, we are going to introduce a couple of new terms in following sentences. If a token is issued with amount equal to one, we call it the singleton token. Similarly, a box which contains the singleton token is called the singleton box.\nThe management contract is controlling a singleton box which holds members of the LETS system. The contract enables the adding of new members at the pace of one member per one transaction. The box is not storing members, but only a small digest of authenticated data structure built on top of the members\u0026rsquo; directory. A member is associated with a singleton token issued in a transaction which is adding the member to the directory. The transaction creates a new member's box which contains the member's singleton token. The member's box is protected by the exchange contract. Also, the newly created member's box has initial balance written down into the R4 register, and the balance is equal to zero in our example. The transaction creating a new member must provide a proof of correctness for directory transformation.\nThe management contract box is controlled usually by a committee, and the committee could evolve over time. To support that, we allow committee logic to reside in the register R5. For example, assume that a new committee member has been added along with a new LETS member, the input management contract box is requiring 2-out-of-3 signatures, and the output box requires 3-out-of-4 signatures. In this case contents of the R5 register in the input and the output box would differ.\nThe management contract code in ErgoScript with comments is provided below. Please note that \u0026ldquo;userContractHash\u0026rdquo; is about exchange contract hash.\nval selfOut = OUTPUTS(0) // Management script  val managementScript = selfOut.R5[SigmaProp].get // The management script template is replicating self, and management script is satisfied  val scriptCorrect = (selfOut.propositionBytes == SELF.propositionBytes) \u0026amp;\u0026amp; managementScript // A spending transaction is creating boxes for directory, user, fee.  val outsSizeCorrect = OUTPUTS.size == 3 // Checks that the management label token is replicating self  val outTokenCorrect = (selfOut.tokens.size == 1) \u0026amp;\u0026amp; (selfOut.tokens(0)._1 == letsToken) // Checks that new token is issued, and its amount is correct  // OUTPUTS(0) tokens already checked via outtokenCorrect  val issuedTokenId = INPUTS(0).id val userOut = OUTPUTS(1) val correctTokenAmounts = (userOut.tokens.size == 1 \u0026amp;\u0026amp; userOut.tokens(0)._1 == issuedTokenId \u0026amp;\u0026amp; userOut.tokens(0)._2 == 1 \u0026amp;\u0026amp; OUTPUTS(2).tokens.size == 0 \u0026amp;\u0026amp; outTokenCorrect) // Checks that the new user has been created with the zero balance  val zeroUserBalance = userOut.R4[Long].get == 0 val properUserScript = blake2b256(userOut.propositionBytes) == userContractHash // Checks that the new token identifier has been added to the directory  val selfTree = SELF.R4[AvlTree].get val toAdd: Coll[(Coll[Byte], Coll[Byte])] = Coll((issuedTokenId, Coll[Byte]())) val proof = getVar[Coll[Byte]](1).get val modifiedTree = selfTree.insert(toAdd, proof).get val expectedTree = selfOut.R4[AvlTree].get val treeCorrect = modifiedTree == expectedTree correctTokenAmounts \u0026amp;\u0026amp; scriptCorrect \u0026amp;\u0026amp; treeCorrect \u0026amp;\u0026amp; zeroUserBalance \u0026amp;\u0026amp; properUserScript correctTokenAmounts \u0026amp;\u0026amp; scriptCorrect \u0026amp;\u0026amp; treeCorrect \u0026amp;\u0026amp; zeroUserBalance \u0026amp;\u0026amp; properUserScript correctTokenAmounts \u0026amp;\u0026amp; scriptCorrect \u0026amp;\u0026amp; treeCorrect \u0026amp;\u0026amp; zeroUserBalance \u0026amp;\u0026amp; properUserScript The exchange contract script is fairly straightforward and provided below along with comments describing its logic. In the contract, it is assumed that a spending transaction for an exchange contract box is receiving at least two inputs, and the first two inputs should be protected by the exchange contract script and contain LETS member tokens. To check that singleton member tokens in the inputs do indeed belong to the LETS system, a spending transaction provides the management contract box as the first read-only data input, and also should provide a proof that the member tokens do belong to the directory authenticated via the R4 register of the management contract box. \u0026ldquo;letsToken\u0026rdquo; in the script is about the singleton token of the management box.\n// Minimal balance allowed for LETS trader  val minBalance = -20000 val lookupProof = getVar[Coll[Byte]](1).get // The read-only box which contains directory of LETS members  val treeHolderBox = CONTEXT.dataInputs(0) val properLetsToken = treeHolderBox.tokens(0)._1 == letsToken val membersTree = treeHolderBox.R4[AvlTree].get // A spending transaction is taking two boxes of LETS members willing to make a deal,  // and returns boxes with modified balances.  val participant0 = INPUTS(0) val participant1 = INPUTS(1) val participantOut0 = OUTPUTS(0) val participantOut1 = OUTPUTS(1) //Check that members do indeed belong to the LETS  val token0 = participant0.tokens(0)._1 val token1 = participant1.tokens(0)._1 val memberTokens = Coll(token0, token1) val membersExist = membersTree.getMany(memberTokens, lookupProof).forall({ (o: Option[Coll[Byte]]) =\u0026gt; o.isDefined }) // Check that LETS member balance changes during the deal are correct  val initialBalance0 = participant0.R4[Long].get val initialBalance1 = participant1.R4[Long].get val finishBalance0 = participantOut0.R4[Long].get val finishBalance1 = participantOut1.R4[Long].get val diff0 = finishBalance0 - initialBalance0 val diff1 = finishBalance1 - initialBalance1 val diffCorrect = diff0 == -diff1 val balancesCorrect = (finishBalance0 \u0026gt; minBalance) \u0026amp;\u0026amp; (finishBalance1 \u0026gt; minBalance) \u0026amp;\u0026amp; diffCorrect // Check that member boxes save their scripts.  // todo: optimization could be made here  val script0Saved = participantOut0.propositionBytes == participant0.propositionBytes val script1Saved = participantOut1.propositionBytes == participant1.propositionBytes val scriptsSaved = script0Saved \u0026amp;\u0026amp; script1Saved // Member-specific box protection  val selfPubKey = SELF.R5[SigmaProp].get selfPubKey \u0026amp;\u0026amp; properLetsToken \u0026amp;\u0026amp; membersExist \u0026amp;\u0026amp; diffCorrect \u0026amp;\u0026amp; scriptsSaved Note that both contracts could be modified in many ways to get new systems with different properties. So hopefully some day this article will be continued!\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_04_22-lets/","subtitle":null,"title":"A Local Exchange Trading System On Top Of Ergo"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/news/","subtitle":"News page","title":"News"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/faq/","subtitle":"Frequently asked questions page","title":"Faq"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/404/","subtitle":null,"title":"404"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/documents/","subtitle":"Documents page","title":"Documents"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/blog/","subtitle":"Blog page","title":"Blog"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/hall_of_fame/","subtitle":"Hall of Fame page","title":"Hall of Fame"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/about/","subtitle":"About page","title":"About"},{"contents":"This article describes a full featured ICO (Initial Coin Offering) implemented in ErgoScript. The example covers several important and novel features of the Ergo Platform and shows how it can support complex contracts with tiny amount of code.\nPart 1. Preliminaries An important design decision in a cryptocurrency protocol is specifying what a spending transaction actually spends. There are two possibilities here. The first a UTXO-based model, as in Bitcoin, where a transaction spends one-time asset containers (called as \u0026lsquo;coins\u0026rsquo; or UTXOs in Bitcoin) and creates new ones. The other is an account-based model, as in Nxt, Ethereum or Waves, where a transaction transfers some amount of asset from an existing long-living account to another, possibly new, long-living account, with possible side-effects on the way, such as contract execution in Waves or Ethereum. In this regard, Ergo is similar to Bitcoin, because it uses the UTXO-based approach, where one-time containers called boxes are being spent. Interestingly, an Ergo transaction can also have data-inputs which are not being spent, but rather used to provide some information from the current set of unspent boxes.\nIt is not trivial to create an ICO on top of an UTXO based model, because, in contrast to account-based models, there is no explicit persistent storage here. However, Ergo brings a spending transaction into the execution context of a script. With this small change it becomes possible to express dependencies between transaction outputs and inputs. In turn, by setting dependencies we can execute even arbitrarily complex Turing-complete programs on top of blockchain (see the \u0026ldquo;Self-reproducing Coins as Universal Turing Machine\u0026rdquo; paper). In this article we will define a concrete scenario of a multi-stage contract using an ICO, where we have three stages (funding, token issuance, withdrawal).\nNow imagine an ICO for thousands of participants. Unlike Ethereum, Ergo does not provide possibility to store large sets of data and carry them over throughout contract execution. Rather, it allows to store only about 40-bytes header of a data structure, represented as key -\u0026gt; value dictionary, authenticated similarly to Merkle tree. To access some elements in the dictionary, or to modify it, a spending transaction which is triggering protecting script execution should provide lookup or modification proofs. This gives possibility for a contract to authenticate potentially huge datasets without requiring much memory to store contract state. However, storing space in the state (of active contracts) would mean bigger transactions, but this problem is easier from scalability point of view, and scalability is a top priority for Ergo.\nPart 2. The ICO Contract There could be many possible scenarios associated with an Initial Coin Offering (ICO). In this article we consider an ICO that wants to collect at least a certain amount of funds (in Ergs) to start the project. Once the funding threshold is crossed and funding period ends, the project is kickstarted and ICO tokens are issued by the project based on the total funding collected. In the withdraw phase, which extends forever, the investors withdraw ICO tokens based on the amount they had invested during the funding period. The contract steps are briefly described below with details provided further:\n First, funding epoch takes place. It starts with a project's box authenticating an empty dictionary. The dictionary is intended for holding (investor, balance) pairs, where investor is a script protecting the box containing withdrawn tokens. For the balance, we assume that 1 token is equal to 1 Ergo during the ICO. During the funding epoch, it is only possible to put Ergs into the project's box. A funding transaction spends the project's box and creates a new project box with updated information. For that, a spending transaction for the project's box also has other inputs which hold investor withdrawing scripts. Investor scripts and input values should be added to the tree of the new box. There could be many chained funding transactions. Second, the funding period finishes, after which the tree holding the investors data becomes read-only. An authenticated tree could have different modification operations allowed individually: inserts, deletes, updates, or all the operations could be disallowed (so the tree could be in the read-only mode). Also, this transaction creates tokens of the ICO project which will be withdrawn in the next stage. The project can withdraw Ergs at this stage. Third, investors withdraw their ICO tokens. For that, a spending transaction creates outputs with guarding conditions and token values taken from the tree. The withdrawn pairs are also cleared from the tree. There could be many chained spending transactions.  These three stages should be linked together in the logical order. A seqience of boxes are used to achieve these goals.\nPart 3. The ICO Contract Details Now it is the time to provide details and ErgoScript code of the ICO contract stages.\nThe Funding Stage In the funding stage, which comes first, we assume that initially a project creates a box committing to an empty dictionary (stored in the register R5) with some guarding script described below. This stage lasts at least till height 2,000. More concretely, the first transaction with height of 2,000 or more should change the output box's script as described in the next section (transactions at lower heights must output a box with the same script).\nThe project's box checks that it is always first input and output of a transaction. The other inputs are considered investors\u0026rsquo; inputs. An investor's input contains the hash of a script in register R4. This hash represents the withdraw script that will be used later on in the withdraw phase. The hashes as well as the monetary values of all investing inputs should be added to the dictionary. The spending transaction provides a proof that investor data are indeed added to the dictionary, and the proof is checked in the contract.\nIt is not checked in the funding sub-contract that the dictionary allows only insertions, and not updating existing values or removals (it is not hard to add an explicit check though).\nThe spending transaction should pay a fee, otherwise, it is unlikely that it would be included in a block. Thus, the funding contract checks that the spending transaction has two outputs (one for itself, another to pay fee), the fee is to be no more than a certain limit (just one nanoErg in our example), and the guarding proposition should e such that only a miner can spend the output (we use just a variable \u0026ldquo;feeProp\u0026rdquo; from compilation environment in our example without providing any details). This \u0026ldquo;feeProp\u0026rdquo; corresponds to a standard, though not required by protocol.\nThe code below enforces the conditions described above. Please note that the \u0026ldquo;nextStageScriptHash\u0026rdquo; environment variable contains hash of the issuance stage serialized script.\nval selfIndexIsZero = INPUTS(0).id == SELF.id val proof = getVar[Coll[Byte]](1).get val inputsCount = INPUTS.size val toAdd: Coll[(Coll[Byte], Coll[Byte])] = INPUTS.slice(1, inputsCount).map({ (b: Box) =\u0026gt; val pk = b.R4[Coll[Byte]].get val value = longToByteArray(b.value) (pk, value) }) val modifiedTree = SELF.R5[AvlTree].get.insert(toAdd, proof).get val expectedTree = OUTPUTS(0).R5[AvlTree].get val properTreeModification = modifiedTree == expectedTree val outputsCount = OUTPUTS.size == 2 val selfOutputCorrect = if(HEIGHT \u0026lt; 2000) { OUTPUTS(0).propositionBytes == SELF.propositionBytes } else { blake2b256(OUTPUTS(0).propositionBytes) == nextStageScriptHash } val feeOutputCorrect = (OUTPUTS(1).value \u0026lt;= 1) \u0026amp;\u0026amp; (OUTPUTS(1).propositionBytes == feeBytes) val outputsCorrect = outputsCount \u0026amp;\u0026amp; feeOutputCorrect \u0026amp;\u0026amp; selfOutputCorrect selfIndexIsZero \u0026amp;\u0026amp; outputsCorrect \u0026amp;\u0026amp; properTreeModification The Issuance Stage This stage has only one spending transaction to get to the next stage (the withdrawal stage). The spending transactions makes the following modifications. Firstly, the it changes the list of allowed operations on the dictionary from \u0026ldquo;inserts only\u0026rdquo; to \u0026ldquo;removals only\u0026rdquo;, as the next stage (withdrawal) is only dealing with removing entries from the dictionary.\nSecondly, the contract checks that the proper amount of ICO tokens are issued. In Ergo, it is allowed to issue one new kind of token per transaction, and the identifier of the token should be equal to the (unique) identifier of the first input box. The issuance sub-contract checks that a new token has been issued, and the amount of it is equal to the amount of nanoErgs collected by the ICO at till now.\nThirdly, the contract checks that a spending transaction is indeed re-creating the box with the guard script corresponding to the next stage, the withdrawal stage.\nFinally, the project should withdraw collected Ergs, and of course, each spending transaction should pay a fee. Thus, the sub-contract checks that the spending transaction has indeed 3 outputs (one each for the project tokens box, the Ergs wirhdrawal box, and the fee box), and that the first output and output is carrying the tokens issued. As we do not specify project money withdrawal details, we require a project signature on the spending transaction.\nval openTree = SELF.R5[AvlTree].get val closedTree = OUTPUTS(0).R5[AvlTree].get val digestPreserved = openTree.digest == closedTree.digest val keyLengthPreserved = openTree.keyLength == closedTree.keyLength val valueLengthPreserved = openTree.valueLengthOpt == closedTree.valueLengthOpt val treeIsClosed = closedTree.enabledOperations == 4 val tokenId: Coll[Byte] = INPUTS(0).id val tokensIssued = OUTPUTS(0).tokens(0)._2 val outputsCountCorrect = OUTPUTS.size == 3 val secondOutputNoTokens = OUTPUTS(0).tokens.size == 1 \u0026amp;\u0026amp; OUTPUTS(1).tokens.size == 0 \u0026amp;\u0026amp; OUTPUTS(2).tokens.size == 0 val correctTokensIssued = SELF.value == tokensIssued val correctTokenId = OUTPUTS(0).R4[Coll[Byte]].get == tokenId \u0026amp;\u0026amp; OUTPUTS(0).tokens(0)._1 == tokenId val valuePreserved = outputsCountCorrect \u0026amp;\u0026amp; secondOutputNoTokens \u0026amp;\u0026amp; correctTokensIssued \u0026amp;\u0026amp; correctTokenId val stateChanged = blake2b256(OUTPUTS(0).propositionBytes) == nextStageScriptHash val treeIsCorrect = digestPreserved \u0026amp;\u0026amp; valueLengthPreserved \u0026amp;\u0026amp; keyLengthPreserved \u0026amp;\u0026amp; treeIsClosed projectPubKey \u0026amp;\u0026amp; treeIsCorrect \u0026amp;\u0026amp; valuePreserved \u0026amp;\u0026amp; stateChanged The Withdrawal Stage At this stage, investors are allowed to withdraw project tokens protected by a predefined guard script (whose hash is stored in the dictionary). Lets say withdraw is done in batches of size N. A withdrawing transaction, thus, has N + 2 outputs, where the first output carrys over the withdrawal sub-contract and balance tokens, the last output pays the fee and the remaining N outputs have guarding scripts and token values according to the dictionary. The contract requires two proofs for the dictionary elements: one proving that values to be withdrawn are indeed in the dictionary, and the second proving that the resulting dictionary does not have the withdrawn values. The sub-contract is below.\nval removeProof = getVar[Coll[Byte]](2).get val lookupProof = getVar[Coll[Byte]](3).get val withdrawIndexes = getVar[Coll[Int]](4).get val out0 = OUTPUTS(0) val tokenId: Coll[Byte] = SELF.R4[Coll[Byte]].get val withdrawals = withdrawIndexes.map({(idx: Int) =\u0026gt; val b = OUTPUTS(idx) if(b.tokens(0)._1 == tokenId) { (blake2b256(b.propositionBytes), b.tokens(0)._2) } else { (blake2b256(b.propositionBytes), 0L) } }) val withdrawValues = withdrawals.map({(t: (Coll[Byte], Long)) =\u0026gt; t._2}) val withdrawTotal = withdrawValues.fold(0L, { (l1: Long, l2: Long) =\u0026gt; l1 + l2 }) val toRemove = withdrawals.map({(t: (Coll[Byte], Long)) =\u0026gt; t._1}) val initialTree = SELF.R5[AvlTree].get val removedValues = initialTree.getMany(toRemove, lookupProof).map({(o: Option[Coll[Byte]]) =\u0026gt; byteArrayToLong(o.get)}) val valuesCorrect = removedValues == withdrawValues val modifiedTree = initialTree.remove(toRemove, removeProof).get val expectedTree = out0.R5[AvlTree].get val selfTokensCorrect = SELF.tokens(0)._1 == tokenId val selfOutTokensAmount = SELF.tokens(0)._2 val soutTokensCorrect = out0.tokens(0)._1 == tokenId val soutTokensAmount = out0.tokens(0)._2 val tokensPreserved = selfTokensCorrect \u0026amp;\u0026amp; soutTokensCorrect \u0026amp;\u0026amp; (soutTokensAmount + withdrawTotal == selfOutTokensAmount) val properTreeModification = modifiedTree == expectedTree val selfOutputCorrect = out0.propositionBytes == SELF.propositionBytes properTreeModification \u0026amp;\u0026amp; valuesCorrect \u0026amp;\u0026amp; selfOutputCorrect \u0026amp;\u0026amp; tokensPreserved Possible Enhancements Please note that there are many nuances our example contract is ignoring. For example, anyone listening to the blockchain is allowed to execute the contract and construct proper spending transactions during funding and withdrawal stages. In the real-world, additional signature from the project or a trusted arbiter may be used.\nAlso, there is no self-destruction case considered in the withdrawal contract, so it will live until being destroyed by miners via storage rent mechanism, potentially for decades or even centuries. For the funding stage, it would be reasonable to have an additional input from the project with the value equal to the value of the fee output. And so on.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_04_10-ico-example/","subtitle":null,"title":"An ICO Example On Top Of Ergo"},{"contents":"","link":"https://github.com/ergoplatform/ergo/wiki/Mining","permalink":"https://ergoplatform.org/en/news/2019-04-03-ergo-mining-tutorial/","subtitle":"Mining is the process of adding new blocks into the Ergo blockchain by performing resource-intensive computations.","title":"Ergo mining tutorial"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.0.3","permalink":"https://ergoplatform.org/en/news/2019-04-02-testnet-2.0.3/","subtitle":"Testnet 2.0.3 released with various bug fixes and GPU mining support.","title":"Testnet 2.0.3 released"},{"contents":"","link":"/en/blog/2019_03_19-qa/","permalink":"https://ergoplatform.org/en/news/2019-03-19/","subtitle":"Transcript of Q\u0026A session with Alex Chepurnoy and Dmitry Meshkov","title":"Q\u0026A session transcript. Mainnet launch is planned for May 26"},{"contents":"First, we have a major announcement - Ergo mainnet launch is planned for May 26 if no security vulnerabilities will be found during audit process!\nWhat are the vision about scaling and adoption? About scaling, the main approach is to avoid bloat without compromising functionality. E.g. persistent updateable storage is possible, with updates to be checked by a blockchain contract, but only digest of authenticated data structure (and some additional bytes, less than 40 bytes anyway) are stored in the UTXO set dependless on data set size. Storage rent is helping to remove dust from the UTXO set. Then light clients: in Ergo you can have full-node guarantees without storing UTXO set, if you do not mine. That's about much improved boostrapping and block validation times. With such improvements, it is possible to raise TPS without compromising classic blockchain assumptions and guarantees. Ok, but do you want concrete numbers? I don't have them, as parameters like block size etc are not set in stone, rather, miners can adjust them. So if a miner is experiencing low full block validation time (as hardware is getting better with time, as well as software), he may propose or vote to increase block size.\nOn adoption, we expect following people to come: 1. People valuing social contract among the system and its users. E.g. people dissatisfied with Ethereum forking. Ergo will not have hard-forks to update functionality, while it will be possible for community to upgrade the protocol in many aspects. 2. Because of (1) at least, and also limited supply, Ergo would be good as store-of-value asset (demurrage cost is small if you just store a coin in the system). 3. People who need for safe, simple, and and efficient financial applications. Ergo's Smart Money concept is much simpler that Ethereum's Smart Contracts, while powerful enough for most financial applications of the people not having very specific skills to develop Solidity contracts, or bunch of money to hire proficient devs. 4. Not ready to predict anything about big companies, but some businesses already expressing interest to do some tokens and contracts on top of Ergo. To early to announce anything though.\nIs there an example or usecase? We have many examples, contracts: oracles, crowdfunding, atomic cross-chains and single-chain (token-to-token) swaps, mixing, etc. Basic things are covered in the ErgoScript tutorial for developers.\nA document with more complex examples (cold wallets, mixing, Rock-Paper-Scissors game) will be published soon. Further, we'll show examples of ICO scenarios and a LETS system.\nPlease also take a look at the targeted microcredit contract example from \u0026ldquo;Smart contracts for the people\u0026rdquo; blogpost.\nDo you have intentions to build a native off-chain solution like lightning network? And what is your vision on community-driven approaches? Yes, we hope that they will occur at some point. Our goal now is to provide as flexible protocol as possible to make their implementation easy. Suprisely, we already have community members that are working on sidechain implementation on top of Ergo, but this work is in the early stage. We support any activity from our community, including sidechains)\nWhat blockchain project is similar to ERGO? In some aspects, Bitcoin (soft-forkability, but we're going much further), Coda (if it's the real thing, I need to check still; light client), Grin (FlyClient is similar to PoPoWs), ZCash (Equihash is similar to our PoW, but our params are stricter and our PoW is pool-resistant). Can not name anything like our language! So, in general, the Ergo is very unique.\nWhat is ErgoData and what are its practical use cases? And how long after Mainnet is it going to be implemented? ErgoData was planned to be a blockchain with the same technology under the hood, but different parameters to address needs of data-oriented applications. Now we're totally focused to launching the single chain and applications on top of it. I think ErgoData could come 2 or 3 years after, if there will be demand for such applications, and also based on applications limitations(especially, data-intensive) on top of Ergo may have. Supposedly, it will be a sidechain. Now there's good progress in this area, so supposedly by then we may have unconditionally good sidechains.\nWhen can we start mining? and can we mine with cpu? For sure you can start mining with CPU right now. Just set up a full node (check this guide) with mining = true config settings, and your node will start mining after the initial synchronization. Example config may be found here\nBut we are not on mainnet yet? So we can only mine testnet coins? Yes, you can only mine testnet coins now. GPU miner will be definitely available before mainnet(probably this or next week).\nWill there be a manual on how to setup a wallet? Wallet is one more thing that should be updated before mainnet launch, we take advice about it's secure setup and so on. For now you can only set up seed phrase as a plain text in your config file section 2 in set up post\nWhat are the minimum requirements to run a node? It all depends on your node regime. We haven't measured it precisely, we turn our full nodes on droplets with 4 Gb memory, 2 CPU, 80 Gb SSD drive, but it is like recommended config, not a minimum one.\nAre you planning any cooperation with other platforms (Waves for example)? What kind of? We're planning to be listed on Waves DEX (this will significantly simplify EFYT/ERG swap), no other cooperation with platforms is planned.\nDo you have plans to add an option to generate ERC721 alike tokens? Tokens that can't be splitted. You can issue one token per transaction for free, so it is not a problem to issue a huge amount of tokens (with 1 max supply). There is no standard to unite them into a class of similar tokens (no standard way to check, that token aa\u0026hellip;aa is of the same class of tokens as token aa...bb), but probably such kind of a standard will occur in the future.\nIs there an option to broadcast a batch of transactions at the same time? Ideally them to be included in same block. There is no API method to broadcast batch of transactions at the same time, but nothing stops you from broadcasting them one by one with no delays. So the should not be a problem to broadcast as many transactions as you wish simultaneously.Regarding Ideally them to be included in same block - it is possible to write some kind of a contract, that ensures that some batch of transactions were included in a single block (or where none of them was included), however, we haven't tried it yet. In addition this may require a miner with modifier rules of collecting transactions from mempool.\nIs there an option to send transaction with 0 value asset? So the token is in the transaction, but it's amount is 0? No, that's not possible\nIs there an option to send \u0026ldquo;sponsored\u0026rdquo; transaction? The transaction which fee is paid by a custom token. It might be done using the exchange example, so you can create a contract that buys your token for Ergo, and when a sender is going to send a token - he sells required amount of token and makes a transfer of the remaining amount of tokens inside one transaction.\nSo there is no way to transfer 0.0000001 of token? Every output in Ergo should have some amount of Erg in it. Transaction fee may be 0, but you should put some Erg amount to every output created.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2019_03_19-qa/","subtitle":null,"title":"Q\u0026A with Alex Chepurnoy and Dmitry Meshkov"},{"contents":"","link":"https://github.com/ergoplatform/ergo/wiki/Set-up-a-full-node","permalink":"https://ergoplatform.org/en/news/2019-03-17-how-to-set-up-full-node/","subtitle":"Tutorial explaining how to install and configure Ergo node.","title":"How to set up and configure full Ergo node"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.0.0","permalink":"https://ergoplatform.org/en/news/2019-03-14/","subtitle":"The super big step towards Ergo Platform launch! All the major features are implemented, just optimization, testing and security audit remain. It should be binary compatible with the mainnet, time to integrate and write your DApps!","title":"Testnet 2.0 is live! Smart contracts language updated"},{"contents":"","link":"https://docs.ergoplatform.com/ErgoScript.pdf","permalink":"https://ergoplatform.org/en/news/2019-03-12/","subtitle":"Paper published, we would be happy to get feedback!","title":"ErgoScript, a Cryptocurrency Scripting Language Supporting Noninteractive Zero-Knowledge Proofs"},{"contents":"A lot of blockchain-related news these days are saying us that a bank X or a corporation Y is going to use a \u0026ldquo;blockchain\u0026rdquo; to \u0026ldquo;reduce costs\u0026rdquo;. Basically it means that just another buzzword is considered by big banksters as just another tool to extract value from everywhere in a more efficient way, and also to save on cutting job positions.\nWhile I am avoiding to say anything about \u0026ldquo;Satoshi's vision\u0026rdquo; (nothing but speculations could be dug there after his exodus), a broad view I witnessed in the early years around online forums users is that a cryptocurrency should provide tools to enrich the ordinary people behind their small businesses providing no much above making ends meet, not depersonalized big financial capital. The tools of a cryptocurrency in the eyes of the original broad community vision should allow people to do economic activity dependless on business size, geographic location, interest rates set by big players, and so on. The tools should allow people to do contracts (no paper contracts, but digital, self-enforcing, and reasonably smart contracts) dependless on differences in jurisdictions, traditions, followed business practices etc.\nI hope Ergo would be useful here. Thousands of small cooperatives and individual entrepreneurs are more important to healthy and sustainable wealth growth around the globe than a couple of corporations hiding profits in offshore heavens.\nAs an example, let's consider a cooperative federation (such as Radical Routes) willing to provide financial help to an entrepreneur thousands kilometers away (say, in Rojava).\nWe need to assume some details now. In the first place, assume that there are four cooperatives in the network. They collectively lock 10,000 Ergs (in equal parts, so 2,500 Ergs each) in a contract, which says the following:\n The cooperatives are associated with public keys pubkeyA, pubkeyB, pubkeyC, pubkeyD. The entrepreneur is associated with a public key businessKey. The cooperatives are locking money in a coin protected by a funding contract, then doing due diligence and vote on whether to fund the entrepreneur or not. All the contract fund (10,000 Ergs) is going to the entrepreneur if 3 votes out of 4 are for that. Technically, the voting is done via 3-out-of-4 threshold signature. If voting is not successful (3 out of 4 signatures are not collected) before the block number 1,000, any cooperative (actually, anyone) can submit withdraw transaction, which is returning 2,500 Ergs (at least) to every cooperative. Further, the funding contract will also be called the voting contract. The investments could be spent on three goals, with some strict bounds. Namely, the entrepreneur must spend at least 5,000 Ergs on equipment, at least 2,000 Ergs on construction of a building needed, other funds the entrepreneur may spend arbitrarily. To be sure that equipment money will be spent on equipment, the cooperative federation is using public keys of known equipment sellers in the area of the entrepreneur. For example, consider that there are equipment sellers with public keys pubkeyTool1, pubkeyTool2, pubkeyTool3, pubkeyTool4 in the area. Technically, the transfer is organized as a collective signature of one equipment sellers (thus ring signature from equipment sellers ring AND entrepreneur's signature) Similarly, assume that there are 3 builders in the are cooperative federation is recognizing, associated with public keys pubkeyConstr1, pubkeyConstr2, and pubkeyConstr3. Similarly to the voting contract, if equipment and construction contracts are not co-signed before block number 5000, the federation cooperatives could withdraw funds.  There are different ways to define contracts in Ergo. A script in the low-level language, ErgoTree, is describing a (single) logical condition on whether a coin could be spent according it, and also a spending proof provided by a spending transaction. Internally, the condition is represented as a typed syntax tree thus the name. The structure is allowing us to do ahead-of-time cost analysis etc. Higher-level language called ErgoScript allows to have more traditional and readable description, use variables and break logic into subroutines.\nLet's start with the main contract defined in (1-3) above:\n{ val votingSuccess = atLeast(3, Array(pubkeyA, pubkeyB, pubkeyC, pubkeyD)) val properSpending = OUTPUTS(0).value \u0026gt;= 5000L \u0026amp;\u0026amp; blake2b256(OUTPUTS(0).propositionBytes) == spendingContract1Hash \u0026amp;\u0026amp; OUTPUTS(1).value \u0026gt;= 2000L \u0026amp;\u0026amp; blake2b256(OUTPUTS(1).propositionBytes) == spendingContract2Hash val withdrawCondition = HEIGHT \u0026gt;= 1000L \u0026amp;\u0026amp; OUTPUTS(0).value \u0026gt;= 2500L \u0026amp;\u0026amp; OUTPUTS(0).propositionBytes == pubkeyA.propBytes \u0026amp;\u0026amp; OUTPUTS(1).value \u0026gt;= 2500L \u0026amp;\u0026amp; OUTPUTS(1).propositionBytes == pubkeyB.propBytes \u0026amp;\u0026amp; OUTPUTS(2).value \u0026gt;= 2500L \u0026amp;\u0026amp; OUTPUTS(2).propositionBytes == pubkeyC.propBytes \u0026amp;\u0026amp; OUTPUTS(3).value \u0026gt;= 2500L \u0026amp;\u0026amp; OUTPUTS(3).propositionBytes == pubkeyD.propBytes (votingSuccess \u0026amp;\u0026amp; properSpending) || withdrawCondition } This script in the ErgoScript is to be compiled into a syntax tree (which is to be written into the blockchain in a serialized form) by binding it with concrete values for variables (pubkeyA, pubkeyB, pubkeyC, pubkeyD, spendingContract1Hash, spendingContract2Hash). spendingContract1Hash is a hash of (serialized) equipment spending script which will be provided below, spendingContract2Hash is a hash of construction spending script.\nThe equipment spending script is below:\n{ val spendingSuccess = (pubkeyTool1 || pubkeyTool2 || pubkeyTool3 || pubkeyTool4) \u0026amp;\u0026amp; businessKey val withdrawCondition = HEIGHT \u0026gt; 5000L \u0026amp;\u0026amp; OUTPUTS(0).value \u0026gt;= 1250L \u0026amp;\u0026amp; OUTPUTS(0).propositionBytes == pubkeyA.propBytes \u0026amp;\u0026amp; OUTPUTS(1).value \u0026gt;= 1250L \u0026amp;\u0026amp; OUTPUTS(1).propositionBytes == pubkeyB.propBytes \u0026amp;\u0026amp; OUTPUTS(2).value \u0026gt;= 1250L \u0026amp;\u0026amp; OUTPUTS(2).propositionBytes == pubkeyC.propBytes \u0026amp;\u0026amp; OUTPUTS(3).value \u0026gt;= 1250L \u0026amp;\u0026amp; OUTPUTS(3).propositionBytes == pubkeyD.propBytes spendingSuccess || withdrawCondition } And the construction script is:\n{ val spendingSuccess = (pubkeyConstr1 || pubkeyConstr2 || pubkeyConstr3) \u0026amp;\u0026amp; businessKey val withdrawCondition = HEIGHT \u0026gt; 5000L \u0026amp;\u0026amp; OUTPUTS(0).value \u0026gt;= 500L \u0026amp;\u0026amp; OUTPUTS(0).propositionBytes == pubkeyA.propBytes \u0026amp;\u0026amp; OUTPUTS(1).value \u0026gt;= 500L \u0026amp;\u0026amp; OUTPUTS(1).propositionBytes == pubkeyB.propBytes \u0026amp;\u0026amp; OUTPUTS(2).value \u0026gt;= 500L \u0026amp;\u0026amp; OUTPUTS(2).propositionBytes == pubkeyC.propBytes \u0026amp;\u0026amp; OUTPUTS(3).value \u0026gt;= 500L \u0026amp;\u0026amp; OUTPUTS(3).propositionBytes == pubkeyD.propBytes spendingSuccess || withdrawCondition } Now assume that the cooperative federation has created a coin protected by the voting contract. Below is how the entrepreneur can do his business:\n Create a transaction which consumes the coin and create at least three coins, one with equipment spending contract, another with construction spending contract, third is creating a coin protected by entrepreneur's public key. Send the transaction to the cooperatives, wait for the transaction with the threshold-signed input being published on the blockchain. Consider a contract with an equipment seller, co-sign a spending transaction. Consider a contract with a builder, co-sign a spending transaction.  The entrepreneur can easily run away without doing any business, but with no more than 3,000 Ergs. This can be fixed, e.g. this money could be made spendable only after block number 5,000, and before that money could be withdrawn by the cooperatives. For equipment and construction spendings, the entrepreneur is working along with some, presumably already reputable, business. Thus the investor is reducing its risks.\nYou can find code and example transactions online. Please note that we have more examples of complex signature schemes, multi-step contracts (with on-the-go execution paths revealing, like MAST in Bitcoin, but with cycles allowed), oracles, crowdfunding and so on. Please check our examples repository.\n","link":null,"permalink":"https://ergoplatform.org/en/blog/2018_10_19-smart-contracts/","subtitle":null,"title":"Smart Contracts for the People"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/en/search/","subtitle":"Search page","title":"Search"}]