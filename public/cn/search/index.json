[{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/","subtitle":null,"title":"Ergo"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.2.1","permalink":"https://ergoplatform.org/cn/news/2020_02_19/","subtitle":"内存池和矿工对链下交易的交易输出交易友好，在标题链下载期间用于同步检测的参数等等","title":"“ 发布尔格主网3.2.1版本 ”"},{"contents":"","link":"https://discordapp.com/invite/gYrVrjS","permalink":"https://ergoplatform.org/cn/news/2020_01_23/","subtitle":"欢迎加入我们","title":"尔格平台Discord 平台已经推出了"},{"contents":"我们想宣布尔格已经成功通过某些(最关键的)部分的安全审查。此次审查由 Jean- Philipee Aumasson 负责完成(也叫 veorq, https://aumasson.jp/ )。\n具体报告如下。没有发现任何重大问题。对所发现问题的评论如下:\n  关于钱包密码，我们将在下一版协议节点中提供建议。不确定密码法的执法力度会 到何种程度，但我们会对此做更多的咨询。\n  只有在启动新网络时修改”n”和”k”参数才有意义。修改挖掘节点中的这些参数将使 所生成的区块对其他节点来说无效。修改协议节点的该项参数意味着出现另一个分 叉(来自诚实协议参与者的区块将被拒绝)。所以可能不需要进行额外核验，因为 那些启动新网络的人会正确设置”n”和”k”的参数。\n  目前尔格节点(以及我们所知道的其他区块链协议节点和钱包，以及我们正在使用 的加密库)无法提供防止本地运行的侧通道攻击的保护(如恶意软件或病毒所发起 的时序攻击或内存检查)。所以，请保护好运行你钱包的设备!\n  ============================================================================== =============================\n% 尔格安全性评估% Jean-Philippe Aumasson % 2019 年 12 月日\n摘要 尔格团队邀请我们对其尔格平台的几个组件进行安全性评估\n 创建与验证西格玛协议证明 钱包对秘密的安全存储 工作量证明验证  这份简报介绍了我们的评估，并说明了我们所发现的问题以及应对措施建议。\n西格玛协议证明 尔格协议依赖于尔格脚本，其是一种支持西格玛语句的脚本语言，可以通过非交互式的 知识证明来进行证明以及验证。\n这些证明是一个类似于树的语句和/或阈值条件，其树叶是离散对数问题的知识证明。\n西格玛语句证明是非交互式的，这应归功于 Fiat-Shamir 的转换\n该逻辑在尔格脚本报告中有详细说明，并且详细的证明与验证流程在其附录 A 中有介 绍。\n实施过程中的挑战包括:\n  定义安全高效证明的编码，并且实现总是成功处理有效输入的序列化，以及总是无法处 理无效输入的反序列化。\n  根据规范正确地实现证明与验证功能，最重要的是确保没有无效语句能够成功通过验 证。\n  我们对这两个方面进行了回顾，根据存储库 sigmastate-interpreter中的代码和尔格脚本报 告，对(附录 A 中的)预期行为与实际所采取的行为进行仔细比较。\n我们会重点审议来自 SigSerializer、Interpreter 的代码以及 ProverInterpreter 特征和目标。\n我们主要寻找来自以下类别中的故障:\n 缺陷输入的不安全处理 不安全处理超长或超短的输入 大树深度或递归级时的行为 不安全使用 Scala 类型和结构 不合适的变量类型 整数溢出 竞态条件 逻辑缺陷  尽管进行了详尽审查，但是我们没未发现任何安全问题。\n协议的逻辑和内部机制是比较复杂的，我们认为最大的风险在于对证明进行分析与验 证。然而，为了利用这些漏洞，攻击者必须创建一个在某种程度上会令自己受益的语义 正确脚本，并且在不应通过验证的时候通过了验证。\n在软件安全方面，Scala 消除某些类别的缺陷，但是由于 Scala 的特定行为或未处理的错 误，Scala 代码可能依然会受到缺陷的困扰。\n钱包 因此，尔格钱包功使其用户能够用磁盘存储与恢复秘密，并且在初次使用的时候，可以 用一个新的种子对钱包进行初始化操作。\n该逻辑主要在 ErgoWalletActor 中进行定义，有关秘密存储的一个主要构件是 JsonSecretStorage。\n首次创建钱包时，InitWallet 命令执行以下操作\n 生成作为初始熵的 settings.walletSettings.seedStrengthBits 随机位。在默认情况下 ，生成 160 位。 从生成的随机位中生成一个 BIP39，其可以被视作一个熵位的编码。采用密码可选的标准 BIP39 逻辑。 使用 BIP39 基于 PBKDF2 的推导逻辑，从助记符中推导出种子。 采用一个随机数，通过 AES-GCM 将该种子加密到磁盘，使用拥有 128000 次迭代的 PBKDF2-HMAC-SHA256，并利用一个随机盐从密码中产生出一个密钥。  要像解锁一个已经创建的钱包，用户提供密码，钱包将尝试解密所存储的数据。\n为了从 BIP39 口令恢复现有帐户，需要执行一个类似于初始化的流程，只不过钱包将从 助记符中，而非从随机助记符中获得种子。\n我们在此确定的两种风险包括:\n  缺少对密码长度的检查:由于钱包实在磁盘上存储秘密，既然密码足以访问种子，从理 论来讲，密码的熵至少应当与助记符相同，而在实际上应该很难破解。因此，我们建议 采用最小的密码长度，如 16 个字符。\n  在钱包软件执行后，秘密值(密码、种子和派生私钥)的副本可能会留在内存中，其是 诸如 Scala 等垃圾收集语言的内在局限性。\n  共享相同内存地址空间的另一进程或用户可能会恢复这些秘密，并且他们也可能出现在 崩溃转储中。据我们所知，在纯 Scala 中没有有效的缓解。 ​\n工作量证明的验证 在先前检查奥托吕克斯共识协议工作量证明安全性之后，我们进行了另一轮检查，重点 关注其最新的验证逻辑，特别是在承诺 eb0f85a 中所做的更改。\n主要的相关文件是 AutolykosPowScheme，其他重要操作在诸如 HeadersProcessor 和 ModifierValidator 中实施。\n我们检查所实施的验证逻辑与奥托吕克斯共识协议规范中所规定的验证逻辑是否一致， 并且其已被妥善整合进区块头的验证逻辑。\n我们认为应解决以下问题:\n  对k 和 n 进行更严格的验证:虽然类强制执行 k\u0026lt;=32 (解决方案中的元素数量)和 n\u0026lt;31 (元素总数的 log2 值)，但依然可以从授权的参数中创建弱区块。因此，validate()函数可 能需要进行额外的验证，确认 n 和 k 是否等于预期的值。\n  断言 k 和 n 为正值，因为当前的负值(称作 Ints)将传递 assert 语句。\n  ","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020_01_12_security_audit/","subtitle":null,"title":"(Jean Philippe Aumasson 所进行的)安全审查"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_01_12_security_audit/","permalink":"https://ergoplatform.org/cn/news/2020_01_12/","subtitle":"尔格已成功通过了代码最关键部分的安全审核","title":"安全审核 (审核员 Philippe Aumasson)"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.2.0","permalink":"https://ergoplatform.org/cn/news/2020_01_07/","subtitle":"此版本包括重大更改和改进。需要重新同步，版本说明中有更多详细信息","title":"发布尔格主网3.2.0版本"},{"contents":"尽管当今此领域最活跃话题是如何普及区块链技术（这通常意味着出售给华尔街）以及如何与维萨卡和万事达卡等系统进行竞争（这通常意味着利用去中心化而放弃，或以效率的名义引入不明确的安全假设），显然有必要对加密货币变化的原因进行重新审视，这些变化大多与去中心化有关。我接下来将在此给出许多问题的明确答案。将90%的比特币开采能力都集中在一个房间里? 是否可行？两三个矿池控制大部分算力是否可能？审查也可行吗？让几乎全部新节点避免处理来自其创世区块的区块链是否可行？工作量证明货币开发者正在做一个旨在改变一致性算法的硬叉，使其再次变得对图形处理器(GPU)友好是否可行？我们能否总结一下与去中心化相关的全部问题？我们能否用技术手段解决大部分问题？\n去中心化涵盖技术、社会及跨界等众多领域的多个问题。研究人员和开发人员正在努力寻找技术解决方案，首选完美且高效的解决方案。然而，对于许多问题而言，依然没有找到解决方案，因此就需要社会解决方案。\n在这篇文章中，我将只讨论去中心化的技术方面，即采矿的去中心化和验证的去中心化。\n采矿的去中心化 关于采矿去中心化的两个最大的问题是专用硬件（如专用集成电路(ASICs)）和中心化池。\n凭借专用集成电路，一个拥有足够资金投资研发的大玩家可以从私人拥有的高效硬件中获得不公平优势。原则上来讲，对于任何类型的计算活动，开发性能优于商用计算设备（如CPUs 和GPUs）的专用硬件永远都是可能的。然而，对于不同的计算任务而言，研发努力与可能的结果却可能大相径庭。搜索一个完美（或者近似完美结果）背后的推理可能相当复杂（参见30多页厚的Equihash报告).\n对于大部分工作量证明加密货币而言（包括比特币、以太坊、ZCash），2-4个中心化挖矿池控制着大部分开采力。这可能意味着审查变得容易或者进行提前交易（例如，对交易所订单进行重新排序），因为在中心化池中，只有中心化池自己才有权决定其所负责的整个池中的候选区块。作为一种可能的结果，不可外包的采矿方案可以防止中心化池的出现。只有尔格平台因部署了一个名为奥托吕克斯共识协议(Autolykos)的实用性不可外包工作量证明方案（基于Equihash报告中据说是更难记忆的问题）而闻名。\n作为社会去中心化问题符合采矿去中心化的一个例子，有时工作量证明的开发者正在引入硬叉，以便一旦ASICs在未来主宰了挖矿市场，则工作量证明算法会对图形处理器再次变得友好。然而，尚不清楚为什么完全合法的活动总是被禁止，为什么开发人员（以及部分用户）可以出于特殊原因而做硬叉。\n验证的去中心化 验证的去中心化是关于核实区块链历史有效性的可能性。这种核实使人确信没有不好的东西（即：不符合协议）被注入到区块链中，从而给予用户拒绝恶意区块链的权利，即使其比其他方法吸收了更多的工作量。当用户激活软叉（UASF）的想法开始走红时，社会上有很多有关比特币社区此项权力的讨论。很好地总结了这种思维方式。最近一篇题为“谁为比特币担保”的文章很好的总结了这种思维模式。\n如果一个实体能够在合理的时间范围内通过花费数百万美元租用数据中心来进行验证，那么这个网络显然不是去中心化的。理想情况下，应该可以在商用硬件（如一台像样的笔记本电脑）上检查整个区块链的完整性。\n然而，新的区块链也倾向于吸收越来越多的功能，而且这些功能并非免费的。然后，研究社区的主题是关于如何在合理的假设下，通过修剪区块或系统状态（或两者）来检查整个区块链的完整性。这里可能的解决方案有：引导状态速览及基于此的区块链后缀（在以太坊协议节点中比较流行，甚至在一篇学术论文)中正式提出）、无状态节点（在尔格平台上实现 部分无状态，或者目前只存在于研究论文中的完全无状态）。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_12_12_new_quest/","subtitle":null,"title":"去中心化方面的新探索，第一部分：技术方面"},{"contents":"本教程将解释如何安装与运行全尔格节点。其不涉及采矿相关的内容。\n节点安全 节点的使用涉及几个重要方面的内容，你的钱包和钱的安全性取决于以下方面:\n 尔格节点需要在配置文件中存储安全关键参数。你永远不应把这个文件公开。 尔格节点提供用于与内置钱包互动的REST API。敏感的API方法需要一个安全令牌，你永远不要通过不可靠的渠道发送该令牌。 访问尔格REST API必须限制在认识的主机上。尤其是绝不允许通过互联网访问API。  先决条件 为了运行尔格节点，你需要JRE版本\u0026gt;= 将要安装的8。其中一种安装方式是使用 甲骨文安装Java.\n接下来需要下载最新的尔格客户端发行版 jar文件，并且创建一个节点配置文件。\n注意：你不用下载jar，你可以克隆资源库，然后通过发布sbt assembly指令，自己利用SBT 来创建jar。\nergo_folder是指存放jar的文件夹。\n首席运行节点 创建在ergo_folder中含有以下文本的配置文件ergo.conf。\nergo { directory = ${ergo.directory}\u0026#34;/.ergo\u0026#34; node { mining = false } wallet.secretStorage.secretDir = ${ergo.directory}\u0026#34;/wallet/keystore\u0026#34; } 参数${ergo.directory}指向jar运行的目录。向ergo_folder开启命令提示符和cd。然后发出以下命令来首次运行节点：\njava -jar ergo-\u0026lt;release\u0026gt;.jar --mainnet -c ergo.conf 之后节点将立即开始同步。API启动与进入到下一步需要等几分钟。\n注意：对于文件你可以使用任何名称，而非ergo.conf。全部配置参数将被传送给该文件，你只需要重写你想修改缺省值的参数。上述配置文件实际上有缺省值。\n计算你秘密的哈希值 首先，选择一个秘密来保护你的API。然后前往 http://127.0.0.1:9053/swagger#/utils/hashBlake2b 然后调用API来计算你秘密的哈希值。参考下图。\n复制含有哈希值的回复以便下一步使用（参见下图）。在我们的例子中，秘密是是 hello 谁的哈希值对应324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf.\n重要提示：你必须使用不同且比较复杂的秘密.\n利用API关键哈希值来更新配置文件 编辑配置文件ergo.conf然后粘贴前步所复制的哈希值。文件内容应当看似如下：\nergo { directory = ${ergo.directory}\u0026#34;/.ergo\u0026#34; node { mining = false } wallet.secretStorage.secretDir = ${ergo.directory}\u0026#34;/wallet/keystore\u0026#34; } scorex { restApi { # Hex-encoded Blake2b256 hash of an API key. # Should be 64-chars long Base16 string. # below is the hash of the string \u0026#39;hello\u0026#39; # replace with your actual hash apiKeyHash = \u0026#34;324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\u0026#34; } } 初始化钱包 重启节点并且前往http://127.0.0.1:9053/panel 以访问面板。然后设置上一步的API主要秘密。注意你需要设置秘密，而非配置文件的哈希值。在我们的举例中，这是字符串hello.\n最后，点击“初始化钱包”：\n在弹开窗口中，您必须输入钱包密码。助记符密码是或选项。点击发送后，钱包会返回一个助记句，如下图所示。\n你必须把这个句子抄下来，并把它保存在一个安全的地方。如果你要在其他计算机恢复你的钱包，就需要这个句子。\n获得钱包的地址 这是一个可以确保你正确设置节点的测试。它将返回钱包中的当前地址。 在http://127.0.0.1:9053/panel 的面板上，点击左侧的Wallet 条，然后点击 Get all wallet addresses 以浏览钱包目前所保存的地址。如果节点设置正确，那么至少应该返回一个地址。\n使用Swagger UI 你可以在http://127.0.0.1:9053/swagger找到Swagger UI。你还可以使用该UI对面板上（尚不）能用的高级操作进行API调用。你之前已经用其来计算你秘密的哈希值。你还可以使用这个UI来为面板中（尚未）提供的高级操作进行API调用。部分举例如下：\n 利用寄存器和上下文变量来创建非标准交易。 创建发出令牌的交易。 创建使用某些框作为输入值的交易。  未来的文章将逐一详细介绍这些操作。\n请注意API中的大部分方法都受到保护，你需要使用你（之前）的秘密来获得这些方法。接下来的图片将展示在Swagger UI中设置该秘密的流程。\n在页面顶端，点击“授权”键。在弹出框中输入您的秘密，如下图所示。\n输入密码后，点击“授权”，将跳出以下界面：\n现在转到http://127.0.0.1:9053/swagger#/wallet/walletAddresses ，然后点击“试一试”。你会看到你之前从面板上看到过的相同的地址列表。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_12_02_how_to_setup/","subtitle":null,"title":"如何设置与配置全尔格节点"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.1.2","permalink":"https://ergoplatform.org/cn/news/2019_10_14/","subtitle":"“此版本包括重新广播内存池交易。禁用了生成P2SH地址的API路由”","title":"发布尔格主网3.1.2版本"},{"contents":"","link":"https://help.hotbit.io/hc/zh-cn/articles/360036438614-Hotbit%E5%AE%9A%E4%BA%8E10%E6%9C%889%E6%97%A5%E4%B8%8A%E7%BA%BFERGO-ERG-","permalink":"https://ergoplatform.org/cn/news/2019_10_08_2/","subtitle":"10月9日15:00（北京时间）开放ERG充值，同时开放ERG/BTC交易对","title":"Hotbit交易所上线ERGO (ERG)"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.1.1","permalink":"https://ergoplatform.org/cn/news/2019_10_08/","subtitle":"新UI（127.0.0.1/panel）。以后会在新版本推出简单化钱包。新API方法能从脚本取得钱包状况和地址。","title":"发布尔格主网3.1.1版本"},{"contents":"","link":"https://github.com/bisq-network/bisq/releases/tag/v1.1.6","permalink":"https://ergoplatform.org/cn/news/2019_09_16/","subtitle":"BISQ, 是去中性化的P2P交易网络, 已经增加了尔格币（ERG）","title":"BISQ 已经正式了加了尔格币(ERG)"},{"contents":"","link":"https://p2pb2b.io/trade/ERG_BTC","permalink":"https://ergoplatform.org/cn/news/2019_09_14/","subtitle":"我们很荣幸地宣布尔格币($ERG) 已经在P2PB2B交易所挂牌交易","title":"尔格币($ERG) 已经在P2PB2B交易所挂牌交易"},{"contents":"什么是众筹？ 众筹是一种通过许多人的努力实现一种融资方式。众筹多通过全球网站启动，使项目和企业可以通过众多个人的小额出资来完成融资。通过众筹方式成功创业的最经典案例之一就是虚拟现实耳麦 - Oculus Rift。Oculus VR公司在2012年发起众筹，仅在两年后就被脸书以20亿美元的价格所收购。除了常规创业企业以外，还有许多区块链项目也选择采取众筹模式，例如：乙太坊、Tron和EOS。目前市场上有无数众筹平台。部分较大的众筹平台包括Indiegogo、Kickstarter和Gofundme，不一而足。众筹方式有很多好处：覆盖面广、高效以及最具说服力的营销… 但是现在，让我们看一下其最核心的一点！\n为尔格引入众筹模式 就在几天前的8月28日，核心开发者 Kushti 在（尔格论坛上）[www.ergoforum.org]表示他成功写出并且实施可以让用户在尔格区块链开展众筹活动的代码（如白皮书第6页. 所述。该代码甚至与当前的钱包API相结合。这里是如何建立钱包的快速指南。在这篇文章中，你将学习如何具体开展尔格众筹工作！还将带你看一下有史以来首次众筹建议书，其将为EIP1后众筹文本撰写工作提供资金支持。如果你想了解更多细节，请阅读以下“脚本”章节。此外，你也可以跳过这一章，直接阅读后面“如何捐款”、“如何收集捐款”以及“众筹项目建议书”等章节。\n脚本 根据尔格脚本白皮书（第6页）, 最简单的众筹脚本是“有关下列众筹情况的脚本：（持有主要出资人公钥的）项目出资人希望为（拥有要出资人公钥的）项目捐款，但前提是该项目在最后期限前从其他渠道筹集到足够的资金（至少达到融资下限）（以高度表示）。为了给项目捐款，出资人将创建一个受以下脚本保护的输出框。该脚本有两个条件：一种情况是最后期限已过，融资失败（出资人可以将钱要回来），另一种情况是成功实现融资（如果融资金额在最后期限前达到了所规定的最低融资门槛，那么项目就可以用这些钱）。\n为了确保融到足够多的资金，脚本将在全部输出结果中搜索一个框，并且向项目公钥分配足够多的值。为了检查输出框值的去向，脚本将读取保护输出框的脚本，并且将其与proveDlog对应的脚本进行比较（项目公钥）；该脚本可以通过projectPubKey.propBytes获得。\n由于目前API不支持嵌入自定义环境变量（只有诸如高度等预定义变量），因此编译脚本的唯一方法是用具体值替换白皮书中的这些变量。例如，想想看，如果一个众筹活动在第5万个区块前筹到500个尔格币，那么这次众筹就是成功的。 对于出资人公钥（backerPubKey）和项目公钥而言，我们可以采用目前只接受P2PK序列化钥匙的PK()函数。 如此，白皮书修订后的脚本如下：\n{ val backerPubKey = PK(\u0026#34;9h7DHKSDgE4uvP8313GVGdsEg3AvdAWSSTG7XZsLwBfeth4aePG\u0026#34;) val projectPubKey = PK(\u0026#34;9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq\u0026#34;) val deadline = 50000 val minToRaise = 500L * 1000000000 val fundraisingFailure = HEIGHT \u0026gt;= deadline \u0026amp;\u0026amp; backerPubKey val enoughRaised = {(outBox: Box) =\u0026gt;outBox.value \u0026gt;= minToRaise \u0026amp;\u0026amp; outBox.propositionBytes == projectPubKey.propBytes } val fundraisingSuccess = HEIGHT \u0026lt; deadline \u0026amp;\u0026amp; projectPubKey \u0026amp;\u0026amp; OUTPUTS.exists(enoughRaised) fundraisingFailure || fundraisingSuccess } 如何捐款 首先，JSON不支持多行字符串，因此需要用\\n替换换行符。此外，引号将被转意，因此使用“而非”。生成的JSON将被发送到/script/p2sAddress。为了给项目捐款，首先要从/钱包/众多地址中获得你的地址，比如说，提取它们中的第一个。把地址输入出资人公钥，这样在这一步之后对/脚本/p2sAddress的请求看起来以下情况：\n{ \u0026#34;source\u0026#34;: \u0026#34;{ val backerPubKey = PK(\\\u0026#34;9...\\\u0026#34;) val projectPubKey = PK(\\\u0026#34;9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq\\\u0026#34;) val deadline = 50000 val minToRaise = 500L * 1000000000 val fundraisingFailure = HEIGHT \u0026gt;= deadline \u0026amp;\u0026amp; backerPubKey val enoughRaised = { (outBox: Box) =\u0026gt; outBox.value \u0026gt;= minToRaise \u0026amp;\u0026amp; outBox.propositionBytes == projectPubKey.propBytes } val fundraisingSuccess = HEIGHT \u0026lt; deadline \u0026amp;\u0026amp; projectPubKey \u0026amp;\u0026amp; OUTPUTS.exists(enoughRaised) fundraisingFailure || fundraisingSuccess }\u0026#34; } 以及你的地址，而非“9…”.\n将字符串发送至 /script/p2sAddress以获得诸如以下反馈：\n{ \u0026#34;address\u0026#34;: \u0026#34;GB3kh2izpWKvyZfMboQwsEscjPaZcz9WrzGqZB4ZrkzRreiFMV6HZYWXGMK3rqCjDCoPgWGNzfnYSUhivW4a1VRYPE7uZXwKnBcqWcRkiuTx6QW55EcPcWeELUsumwdtKoFtWY583nWnKZff\u0026#34; } 复制地址字符串（GB3… 在我们的例子中），并且将钱通过/wallet/payment/send 汇入该地址。提出采用API方法发送10个尔格币（100亿个毫微尔格(nanoErgs)）的请求如下所示：\n[ { \u0026#34;address\u0026#34;: \u0026#34;GB3kh2izpWKvyZfMboQwsEscjPaZcz9WrzGqZB4ZrkzRreiFMV6HZYWXGMK3rqCjDCoPgWGNzfnYSUhivW4a1VRYPE7uZXwKnBcqWcRkiuTx6QW55EcPcWeELUsumwdtKoFtWY583nWnKZff\u0026#34;, \u0026#34;value\u0026#34;: 10000000000 } ] 大功告成！\n现在钱包将可以自动找到区块链的币箱，因为其在退款条件下含有属于钱包的公钥。由于（对相同地址）一个输入值只产生一个输出值，因此钱包会定期通过与币箱进行最简单的交易以检查币箱是否有钱。 在退款高度（我们的例子中是50,000），钱包将花币箱里的钱，因此币箱价值将在加入/钱包/余额。请注意在采用EIP-1 3后，情况会有所不同，因为到那时候钱包将采用窄识别模式。\n如何收集捐款 与项目公钥挂钩的钱包将发现区块链上新到的币箱。然而，其将无法确保币箱是有钱的，因为钱包目前采用的是最简单的交易，对于此类支出交易，脚本是无法做到的。在 /wallet/boxes/uncertain 方法采用之前，这是项目发现新到币箱的唯一方法。那时候 /wallet/transaction/send 和手工提供的（在“inputsRaw”）序列化币箱（采用 /utxo/byIdBinary 通过标识符获得序列化币箱）。\n那时候Kushti自己完成，并且获得以下 交易.\n请注意EIP-1 也将打破这一工作流程。\nKushti 提议在区块50,000之前筹集500个尔格币，以（用Python语言）撰写命令行脚本，为EIP-1实施后组织与参与众筹活动作准备。命令行脚本比手工处理请求更为适合，亦可用来在其上面构建图形界面。\n司库的确提供一半的资金，因此其他人需要一起贡献另外250个尔格币。如果众筹活动失败，资金将被自动退回。由于目前筹款并非易事，Kushti将牵头这一工作，因此请使用以下由他所控制的密钥：\n9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq\n为了捐赠任何数额的款项，请阅读上面“如何捐款” 章节，用你的公钥取代出资人公钥，并且赋予金额适当的价值（请注意其以毫微尔格计值，1尔格= 1.000.000.000 毫微尔格）。 如果阁下有任何问题、建议或者希望参与我们的活动，欢迎随时加入我们的社交媒体群或论坛。\n如果阁下有任何问题、建议或者希望参与我们的活动，欢迎随时加入我们的社交媒体群或论坛。\nt.me/ergoplatform | t.me/ergo_mining | www.ergoforum.org\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_09_06_crowdfund/","subtitle":null,"title":"尔格和众筹"},{"contents":"","link":"https://twitter.com/Hotbit_news/status/1169883351093694464","permalink":"https://ergoplatform.org/cn/news/2019_09_06/","subtitle":"我们很荣幸地宣布尔格币($ERG) 将在Hotbit交易所挂牌交易","title":"尔格币($ERG) 将在Hotbit交易所挂牌交易"},{"contents":"","link":"https://x.vite.net/trade?symbol=ERG-000_BTC-000\u0026category=BTC","permalink":"https://ergoplatform.org/cn/news/2019_08_20/","subtitle":"我们很荣幸地宣布尔格币($ERG) 已经在Vgate交易所挂牌交易","title":"尔格币($ERG) 已经在Vgate交易所挂牌交易"},{"contents":"本教程将向你提供在Windows或Linux环境下利用AMD卡开采尔格币的所需信息.\n开发者MH Samadani 在正式推出后第3天就发表其AMD矿工，并且之后还在不断对其进行更新。为了跟踪其最新动态，你可以加入尔格采矿电报群并且搜索 #amdminer。你可以在此查看矿机。\n编码是基于OpenCL并且是完全开放源代码。如果你用的是Nvidia 卡，你可以在此找到CUDA矿机。\n请注意，使用任何封闭源代码矿机是不安全的。尔格的开采特点要求你必须将你的密钥提供给矿机，以在任何脆弱数据面临危险之前确定谁值得信任！\n以下是AMD卡的报告哈希率：\n rx570-8g: 22-24Mh/s rx580-8g: 23-25Mh/s rx Vega56: 24-26Mh/s  在进一步说明之前，我想对MH Samadani和主要开发人员Amin Moradi为矿工和同仁编写此教程的付出表示感谢！\n现在让我们开始吧！\n配置 将这些文件复制到相同的文件夹作为你的可执行文件，并且将你的种子字符串和节点地址添加到 config.json。除了在相同文件中设置keepPrehash: true 之外。\n Miningkernel.cl Prehashkernel.cl Ocldecs.h Ocldefs.h Libcurl.dll(在windows环境下) Config.json  对Linux的要求 1. 通过下载你来自amd.com特定Linux 发行版的AMDGPU-PRO 软件包来安装AMDGPU-PRO驱动器。打开该文件包，并且在终端窗口运行： $ amdgpu-pro-install --opencl=legacy,pal --headless 2. 安装OpenCL 头文件 $ apt install libcurl4-openssl-dev 3. 安装OpenSSL 1.02 $ apt install libssl-dev 对Windows的要求 1. 你需要至少一个AMD GPU，其驱动器安装了 amd.com 2. 从此处的 mhssadini’s github 下载与安装AMD APK 3. 如果没有现成的，利用含有可视化工作室工具链说明的源代码建造网络库libcurl 4. 从此处下载与安装OpenSSL 1.0.2 在Linux环境下建造 1. 在主目录下编辑 ErgoOpenCL.cpp ，并且加批注 #define TEST 或者取消批注 define TEST 以建造矿机或者测试机。 2. 将目录改为 ergoAMDminer/Ubuntu ，并且运行make. ./makefile 3. 如果每一步都运行无误，你应当可以在ergoAMDminer/Ubuntu/下找到ErgoOpenCL。继续，运行程序，开始开采。 ./ErgoOpenCL 针对Windows的预制版本 下载github，前往win64文件夹，然后执行 ErgoOpenCL_miner.exe 或 ErgoOpenCL_tester.exe。如果每一步都运行无误（参见要求与配置），其应当可以开始开采。\n在Windows环境下建造 打开 ErgoOpenCL.sln 可视化工作室。增加OpenCL、LibCurl和OpenSSL库。 包括目录：\n并且包括其他目录：\n其他库目录：\n其他依赖性：\n在ErgoOpenCL.cpp 文件中，加批注 #define TEST 以建造矿机，或取消批注define TEST 以建造测试机。\n如果你还有其他问题、建议，希望送花给 @mhs_sam 或者就是想加入社区，快加入我们的电报群 - 尔格采矿 或尔格平台 – 来打声招呼吧！\n祝挖矿顺利！\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_08_07_amd/","subtitle":null,"title":"利用AMD卡开采尔格币"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.6","permalink":"https://ergoplatform.org/cn/news/2019_08_06/","subtitle":"此次发布为矿工引进了一个针对累计交易输入脚本复杂性的过滤器。对钱包、API方法和Swagger UI进行了更新","title":"发布尔格主网3.0.6版本"},{"contents":"在今天的文章中，我们的将对尔格地址的格式化一窥究竟。除此之外，我们将说明他们具体的具体工作原理，以及什么使其优于其他类型的区块链地址。\n让我们从头说起。\n在你安装任何数字货币钱包的时候，你会自动创建一个地址。简单来说，这个钱包就好比一个传统银行账户，而地址就如同与之相匹配的账号。如果你需要把钱由甲打给乙、收款或者提走你的挖矿奖励，那么你就需要一个字母数字地址提取你的挖矿奖励。\n如果你希望利用尔格钱包启动，并且想深入了解其功能，请双击以下链接.\n那么，到底什么是地址呢？\n地址是与某些脚本相对应的短字符串，并且用于保护一个币箱 （在此贴中，核心开发者kushti 在我们的论坛中发表文章详细解释了什么是币箱(“box”)。\n与（十六进制编码）二进制脚本描述有所不同，尔格地址采用Base58编码，因此拥有一些二进制描述无法提供的非常有用的特性：\n 地址的完整性可以轻易通过一体化校验和进行检查（根据维基百科的解释，其是“出于探测那些在传输与存储期间可能导入错误之目的，从一堆数字资料中得出的小型数据”）。 地址的前缀告诉你网络和地址的类型。尤其是网络前缀可以防止你误将主网代币发到测试网的地址。 地址使用一个编码（即：上面提到的 Base58），其可以避免长得很像的字符 ，并且方便双击以及在电子邮件中进行换行。 地址是编码网络类型、地址类型、校验和以及足以与特定脚本相对应的信息。  让我们看一下含有有关网络和地址类型信息的前缀字节：\n可能的网络类型包括：\n 主网 - 0x00 测试网 - 0x10  地址类型包括（下述语义学）：\n 0x01 - Pay-to-PublicKey(P2PK) address 0x02 - Pay-to-Script-Hash(P2SH) 0x03 - Pay-to-Script(P2S)  对于地址类型，我们建立的内容字节如下：\n P2PK – 序列化（压缩）公钥 P2SH - 序列化脚本字节Blake2b256 哈希的前192个比特 P2S – 序列化脚本（这就是挖矿奖励的去处!）  举例来说，将10个尔格币发到P2PK 地址通常意味着对应的交易将包含一个币箱，在这个币箱中用P2PK地址中编码的公钥锁住10个尔格币。与此相类似， 如果是P2S地址，币箱将被地址中编码脚本锁住。如果是最复杂的P2SH脚本，币箱将获得特别预先确定脚本的保护，其将对脚本采用Blake2b256 哈希值前192个比特，在币箱支出时，应当会通过输入值显示。\n以下是特定地址将如何看待测试网的例子：\n 3 - P2PK (3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN) ? - P2SH (rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB) ? - P2S (Ms7smJwLGbUAjuWQ)  以下是他们对我们主网的看法：\n 9 - P2PK (9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA) ? - P2SH (8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg) ? - P2S (4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ)  归纳如下：\n 前缀字节 = 网络类型 + 地址类型 (举例来说，测试网的P2S脚本由Base58之前的0x13开始) 校验和 = leftmost_4_bytes (blake2b256 (前缀字节 || 内容字节)) 地址 = 前缀字节 || 内容字节 || 校验和  如果阁下对其中任何内容感兴趣，非常欢迎阁下加入我们的社区，并且在我们的电报群和/或论坛中咨询更多问题。期待你的加入！\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_07_24_ergo_address/","subtitle":null,"title":"尔格地址"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.4","permalink":"https://ergoplatform.org/cn/news/2019_07_19/","subtitle":"此次发布在候选区块生成算法中引入了一个带有时间标记的缺陷修复。向各位矿工强烈推荐","title":"发布尔格主网3.0.4版本"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.3","permalink":"https://ergoplatform.org/cn/news/2019_07_18/","subtitle":"此次发布包括修补与引入新的API方法。有关此次发布的更多详情，请点击","title":"发布尔格主网3.0.3版本"},{"contents":"","link":"https://magnumwallet.co/?coin=erg","permalink":"https://ergoplatform.org/cn/news/2019_07_11/","subtitle":"我们很荣幸地宣布尔格币($ERG) 已与Magnum钱包相挂钩","title":"尔格币已进入Magnum钱包"},{"contents":"首先，我们感谢各位热心人士、开发者、矿工、社会各界以及我们的家人在尔格开发与启动过程中所给予我们的大力支持与无私帮助。尔格的启动为团队在过去几年的初始研发画上了句号，同时也开启了一个新的时代，核心技术大体定调，继续完善协议落实与基建项目将成为工作重点。\n当前核心-尔格核心团队将全心致力于项目开发（至少，同时Foundation Treasury正在推进这方面的工作）。基于此，请允许我介绍一下当前项目的进展情况以及未来规划。\n项目的当前进展状况 首先，关于尔格，我想提醒各位注意以下几点:\n  其依然是一个相对保守的工作量证明区块链，其对尔格币的供应量会进行严格限制；这是一个类似于比特币的交易模式，在区块间精心挑选目标时滞等。从这种意义上来说，尔格币类似于比特币，并且时间已经证明这是对那些注重去中心化和币值稳定人的最佳选择。\n  尽管其是一种（含有未花费的交易输出的）类似于比特币的交易模式，在不牺牲安全的前提下，尔格币支持强化合约货币可能性。我们已经拥有众筹、首次代币发行、冷钱包合约等几个例子。同时，尔格可以轻松获得基于普通离散对数的零知识证明，因此其对于在此基础上设计的协议来说会更好（在某些情况下，会是唯一的选择）。例如，现在每3个多签名中就有2个在网络上完成，该签名维持零知识（因此没有第三方观察员可以确定哪两方实际签署了交易的输入）。同样，环状签名（每N个签名中就有1个维持零知识）将免费提供。另外请看一下Ergomix, 这是一个(非互动性混合计划)[https://docs.ergoplatform.com/sigmastate_protocols.pdf]，并且可能是首个实用的非互动性混合建议。\n  尔格对于常规代币提供原生支持。其还对可以信赖的认证数据结构提供支持（可信方在区块链以外对数据集进行的修订）或者不可信（根据合约规定在区块链上进行修订，然而只有非常小的数据集摘要被存储在未花费的交易输出（UTXO）集上）。\n  其拥有抗池的(pool-resistant)和（在一定程度上）抗ASIC（ASIC-resistant）奥托吕克斯工作量证明计划，主要针对最高级图形处理器(GPUs)，性能最优的GPUs是8gb+ RAM.\n  随着时间的推移，全节点数量可能会出现下降，为了更好地去中心化。尔格首次支持支持无国籍绝对安全客户。高效的轻钱包（SPV）客户支持也已经完成，但是这是采用(NIPoPoW技术)[https://nipopows.com/]，而非Grin所使用的FlyClient技术。\n  没有必要对修改区块容量以及许多其他参数进行激烈辩论。仅拿区块容量为例，一名矿工只需在一个纪元（其由1,024个区块所构成）开始时进行投票就好，如果纪元内有超过50%的矿工支持修改（区块容量增加或者减少1%），那就会进行修改。对于协议的许多方面来说，如果超过90%的采矿权投票是针对软分叉的，那么软分叉更新就是可能的。（具有软分叉属性的）比特币和（具有动态瓦斯限值的）以太坊可以在一定程度上进行协议参数修改。然而，尔格币可以通过其矿工投票机制来对协议的许多方面进行修改与改进。\n  目前所有这些特征或许还不太明显，因为其才启动一个星期，但是他们将从长期定义尔格币的独有特征。请注意，对于长期成功而言，你需要从第一原理开始，而尔格就是从第一原理开始的，而非仅仅是在技术方面（:请注意尔格在白皮书中第2章所记述明确定义的社会契约。\n推进尔格核心团队的职责 尽管参考节点的实施工作还算大体顺利，然而即便对于熟练用户而言，其界面依然令人感到困惑，现在还没有诸如钱包、用于开发应用程序的框架等基础设施。因此核心团队将在未来几个月花时间创建所需框架，改进应用程序界面（API）以及支持钱包和交易所，其部分工作目前已经上马。另外请注意：目前节点的许多构成要素效率还不高，因此在可预计的将来，节点性能将会大幅提高。与此同时，外部团队将继续开展安全性审查。对协议设计和参考实施最关键部分的审计工作已经完成，其有时候是由几方协作完成的。\n硬分叉政策 尔格正在努力避免硬分叉。发行（Emission）、工作量证明、交易模型基本原理以及其他核心问题绝对不应被修改，因为对设计核心部分的任何修改都意味着创建另一个区块链。但是，开发者可以在前12个月内提出硬分叉，当（且仅当）：\n 硬分叉只是为了修补安全漏洞。唯一例外是通过矿工投票使部分特定指令的成本可调整，其是有计划的，但不是在目前主网上完成的。 硬分叉获得超过90%矿工支持的时候。 硬分叉没有违反旧的合约、冻结或者转移任何资金。  社区很重要！ 开发对于外部贡献者来说应当更透明与开放，尔格的开发应当逐渐转变为采用EPIPs （EPIP是指“尔格平台改进建议”）。任何拟议修改应当首先作为正式文件（EPIPS）提出，在正式实施之前可以对其进行讨论、辩论与修改。这相当于比特币和以太坊所分别采用的BIPs和EIPs。\n尔格还需要一个与此相围绕的框架与应用生态系统。一部分资金将被用来奖励生态系统的开发者。奖励计划的详情将在稍后公布，然而，如果你有任何建议，可以立刻联系尔格核心团队。同时，团队非常欢迎各类建议以及所需的API改进想法等。鉴于团队对协议稳定性的承诺，从投资者的角度来看，相较于其他区块链，投资尔格以外的项目可能更有价值。\n此外，请帮助宣传尔格币这个概念！我们是一个刚刚蹒跚学步处于萌芽阶段的区块链，正在寻找那些有志于参与文件起草、撰稿和其他材料的志同道合者。\n尔格和尔格数据 首先，（几年前）曾宣布将会推出两个区块链 -尔格和尔格数据。它们的技术是相同的（或者非常类似），但是参数有所不同。尔格数据背后的主要思想是服务数据密集型应用需求，如：土地登记、证书名录等。\n目前，尔格数据的计划还不明朗。只有在用户对其产生需求的时候才会启动该网络。此外，尔格数据最可能是尔格的一个侧链。同时其无论如何不会在短期内推出，只有当尔格打下完善的基础设施基础后方可能推出。尔格数据链一旦推出，在尔格币推出时，尔格元年代币（EFYT）的持有者将会获得尔格数据（ErgoData）代币。推出时的EFYT持有者速览(snapshot)已经完成。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_07_09_after_launch/","subtitle":null,"title":"启动后的思路与尔格发展路线图"},{"contents":"","link":"https://ergoplatform.org/en/blog/2019_07_09_after_launch/","permalink":"https://ergoplatform.org/cn/news/2019_07_09/","subtitle":"非常感谢各位同业、开发者、矿工、社会各界人士以及家人在尔格开发与启动过程中所给予的大力支持与无私帮助。","title":"启动后的思路与尔格路线图"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.2","permalink":"https://ergoplatform.org/cn/news/2019_07_04/","subtitle":"该发布包括API改上","title":"尔格主网3.0.2发布"},{"contents":"","link":"https://ergoplatform.org/en/blog/2019_07_03_mining_withdrawal/","permalink":"https://ergoplatform.org/cn/news/2019_07_03/","subtitle":"本说明将帮助矿工提取其所挖到的资金","title":"尔格币提取说明"},{"contents":"花掉挖矿报酬 本文帮助矿工提取所挖到的资金。\n许多人既发布节点，又担任拥有从内嵌于节点格式化矿机获得16进制公钥（pubkeyHex）的矿工。下面我来谈一谈如何认定所挖尔格币的数量以及如何将其提取到另一个地址。\n关于密钥. 矿工可能遇到很多不同形式的密钥。\n首先，挖矿软件以及节点中的采矿支持（即：格式化文件中的 ergo.node.miningPubKeyHex 设定） 正在采用16进制编码（Base16-encoded）“原”公钥，其仅为椭圆曲线中的一个编码序列点。该密钥对矿工来说已经足够用（其可能避免支持58进制的需要，地址构成的需要等）。\n其次，节点钱包显示公钥付费（P2PK）地址，该地址以“9”开始。P2PK地址不仅包含椭圆曲线点，而且还包含网络前缀和校验和（checksum）， 类似于比特币的P2PK和P2PKH地址。\n第三，还有minig/rewardAddress API方法，其主要是针对外部工具所产生的候选区块。此种API方法看起来有点像88dhgzEuTXaSfKEbxfa6vghvEGdBH39sn9h7As2Y2Z6SGd8bKXCXmRLY5JtU4g4RYBP4WcZWb3JwjXDK，其是以编码形式支付给矿工的特殊文字。\n无论如何，如果你想把你矿机的16进制公钥（pubkeyHex）植入你的节点，完全没有问题，不用担心看到不同的密钥。\n显示你的余额以及提款 如果你先挖出来尔格币然后才进行钱包初始化，因为你进行钱包初始化的区块高度比挖币的时候要高，那么或许你看不到你挖的尔格币。请注意：节点不会对区块进行反向扫描，在初始化后，其只扫描新的区块。因此，为了找到所开采的尔格币，目前需要对整个区块链进行重新扫描（或者，如果你开采，在另一台机器上发布另一个节点，或者在格式化文件中拥有不同端口设置的同一台机器上，即，给scorex.restApi.bindAddress 和scorex.network.bindAddress的域设定新的值； 另外请使用3.0.1版本，主要是因为其更便于格式化）。\n为了把挖矿报酬花掉，你需要按照以下步骤进行操作： 1. 清除节点状态，如果你打算叫停工作节点。 为了清除你的节点的状态，你需要叫停节点，并且删除.ergo 目录下的全部内容（其可能藏在Mac和Linux你看不到的地方，尝试目录中的 ls -a 命令，你可以从此路径运行节点）。\n2.从奥托吕克斯矿机使用的种子短语中恢复本地钱包 在你格式化你的奥托吕克斯矿机时，请记住你在config.json 设定的助记符句子 - 目前你需要从那儿恢复内置钱包。为了恢复你的钱包，再次启动节点，并且将POST请求发送给含有诸如\n{ \u0026#34;pass\u0026#34;: \u0026#34;your_wallet_pass\u0026#34;, \u0026#34;mnemonic\u0026#34;: \u0026#34;mnemonic_sentense_from_your_miner\u0026#34;, \u0026#34;mnemonicPass\u0026#34;: \u0026#34;mnemonic_pass_if_set\u0026#34; } application/json 内容类型体的http://[your_node_ip]:9053/wallet/restore，\n如果 pass 是一个将用于你本地盘加密钱包数据的一把新的特殊钥匙， 并且 mnemonic 是一个你可以从奥托吕克斯矿机格式化文件(config.json)复制的助记符短语。请特别注意 mnemonicPass 的域 – 这是你的助记符短语口令，其为可选项，并且你在创造你的助记符的时候可能已经对其进行格式化。只有当你的助记符真地需要钥匙，那么就在请求中增加此域，否则就删除此域。\n不要忘记授权你的请求，设定对应 apiKeyHash正确的api_key HTTP 头字段， 在节点格式化文件中进行格式化。\n注意：为了让钱包扫描来自创世的全部区块，你需要在你的节点已经开始下载全部区块前恢复钱包（请在/info API方法回应核对fullHeight - 尽管其是 null 你的节点尚未开始下载全部区块）。\n3. 查询你的余额 当你的节点与网络实现同步的时候，请核对 /wallet/balances API方法。反馈应当类似于：\n{ \u0026#34;height\u0026#34;: 3560, \u0026#34;balance\u0026#34;: 67500000000, \u0026#34;assets\u0026#34;: {} } 首先注意 height 域 – 其应等于通过 /info API路径的 fullHeight 显示值。balance 是你钱包所发现的一个确认余额。\n4. 通过交易花掉你的报酬 为了从你的钱包中提走报酬，利用 /wallet/payment/send API路径创建一笔新的支付交易。为了进行这一操作，发送诸如\n{ \u0026#34;address\u0026#34;: \u0026#34;your_address\u0026#34;, \u0026#34;value\u0026#34;: 10000000 } 含有 application/json 内容类型体的POST请求， 如果 address 是你希望把你资金移去的地址并且 value 是你希望移走多少十亿分之一ERGs。\n在发送请求的时候，节点会回复交易ID作为回应。你可以利用 explorer 查询你的交易何时到达区块。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_07_03_mining_withdrawal/","subtitle":null,"title":"尔格提取"},{"contents":"","link":"https://twitter.com/Tidex_Exchange/status/1146161192878190594","permalink":"https://ergoplatform.org/cn/news/2019_07_02/","subtitle":"我们很荣幸地宣布尔格币($ERG) 在Tidex交易所挂牌交易","title":"尔格币($ERG) 在Tidex交易所挂牌交易"},{"contents":"","link":"https://explorer.ergoplatform.com","permalink":"https://ergoplatform.org/cn/news/2019_07_01_1/","subtitle":"尔格主网正式启动。欲了解更多详情，请点击: https://explorer.ergoplatform.com","title":"尔格主网正式启动"},{"contents":"","link":"https://explorer.ergoplatform.com","permalink":"https://ergoplatform.org/cn/news/2019_07_01_2/","subtitle":"尔格浏览器提供有关地址、区块和尔格平台交易的详细信息","title":"发布尔格浏览器"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.1","permalink":"https://ergoplatform.org/cn/news/2019_07_01/","subtitle":"该发布包括硬编码无预挖证明和创世状态根哈希，感谢所有为主网启动作出贡献的人","title":"尔格主网3.0.1发布"},{"contents":"","link":"https://p2pb2b.io/zh/","permalink":"https://ergoplatform.org/cn/news/2019_06_28/","subtitle":"尔格主链上线以后，尔格原生币(ERG)会挂牌。","title":"尔格会在P2PB2B 交易所上市"},{"contents":"自启动伊始加入尔格主网 为了在启动伊始加入尔格主网并且竞相开采创世区块，你需要按照以下步骤进行操作。如果你不打算参与尔格挖矿，而只是想建一个全节点，那么你只需进行步骤3和步骤5的操作。\n准备工作 1. 安装采矿软件 请先查阅https://github.com/ergoplatform/ergo/wiki/Mining的说明. 根据其（有关Ubuntu的）阅读说明或使用Windows手册https://ergoplatform.org/en/blog/2019_05_07_mining，搭建一个https://github.com/ergoplatform/Autolykos-GPU-miner矿机。 尝试运行诸如含有测试格式化的./auto.out config.json:\n{ \u0026#34;mnemonic\u0026#34;: \u0026#34;noise peasant subway frozen illegal pretty oak agent train valid wash title burst column yard decide move coin gas asset pretty hire happy fuel\u0026#34;, \u0026#34;node\u0026#34;: \u0026#34;http://159.203.36.162:9052\u0026#34;, \u0026#34;keepPrehash\u0026#34;: true } 并且查看诸如以下内容：\n2019-06-27 14:44:58,626 INFO [main thread] Using 1 GPU devices 2019-06-27 14:44:58,626 INFO [main thread] Using configuration file mine162.json 2019-06-27 14:44:58,628 INFO [main thread] Block getting URL: http://159.203.36.162:9052/mining/candidate 2019-06-27 14:44:58,628 INFO [main thread] Solution posting URL: http://159.203.36.162:9052/mining/solution 2019-06-27 14:44:58,629 INFO [main thread] Generated public key: pk = 0x03 F5214F2F6D87C714 4A2E12F8D4C4E110 1C59FF7D9AEABC11 77C4CB50FA8497E7 2019-06-27 14:44:58,714 INFO [main thread] Got new block in main thread, block data: { \u0026#34;MSG\u0026#34; : \u0026#34;3637B40440681781F92EDC92B33E623330F05705446168952CBD3720BA922442\u0026#34;, \u0026#34;B\u0026#34; : 3462030106355215694294694818737961234095984491840283822105474632310, \u0026#34;PK\u0026#34; : \u0026#34;03F5214F2F6D87C7144A2E12F8D4C4E1101C59FF7D9AEABC1177C4CB50FA8497E7\u0026#34; } 2019-06-27 14:44:58,956 INFO [GPU 0 miner] GPU 0 allocating memory 2019-06-27 14:44:58,964 INFO [GPU 0 miner] Preparing unfinalized hashes on GPU 0 2019-06-27 14:45:13,443 INFO [GPU 0 miner] GPU 0 read new block data 2019-06-27 14:48:02,298 INFO [main thread] Average hashrates: GPU0 24.8537 MH/s Total 24.8537 MH/s 上述通知表明你的矿机已经正确安装。\n2. 产生用于挖矿的助记符短语 如果你没有，请运行./auto.out –G以产生一个新的助记符短语。\n$ ./auto.out -G 2019-06-28 12:08:32,915 INFO [main thread] !!!Generated new mnemonic, put it in your config.json file!!! job great stage urge elite purity surprise any cram matrix typical table panel honey curious enlist fault matrix !!!Generated new mnemonic, put it in your config.json file!!! 2019-06-28 12:08:32,918 INFO [main thread] Generated public key: pk = 0x03 61F8098779E5EC8C 2A851E3EF57C471E 9A6803F60666E93E EB0BDD67411439D0 在上面的例子中，当你的公钥是0361F8098779E5EC8C2A851E3EF57C471E9A6803F60666E93EEB0BDD67411439D0，你所产生的助记符短语是job great stage urge elite purity surprise any cram matrix typical table panel honey curious enlist fault matrix。保存你的助记符短语（如：记在一张纸上）并且永远保存个私密的地方，任何能拿到这一信息的人都可能偷走你的钱。写下你的公钥，在接下来步骤里你需要它\n3. 格式化与开启矿机 创建一个含有以下内容的settings.json 格式化文件（别忘了替换\u0026lt;\u0026gt;括号中的内容):\n{ \u0026#34;mnemonic\u0026#34;: \u0026#34;\u0026lt;mnemonic generated at step 2\u0026gt;\u0026#34;, \u0026#34;node\u0026#34;: \u0026#34;http://\u0026lt;ip address of your node\u0026gt;:9053\u0026#34;, \u0026#34;keepPrehash\u0026#34;: true } 并且运行诸如./auto.out settings.json的矿机。其应进行初始化，并且开始为候选区块索取节点。\n2019-06-27 15:14:02,267 INFO [main thread] Using 1 GPU devices 2019-06-27 15:14:02,267 INFO [main thread] Using configuration file mainnet-conf.json 2019-06-27 15:14:02,269 INFO [main thread] Block getting URL: http://\u0026lt;ip address of your node\u0026gt;:9053/mining/candidate 2019-06-27 15:14:02,269 INFO [main thread] Solution posting URL: http://\u0026lt;ip address of your node\u0026gt;:9053/mining/solution 2019-06-27 15:14:02,269 INFO [main thread] Generated public key: pk = 0x02 F611D5F6AAB70C05 4A530C6420395B3C 4521642DC7125A93 49AAA2D9BB89D7AF 2019-06-28 12:21:36,035 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 2019-06-28 12:21:36,835 INFO [main thread] Waiting for block data to be published by node... 2019-06-28 12:21:36,876 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 2019-06-28 12:21:37,676 INFO [main thread] Waiting for block data to be published by node... 2019-06-28 12:21:37,718 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 不需要对矿机进行其它操作。\n4. 格式化与运行你的全节点 请先查阅https://github.com/ergoplatform/ergo/wiki/Set-up-a-full-node的说明。\n创建含有以下内容的一个settings.conf 格式化文件(别忘了替换\u0026lt;\u0026gt;括号中的内容):\nergo { node { mining = true miningPubKeyHex = \u0026#34;\u0026lt;your public key from step 2\u0026gt;\u0026#34; } chain { initialDifficultyHex=\u0026#34;011765000000\u0026#34; } } scorex { network { nodeName = \u0026#34;\u0026lt;some name to identify your node\u0026gt;\u0026#34; } restApi { # you may wish to configure an apiKeyHash to use your wallet. Check https://ergoplatform.org/en/blog/2019_06_04_wallet-documentation/ for wallet documentation.  apiKeyHash = \u0026#34;1111\u0026#34; } } 从https://github.com/ergoplatform/ergo/releases/tag/v3.0.1下载最新的主网发布，并且像nohup java -jar -Xmx3G -Dlogback.stdout.level=DEBUG ergo-3.0.1.jar --mainnet -c settings.conf那样运行，并且如果你看到类似以下内容：\n17:02:11.449 INFO [main] o.e.settings.ErgoSettings$ - Running in mainnet network mode 17:02:12.262 INFO [main] org.ergoplatform.ErgoApp - Entering coordinated network bootstrap procedure .. 17:02:12.933 INFO [main] o.e.BootstrapController - Wrong response format, retrying in 10s 17:02:22.933 INFO [main] o.e.BootstrapController - Wrong response format, retrying in 10s 你的节点已经完成正确格式化，不需要再进行任何其它操作。\n5. 等待主网启动 这几步完成后，你就完成了参与尔格挖矿的准备工作，你只需等待。你的矿机等待来自你节点的候选区块（block candidate），同时你的节点正在等待无预挖证明（proof-of-no-premine），该证明将由尔格开发团队根据主网启动时间表进行发布。无预挖证明将包含来自媒体（卫报、Vedomosti、新华社）的头条报道以及来自比特币和以太坊的最新区块鉴定人。在主网启动时，我们将分发无预挖证明，并且开挖启动。\n为了确保你的节点正在挖矿，你可能需要检查你的节点日志。应当停止从BootstrapController写日志，并且写Boot settings received. Starting the node, 这样日志文件将类似于以下文件：\n17:21:39.417 INFO [main] o.e.BootstrapController - Wrong response format, retrying in 10s 17:21:49.437 INFO [main] o.e.BootstrapController - Wrong response format, retrying in 10s 17:21:59.500 INFO [main] org.ergoplatform.ErgoApp - Boot settings received. Starting the node .. 17:21:59.554 INFO [ctor.default-dispatcher-3] s.c.n.NetworkController - Declared address: None 17:21:59.558 INFO [ctor.default-dispatcher-3] s.c.n.NetworkController - Registering handlers for List((1,GetPeers message), (2,Peers message)) 17:21:59.559 INFO [ctor.default-dispatcher-3] s.c.n.NetworkController - Successfully bound to the port 9030 17:21:59.565 INFO [ctor.default-dispatcher-4] o.e.n.state.ErgoState$ - Generating genesis UTXO state 17:21:59.568 INFO [ctor.default-dispatcher-2] o.e.local.ErgoMiner - Trying to use key from wallet for mining 17:21:59.583 INFO [ctor.default-dispatcher-3] s.c.u.NetworkTimeProvider - New offset adjusted: 2 17:21:59.585 WARN [ctor.default-dispatcher-3] o.e.n.ErgoReadersHolder - Got GetReaders request in state (None,None,None,None) 17:21:59.598 INFO [ctor.default-dispatcher-2] s.c.n.NetworkController - Registering handlers for List((55,Inv), (22,RequestModifier), (33,Modifier), (65,Sync)) 17:21:59.729 INFO [ctor.default-dispatcher-4] s.c.a.a.b.VersionedIODBAVLStorage - Update storage to version ByteArrayWrapper[6813BCA7232C6E156FB6229ECF165D157640A8576A5B320506E4C1B66011253402]: 14 elements to insert, 1 elements to remove 17:21:59.846 INFO [ctor.default-dispatcher-4] o.e.n.state.ErgoState$ - Genesis UTXO state generated with hex digest 6813bca7232c6e156fb6229ecf165d157640a8576a5b320506e4c1b66011253402 与此同时，你的矿工应当给你写下类似以下内容：\n2019-06-28 12:21:36,035 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 2019-06-28 12:21:36,835 INFO [main thread] Waiting for block data to be published by node... 2019-06-28 12:21:36,876 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 2019-06-28 12:21:37,676 INFO [main thread] Waiting for block data to be published by node... 2019-06-27 15:26:20,328 INFO [main thread] Got new block in main thread, block data: { \u0026#34;MSG\u0026#34; : \u0026#34;0777078E22BB64C771DE8A8D3B1E454847A91024D98AB86949091C8019FA7453\u0026#34;, \u0026#34;B\u0026#34; : 964934076977634961863091541739065898773646368992290869855043026179318012, \u0026#34;PK\u0026#34; : \u0026#34;02F611D5F6AAB70C054A530C6420395B3C4521642DC7125A9349AAA2D9BB89D7AF\u0026#34; } 2019-06-27 14:44:58,956 INFO [GPU 0 miner] GPU 0 allocating memory 2019-06-27 14:44:58,964 INFO [GPU 0 miner] Preparing unfinalized hashes on GPU 0 2019-06-27 14:45:13,443 INFO [GPU 0 miner] GPU 0 read new block data 2019-06-27 14:48:02,298 INFO [main thread] Average hashrates: GPU0 24.8537 MH/s Total 24.8537 MH/s 2019-06-27 15:27:11,033 INFO [GPU 0 miner] GPU 0 found and trying to POST a solution: ","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_06_28_mainnet-bootstrap/","subtitle":null,"title":"自启动伊始加入尔格主网"},{"contents":"","link":"http://github.com/ergoplatform/ergo/releases/tag/v2.2.0","permalink":"https://ergoplatform.org/cn/news/2019_06_27/","subtitle":"更新Sigma-State语言，新API方法","title":"发布“测试网2.2.0版(Testnet 2.2.0)”"},{"contents":"","link":"“http://twitter.com/ergoplatformorg/status/1143824003632685056”","permalink":"https://ergoplatform.org/cn/news/2019_06_26/","subtitle":"我们很快会指引关于在主网启动后如何迅速加入主网","title":"主网启动 ： 周一，7月1日，上午10:00 UTC"},{"contents":"","link":"https://t.me/ergo_mining","permalink":"https://ergoplatform.org/cn/news/2019_06_24/","subtitle":"欢迎CPU和GPU矿工加入","title":"尔格采矿电报(Ergo Mining Telegram)群现已开放"},{"contents":"","link":"https://twitter.com/Tidex_Exchange/status/1139282057643905024","permalink":"https://ergoplatform.org/cn/news/2019_06_14/","subtitle":"尔格原生币(ERG) 将在主网推出后立即上市","title":"EFTY（尔格元年代币）已经在Tidex挂牌上市"},{"contents":"","link":"https://twitter.com/ergoplatformorg/status/1139164264168591362","permalink":"https://ergoplatform.org/cn/news/2019_06_13/","subtitle":"由于交易所上市时间的推迟以及新发现的问题，我们已经决定将主网的推出时间推迟到6月28日进行。感谢阁下的耐心等待与长期支持！","title":"主网推出延后"},{"contents":"","link":"https://badcryptopodcast.com/2019/06/13/crypto-for-good-276/","permalink":"https://ergoplatform.org/cn/news/2019_06_13_2/","subtitle":"第276节：利用加密技术（Crypto）携手The Giving Block做善事","title":"具有尔格特征的坏加密播客(Bad Crypto Podcast)"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.1.2","permalink":"https://ergoplatform.org/cn/news/2019_06_12/","subtitle":"支持协调网络辅助程序。修复多个创世处理与地址的网络字节。","title":"发布测试网（Testnet） 2.1.2版"},{"contents":"","link":"https://www.youtube.com/watch?v=bsqcyLT8ddY","permalink":"https://ergoplatform.org/cn/news/2019_06_11/","subtitle":"比特币| DataDash所描述的货币未来的变化","title":"对为合约货币搭建框架名为“尔格”的平台所进行的访谈"},{"contents":"","link":"https://twitter.com/SwftCoin/status/1136293239219113986","permalink":"https://ergoplatform.org/cn/news/2019_06_05/","subtitle":"ERG将在主网推出后不久上市，其将可用于支付，并且与超过170种加密货币进行互换!","title":"与SWFT区块链的协议"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.1.0","permalink":"https://ergoplatform.org/cn/news/2019_06_05_3/","subtitle":"对所采用的软分叉特征进行投票表决，并且对Sigma-State语言进行更新。发布更为详细的说明。","title":"发布测试网2.1.0版"},{"contents":"","link":"https://bitcointalk.org/index.php?topic=5150971","permalink":"https://ergoplatform.org/cn/news/2019_06_05_2/","subtitle":"接着大约两年前开始的有关Bitcointalk的PRE-ANN线索来说，尔格团队宣布一个名为“尔格”对合约货币具有强适应力的平台即将上市。","title":"新的Bitcointalk线索"},{"contents":"尔格节点提供内置钱包以便存放私钥及签署交易。以下内容将说明如何建立与保护阁下的尔格钱包。\n该钱包将采用BIP39 标准从助记符句子中生出一颗种子，其将根据BIP32 标准用以创造一把私钥 （分层确定性钱包）。如果你愿意的话，你可以使用你自己的由那些词汇偏执狂常用词汇所构成的助记符句子。所允许的句子长度分别为12、15、18、21、24，分别代表128位、160位、192位、224位、256位安全。为了对这个有助记符的钱包进行初始化，你应当使用这个wallet/restoreAPI评估指标。然而，使用钱包所产生的助记符要安全得多。 在此阶段，与钱包的所有互动只能通过节点REST API完成。请确保你在进行下一步之前在你的节点上设置一把API密钥。\n钱包格式化 通过节点格式化文件对钱包进行格式化。以下是在首次钱包格式化时需要注意的格式化参数：\n ergo.wallet.seedStrengthBits - 如果其由节点产生，那么需要注意种子位的长度。注意：种子越强大，那么助记符句子的长度就会越长。选择： 128, 160, 192, 224, 256 ergo.wallet.secretStorage.secretDir - 请注意将机密以加密形式存储的目录 ergo.wallet.mnemonicPhraseLanguage - ergo.wallet.mnemonicPhraseLanguage – 请注意在助记符句子中将使用的语言。选择：\u0026quot;chinese_simplified\u0026quot;, \u0026quot;chinese_traditional\u0026quot;, \u0026quot;english\u0026quot;, \u0026quot;french\u0026quot;, \u0026quot;italian\u0026quot;, \u0026quot;japanese\u0026quot;, \u0026quot;korean\u0026quot;, \u0026quot;spanish\u0026quot;（ \u0026quot;简体中文\u0026quot;、\u0026quot;繁体中文\u0026quot;、\u0026quot;英文\u0026quot;、\u0026quot;法文\u0026quot;、\u0026quot;意大利文\u0026quot;、\u0026quot;日文\u0026quot;、\u0026quot;韩文\u0026quot;、\u0026quot;西班牙文\u0026quot;）  首次使用钱包 在首次运转节点的时候，需要通过REST API对钱包进行初始化。可以有两种选择：\n  通过向含有数据body: {\u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;, \u0026quot;mnemonicPass\u0026quot;: \u0026quot;abc\u0026quot;}的/wallet/init 提出POST请求，从头开始进行初始化（种子将通过节点产生）。不要忘记存储节点对应的助记符短语。（备注：请求主题中的参数 mnemonicPass 是可选项，并且可以用来保护助记符短语）。\n  从现有的种子中恢复钱包。你需要提供你的助记符短语：什么时候使用这一选项。这可以通过向含有数据body: {\u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;, \u0026quot;mnemonic\u0026quot;: \u0026quot;abandon abandon ...\u0026quot;, \u0026quot;mnemonicPass\u0026quot;: \u0026quot;abc\u0026quot;}提出 POST请求得以完成。（注意：只有当你的助记符短语在创建时被其他密码保护起来，才会需要mnemonicPass 字段）。\n  钱包开锁 在初始化后以及每次使用钱包前需要向含有数据body: {\u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;}的/wallet/unlock 提出 POST请求来进行解锁。（备注：在初始化阶段使用你已经选定的密码） 在每次节点重启或者钱包上锁的情况下，你必须走这一步。尤其是为了进行下列操作，钱包必须先解锁：\n 采用内部矿工 签署交易 跟踪框  钱包上锁 一段时间后钱包会自动上锁，这意味着所有当前加载的机密都将从内存中消失。你还可以通过向含有数据的/wallet/lock提出GET 请求，使用REST API 对钱包上锁。建议你在不用的时候对钱包上锁。上锁后，你需要对钱包进行重新解锁方能再次使用。\n管理密钥 钱包采用BIP32 （\u0026ldquo;分层确定性钱包\u0026rdquo;）。在钱包进行初始化的时候，只会创建根密钥。为了产生与特定衍生路径相对应的其他密钥对（方法：POST, 请求主体： {\u0026quot;derivationPath\u0026quot;: \u0026quot;m/1/2\u0026quot;}） /wallet/deriveKey API 路径可以使用。为了简化创建其他密钥对，可以使用a /wallet/deriveNextKey API 路径 （方法：GET）。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_06_04_wallet-documentation/","subtitle":null,"title":"钱包文件汇编"},{"contents":"本地交易所交易系统（LETS）旨在发展当地经济，并且通常由在彼此附近的当地人使用。 在此链接中描述了一个管理LETS的委员会。 我们将此类系统称为管理或许可，因为它取决于受信任的委员会。 在这里，我们描述了一个去信任的LETS系统，即没有管理委员会的系统。\n概要 LETS涉及多个同意使用某种形式的“本地货币”的党派，通常以1：1的比率与该国的主要货币挂钩。假设我们的LETS位于欧洲国家，货币为欧元，交换以“当地欧元”进行，被认为相当于国家欧元。\nLETS中的每个用户都有一个帐户，其中包含该用户的LETS余额（以本地欧元为单位）。在加入时，每个用户的余额为零。余额存储在（可能是去中心化的）分类帐中。 LETS的一个有趣特征是零余额的用户也可以“提款”，但仅用于支付另一个LETS用户。在任何时候，所有用户的LETS余额总和为零。\n例如，零余额的Alice希望从Bob那里以2欧元购买一升牛奶，Bob也是零余额的LETS成员。她将2欧元从她的账户转到Bob's，她的余额为-2，Bob为+2。然后，Bob可以将他的部分或全部余额转移给另一个LETS用户，以换取商品或服务。\n去信任的LETS 由于我们希望获得去信任的LETS，因此我们不能依赖任何受信任的群体来接纳用户。我们只假设又一个有信任的预言机（oracle）由一些全球账号和一个包含这个账号的一个代币的单例币箱标识。此币箱还包含在任何给定时间段内尔格币与欧元的比率。通过使用此币箱并使用新费率创建另一个单例币箱来更新费率。\n在任何情况下，我们的LETS由包含一些LETS成员资格代币的全局LETS币箱来定义。此币箱受以下脚本保护。代币账号唯一地定义了所使用的LETS的属性，例如位置，货币单位，费率预言机（oracle）账号等。一个或多个用户可以花费该币箱并创建他们各自的LETS币箱作为交易的输出。该币箱最初以例如10000 LETS会员代币开始。\n一个LETS币箱表示一个LETS成员，必须用于LETS交易。 LETS交易发生在两个LETS成员之间，一个是发送者而另一个是接收者，这样发送者将一些正数量的LETS货币（本地欧元）转移给接收者。这样的交易消耗成员的币箱并将其重新创建为具有更新余额的输出。\n基本变体 为了防止垃圾信息和分布式拒绝服务攻击，我们要求至少将一些最小数量的尔格币(minErgsToJoin)锁定在新创建的成员的币箱中。 尔格币将被锁定，直到至少minWithdrawTime数量的区块被挖掘为止。 允许一个币箱的LETS余额为负值，直至锁定的尔格币可以覆盖的金额（使用交易时的汇率）。\n// 一个币箱存储会员的代币 val tokenBox = OUTPUTS(0) // first output contains remaining LETS tokens def isLets(b:Box) = { // 一个LETS 币箱必须在代币中有正好一个会员资格代币(0)  b.tokens(0)._1 == letsTokenID \u0026amp;\u0026amp; b.tokens(0)._2 == 1 \u0026amp;\u0026amp; blake2b256(b.propositionBytes) == memberBoxScriptHash \u0026amp;\u0026amp; SELF.R4[Long].get == 0 \u0026amp;\u0026amp; // 从0 LETS结余中开始一个币箱  b.value \u0026gt;= minErgsToJoin \u0026amp;\u0026amp; // 币箱必须包含一些最小数量的尔格币  b.R6[Long].get \u0026lt;= HEIGHT // 将创建高度存储在R6中 } // 在tx中创建了多少lets币箱 val numLetsBoxes = OUTPUTS.filter({(b:Box) =\u0026gt; isLets(b)}).size // 在交易中，为币箱保留了以下内容 ... tokenBox.tokens(0)._1 == SELF.tokens(0)._1 \u0026amp;\u0026amp; // 代币账号 tokenBox.tokens(0)._2 == SELF.tokens(0)._2 - numLetsBoxes \u0026amp;\u0026amp; // 数量 tokenBox.propositionBytes == SELF.propositionBytes // 脚本 LETS成员的币框受以下脚本的保护，其哈希memberBoxScriptHash（成员币箱脚本哈希）被以上使用。\nval validRateOracle = CONTEXT.dataInputs(0).tokens(0)._1 == rateTokenID val rate = CONTEXT.dataInputs(0).R4[Int].get val inBalance = SELF.R4[Long].get // 当前输入下的LETS结余 val pubKey = SELF.R5[SigmaProp].get // 当前输入的拥有者 val createdAt = SELF.R6[Long].get // 当前输入开采的高度  val index = getVar[Int](0).get // 相关输出的指数 val out = OUTPUTS(index) val outBalance = out.R4[Long].get // 输出的LETS结余  // LETS币箱与当前币箱具有相同的脚本 val isMemberBox = {(b:Box) =\u0026gt; b.propositionBytes == SELF.propositionBytes} val letsInputs = INPUTS.filter(isMemberBox) // 所有LETS输入币箱 val letsOutputs = OUTPUTS.filter(isMemberBox) // 所有LETS输出币箱  // 如果LETS余额增加，则当前输入属于接收器 // 接收器的输入币箱中可能有一些尔格币，我们需要确保 // 接收器的输出币箱也包含与输入相同数量的尔格币 val receiver = outBalance \u0026gt; inBalance \u0026amp;\u0026amp; out.value == SELF.value val getBalance = {(b:Box) =\u0026gt; b.R4[Long].get} // 回到币箱的LETS结余  val letsBalIn = letsInputs.map(getBalance).fold(0L, {(l:Long, r:Long) =\u0026gt; l + r}) val letsBalOut = letsOutputs.map(getBalance).fold(0L, {(l:Long, r:Long) =\u0026gt; l + r}) // 发送人的币箱可以包含较少量的尔格币(发送人可以撤回提供的尔格币 // 发送者的任何负LETS余额都有足够的尔格币支持) val correctErgs = out.value \u0026gt;= -outBalance * rate \u0026amp;\u0026amp; ( out.value \u0026gt;= SELF.value || SELF.R6[Long].get + minWithdrawTime \u0026gt; HEIGHT ) // 对于接受者来说，我们并不接触尔格币的结余 // 因为接受者没有积极参与交易  inBalance != outBalance \u0026amp;\u0026amp; // 交易应该发生；结余必须变化 SELF.tokens(0)._1 == letsTokenID \u0026amp;\u0026amp; // 当前输入有正确的代币 out.tokens(0)._1 == letsTokenID \u0026amp;\u0026amp; // 对应地，输出也有正确的代币 validRateOracle \u0026amp;\u0026amp; // 预言机（oracle）提供费率具备正确的“费率代币” letsBalIn == letsBalOut \u0026amp;\u0026amp; // 总共的LETS结余被保存在交易中 letsInputs.size == 2 \u0026amp;\u0026amp; letsOutputs.size == 2 \u0026amp;\u0026amp; // 只有两个LETS输入，输出 out.propositionBytes == SELF.propositionBytes \u0026amp;\u0026amp; // 输出是一个LETS币箱 ... out.R5[SigmaProp].get == pubKey \u0026amp;\u0026amp; // ... 用正确的公钥 out.R6[Long].get == SELF.R6[Long].get \u0026amp;\u0026amp; // ... 和创建高度 (receiver || // ...要么当前输入属于接受者  (pubKey \u0026amp;\u0026amp; correctErgs) // ... 要么输出有正确的尔格币，同时tx有签名 ) 使用上述脚本支付币箱的交易需要：\n 保留了输入和输出的LETS结余之和 有两个LETS输入和两个LETS输出 公钥（存储在R5中）保存在相应的输出中 创建高度（存储在R6中）保留在相应的输出中  我们说如果输出的LETS结余高于其输入的LETS结余，则某些公钥是接收器。\n最后一个条件要求输入（和输出）币箱属于接收器（以便保留尔格币的数量），或者如果LETS余额为负，则输出由所需数量的尔格币支持。此外，它要求发送者的尔格币结余不能减少，直到在尔格币被锁定之后已经挖掘了minWithdrawTime的区块数量。\n与托管LETS相比，上述系统有以下不同之处：\n 没有会员记录：与托管LETS不同，我们不在此处存储任何会员信息。 多个币箱：一个人可以创建多个会员币箱，这是允许的。我们只要求每个币箱都锁定最小数量的尔格币。  LETS-1：零和，有抵押 以上是我们称之为LETS-1的基本变体。 它具有以下功能：\n 有时间限制的加入费：为了防止垃圾信息攻击，会员必须在加入时支付一定的最低费用。 此费用可退还，但仅限于预定数量的区块后。 零和：所有成员币箱的LETS余额总和为零。 只要在一定限度内，会员币箱就可以有负余额。 抵押品：对于发送人的输入，尔格币用作抵押品以支付当前汇率的负LETS余额。  以下是LETS-1的一些变体。\nLETS-2：零和，无抵押 这是LETS-1的略微变化如下：\n 不可退还的加入费：与LETS-1类似，需要加入费用以防止垃圾信息攻击。但是，与LETS-1不同，此费用不可退还，必须发送给某个预定义的管理委员会。 零和：与LETS-1一样。  LETS-3：正和，有抵押 以上两种变体要求总LETS余额始终为零。在这里，我们考虑这个总和的正值。特别是，此变体具有以下属性：\n 时间锁定加入费：与LETS-1相同。 正和：每个成员的LETS余额必须始终为非负数。这确保了所有成员币箱的LETS余额总和为正。初始LETS余额根据当前汇率的加入费设置为正值，上限为某个最大值。 抵押品：发送方的尔格币余额的任何减少必须伴随当前汇率的相应LETS余额的减少。  我们还可以通过添加等量的尔格币来允许在交易期间补足LETS余额。\nLETS-4：正和，无抵押 这类似于LETS-3，但有一些小的变化：\n 不可退还的加入费：与LETS-2相同 正和：与LETS-3一样  下表总结了这些变体：\n    零和 正和     有抵押 LETS-1 LETS-3   无抵押 LETS-2 LETS-4    ","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_05_29-exchange/","subtitle":null,"title":"一个去信任的本地交易所交易系统"},{"contents":"概要 尔格的原生代币称为尔格币，平台的用户和矿工对其发行时间表可能非常感兴趣。尔格币也有一些独特的特征，在这篇文章中将重点展现。最基本的并且省略技术细节的特征是：尔格有严格的供应量限制，8年的发行计划、以及8年来不断下降的的发行率。所有尔格币都通过原始的专用集成电路（Asic）和池阻工作量证明（“PoW”）算法称为奥托吕科斯（Autolykos），来进行挖掘。因此，在主网启动时存在0个尔格币，因为没有首次币发行也没有预挖。在8年结束时，最终的尔格币供应将是97,739,925个尔格币。尔格区块间距为2分钟，前两年每个区块将释放总共75个尔格币，供矿工和金库共享（下文讨论的金库）。但从第2年开始，发行率将下降3.0 个尔格币，然后每3个月进一步下降3.0个尔格币，这将导致在发行8年后结束发行。不会有额外的通货膨胀，而且尔格币基础货币将保持不变。下面的发行图说明了这一点。\n尔格金库 为了资助开发，推广，活动，将尔格的“尔格元年代币”（“EFYT”，Ergo First Year Token下文进一步讨论）交换为尔格币并为可能推进该平台的其他活动提供资金，尔格已经建立了一个金库，将获得尔格币总发行量的4.43％。在主网发布后的前两年，金库每个区块将获得7.5个尔格币。鉴于每个区块的区块奖励总计为75个尔格币，金库的尔格币分配相当于前两年总区块奖励的10％，并且矿工的区块奖励为每区块67.5个尔格币。 2年后，金库将继续获得超过67.5个尔格币的部分奖励，但是，当区块奖励达到每个区块66个尔格币时，2年半之后将变为0。熟悉其他一些带有金库的工作量证明协议的读者，如ZCash，可能会发现与之类似，但应该注意的是进入金库的尔格币总数仅为4,330,791.5，占总货币金额的4.43％，并在短短2年半完成。这与ZCash的金库相比，后者是ZCash总货币金额的10％和前4年所有ZCash币的20％。希望在主网发布一年后，尔格将通过多元化的开发商，矿工和用户群实现高水平的去中心化。第一年，金库将用于在尔格币的Waves（波）平台上交换尔格元年代币（EFYT）。在剩余的1年半内，将建立一个社区投票机制，以确定金库的资金支出情况。\n尔格发行图表和代码 发行计划的代码可以从此处获得\n尔格元年代币（“EFYT”Ergo First Year Token） 2年前，即2017年5月，从10万个“尔格元年代币”（“EFYT”）空投开始，尔格元年代币在Waves DEX上进行了空投和分发。尔格元年代币有助于建立尔格利益相关者和爱好者的早期社区以及筹集少量资金的双重目的。该平台在发布之前用于资助开发，推广等。尔格元年代币严格来说是一个Waves代币，与尔格币不同，尔格币是在尔格主网发布后挖掘的尔格主网本地代币。\n尔格元年代币将与主网发布后的前1年内开采的尔格币的一小部分进行交换。执行交换的计划机制首先是，将在Waves上为尔格的主网代币尔格币建立一个新的支付网关。有关Waves支付网关的更多信息，请点击此处。在建立网关后，当尔格金库从挖矿奖励中收到尔格币时，金库将通过网关将这些尔格币存入Waves，此时，金库将以1.00 尔格币/1.00EFYT的固定价格在市场上出价。尔格元年代币的所有者可以将他们的尔格元年代币交换为尔格币，并按照他们的意愿与他们的包含保存在Waves的尔格币进行交换，在Waves上交易或通过网关将他们的尔格币从Waves转移到他们自己的钱包以便在其他地方使用。在这个过程中由金库购买的所有尔格元年代币都将被烧掉。\n尔格元年代币的当前分发情况可以在这里找到。值得注意的是，尔格元年代币的最大供应量为1,970,945.0。这是尔格代币发行第一年的10％和金库将获得的尔格币数量相同，这意 味着 金库将在第1年收到1,970,945.0个尔格币，足以将尔格元年代币的最大供应量交换为尔格币。\n尔格如何在短短8年内发行整个尔格币供应，而其他工作量证明区块链的发行时间表更长？ 除了尔格之外，很少有（如果有的话）工作量证明协议仅有8年之短的发行时间表，尔格之所以能做到的原因是值得一提的。首先，简单地和一些突出的工作量证明和最近发布的工作量证明代币作比较，尔格币供应量在8年后完成100％发行，无长尾发行，而以下代币的发行是这样的：\n 比特币在8年后发行约75％，随后长尾发行; ZCash和Ravencoin遵循与比特币相同的发行计划; Beam将在8年后发行75％并具有长尾发行; Grin通胀无限期延长。  尔格的短发行计划是通过其新的经济模式实现的，即其协议的存储租用费特征。矿工将有一个额外的收入来源，这里有一篇相关论文。总而言之，矿工能够从未使用的币箱（类似于比特币中的UTXO）中每隔4年扣除一次在尔格币中计算的存储租用费，以换取将这种币箱保持在高成本记忆中的状态。因此，即使在没有区块奖励补贴的情况下，矿工也会受到高度激励以确保网络安全，这将导致更稳定的挖矿奖励，而不仅仅依靠矿工也能获得的交易费用。拥有存储租用费的其他好处包括防止“状态膨胀”、建立一个状态周边的经济（用户必须付钱以保持矿工记忆中未用完的币箱）以及任何丢失的硬币逐渐返回循环。请注意，在尔格生态中，矿工可以使用在线投票来逐步更改许多关键参数，包括存储租用费、区块大小和区块的最大计算成本。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_05_20-curve/","subtitle":null,"title":"尔格发行计划"},{"contents":"","link":"https://docs.ergoplatform.com/cn/whitepaper_cn.pdf","permalink":"https://ergoplatform.org/cn/news/2019-05-15-whitepaper/","subtitle":"尔格平台深层概述","title":"尔格白皮书"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/news/2019-05-07-release/","subtitle":"由于主要集中在测试和安全审核等方面的原因，我们决定将主链上线日期延迟到6月20日。","title":"主链延迟发布"},{"contents":"第1步：工具 Visual Studio(可视化工作室)\n选择免费的社区版本，您需要在安装期间选择使用C ++包进行桌面开发。\nCUDA工具包 选择您的系统版本，使用默认选项安装，它会将您的图形驱动程序更新为兼容版本。\nCurl\n没有SSL的通用版本，二进制不会工作。 选择通用源，压缩文件并单击显示镜像。下载并解压缩。\nOpenSSL 1.0.2\n下载并安装。\nAutolykos GPU矿工\n单击克隆或下载，并下载压缩文件并解压缩。\n第2步：构建libcurl 打开命令行，转到 c:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\vc\\Auxiliary\\Build\\ 并运行此脚本： vcvarsall.bat x64\n打开命令行，转到解压缩的Curl目录，然后进入winbuild文件夹并运行此命令： nmake /f Makefile.vc mode=dll MACHINE=x64\n成功构建后，转到Curl目录， \\curl\\builds\\libcurl-vc-x64-release-dll-ipv6-sspi-winssl\\bin 并将 libcurl.dll 复制到 \\Autolykos\\secp256k1 目录。\n第3步：建立矿工 打开命令行，转到 c:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\vc\\Auxiliary\\Build\\ 并运行此脚本： vcvars64.bat\n打开命令行并转到解压缩的奥托吕科斯图形处理器矿工（Autolykos GPU miner）目录，然后进入 secp256k1文件夹 并编辑 winbuild.cmd 文件，将 OPENSSL_DIR, LIBCURL_DIR 更改为OpenSSL和Curl主目录。 您可以将 CUDA_COMPUTE_ARCH 更改为所需的图形处理器代码体系结构。\n运行 winbuild.cmd 并构建你的矿工。 成功构建后，您应该能在同一目录中发现miner.exe。\nS第4步：挖掘 在挖掘之前，您必须配置您的节点，钱包和矿工 \n同步节点后，配置并解锁钱包，您必须在 \\Autolykos\\secp256k1 目录中，创建挖掘配置文件 config.json ，具有以下结构： {“seed”：“YourSeedString”，“node”：“https：//127.0.0.1：9052” ，“keepPrehash”：true}。\n打开命令行并转到 \\Autolykos\\secp256k1 目录。 运行 miner.exe config.json。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_05_07_mining/","subtitle":null,"title":"如何在Windows（x64）系统下挖掘尔格"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/foundation/","subtitle":"Foundation page","title":"Foundation"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/legal/","subtitle":"Legal page","title":"Legal"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/privacy/","subtitle":"Privacy page","title":"Privacy"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/use_cases/","subtitle":"Use Cases page","title":"Use Cases"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/wallets/","subtitle":"Wallets page","title":"Wallets"},{"contents":"","link":"https://docs.ergoplatform.com/cn/teaser%E5%B0%94%E6%A0%BC%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B_%E4%B8%AD%E6%96%87%E7%89%88.pdf","permalink":"https://ergoplatform.org/cn/news/2019-04-24-teaser/","subtitle":"高度概括了该平台的愿景、共识机制、客户端、存续性、经济模型及应用前景。","title":"尔格简介"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/exchanges/","subtitle":"Exchanges page","title":"Exchanges"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/software/","subtitle":"Software page","title":"Software"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/tools/","subtitle":"Tools page","title":"Tools"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/basics/","subtitle":"Basics page","title":"Basics"},{"contents":"本地交易所交易系统（LETS）是一个本地相互信用协会，允许成员单独创建共同信用资金，系统中的所有交易都写入共同的分类账。例如，假设拥有零余额的Alice愿意从Bob购买一升生鲜奶。首先，他们就价格达成一致，例如，假设价格约为2欧元（Alice和Bob居住在爱尔兰）。交易被写入分类账后，Alice的余额变为-2（减去2）欧元，Bob的余额变为2欧元。然后Bob可能会花费2欧元来购买Charlie的自制啤酒。通常，这种制度对负余额施加限制，有时甚至对正余额施加限制，以促进社区交易。\n从历史上看，这种系统在危机时期变得流行起来。第一个系统是迈克尔林顿于1981年在加拿大陷入萧条时的城镇建立的。1998-2002年阿根廷大萧条期间，当地的交易所交易系统非常受欢迎。大多数LETS团体的成员从50到250人不等，由核心委员会维护纸质信用票据和分类账。然而，基于纸张的LETS货币已经出现了一些问题，例如伪造票据，系统管理员可能的流氓行为等等。因此，基于区块链的LETS可能优于旧系统。有关LETS的更多信息可以在“货币生态”(The Ecology of Money”)一书(作者RichardDouthwaite) 和维基百科中找到。\n在本文中，我们将展示如何在尔格之上实现LETS。据我们所知，这是区块链上首次执行这种社区货币。我们的参考执行很简单，包括两个合同，即管理合同和交易合同。我们跳过尔格初步行动，所以请起步者阅读 首次币发行文章和ErgoScript教程(基础和 高级)。不过，我们将在以下句子中介绍几个新术语。如果发出的代币数量等于1，我们将其称为单例代币。类似地，包含单例代币的币箱称为单例币箱。\n管理合约控制一个单例币箱，该币箱容纳LETS系统的会员。合约允许以每笔交易一个会员的速度添加新会员。该币箱不存储会员，而是仅构建在会员目录之上的经过验证的数据结构的小摘要。会员与在交易中发出的单例代币相关联，该交易将会员添加到目录中。该交易创建一个新会员的币箱，其中包含会员的单例代币。会员的盒子受交换合同的保护。此外，新创建会员币箱的初始余额写入R4寄存器，在我们的示例中余额等于零。创建新会员的交易必须提供目录转换的正确性证明。\n管理合约币箱通常由委员会控制，委员会随着时间的推移而发展。为了支持这一点，我们允许委员会逻辑驻留在寄存器R5中。例如，假设已添加新的委员会会员以及新的LETS会员，输入管理合约币箱需要2/3个签名，输出币箱需要3/4个签名。在这种情况下，输入和输出币箱中R5寄存器的内容会有所不同。\n下面提供了尔格脚本中带有注释的管理合约代码。请注意“userContractHash”（用户合约哈希）是关于交易合约哈希。\nval selfOut = OUTPUTS(0) // 管理脚本  val managementScript = selfOut.R5[SigmaProp].get // 管理脚本模板正在自我复制，并且管理脚本已被满足  val scriptCorrect = (selfOut.propositionBytes == SELF.propositionBytes) \u0026amp;\u0026amp; managementScript // 支出交易正在为目录，用户，费用创建币箱。  val outsSizeCorrect = OUTPUTS.size == 3 // 检查管理标签代币是否正在自我复制  val outTokenCorrect = (selfOut.tokens.size == 1) \u0026amp;\u0026amp; (selfOut.tokens(0)._1 == letsToken) // 检查新代币是否发行，其数量是否正确  // OUTPUTS(0) 已经通过outtokenCorrect检查了代币  val issuedTokenId = INPUTS(0).id val userOut = OUTPUTS(1) val correctTokenAmounts = (userOut.tokens.size == 1 \u0026amp;\u0026amp; userOut.tokens(0)._1 == issuedTokenId \u0026amp;\u0026amp; userOut.tokens(0)._2 == 1 \u0026amp;\u0026amp; OUTPUTS(2).tokens.size == 0 \u0026amp;\u0026amp; outTokenCorrect) // 检查是否已使用零余额创建新用户  val zeroUserBalance = userOut.R4[Long].get == 0 val properUserScript = blake2b256(userOut.propositionBytes) == userContractHash // 检查新代币标识符是否已添加到目录中  val selfTree = SELF.R4[AvlTree].get val toAdd: Coll[(Coll[Byte], Coll[Byte])] = Coll((issuedTokenId, Coll[Byte]())) val proof = getVar[Coll[Byte]](1).get val modifiedTree = selfTree.insert(toAdd, proof).get val expectedTree = selfOut.R4[AvlTree].get val treeCorrect = modifiedTree == expectedTree correctTokenAmounts \u0026amp;\u0026amp; scriptCorrect \u0026amp;\u0026amp; treeCorrect \u0026amp;\u0026amp; zeroUserBalance \u0026amp;\u0026amp; properUserScript correctTokenAmounts \u0026amp;\u0026amp; scriptCorrect \u0026amp;\u0026amp; treeCorrect \u0026amp;\u0026amp; zeroUserBalance \u0026amp;\u0026amp; properUserScript correctTokenAmounts \u0026amp;\u0026amp; scriptCorrect \u0026amp;\u0026amp; treeCorrect \u0026amp;\u0026amp; zeroUserBalance \u0026amp;\u0026amp; properUserScript 交易合约脚本非常简单，下面提供了描述其逻辑的注释。 在合约中，假设交易合约币箱的支出交易正在接收至少两个输入，并且前两个输入应受交易合约脚本保护并包含LETS成员代币。 要检查输入中的单例会员标记是否确实属于LETS系统，开销交易会将管理合约币箱作为第一个只读数据输入，并且还应提供会员标记确实属于经过验证的目录的证据。 通过管理合约币箱的R4注册。 脚本中的“letsToken”是关于管理币箱的单例代币。\n// LETS交易者允许的最小余额  val minBalance = -20000 val lookupProof = getVar[Coll[Byte]](1).get // 包含LETS会员目录的只读币箱  val treeHolderBox = CONTEXT.dataInputs(0) val properLetsToken = treeHolderBox.tokens(0)._1 == letsToken val membersTree = treeHolderBox.R4[AvlTree].get // 支出交易需要愿意交易的LETS会员的两个币箱，  // 并返回修改余额的币箱。  val participant0 = INPUTS(0) val participant1 = INPUTS(1) val participantOut0 = OUTPUTS(0) val participantOut1 = OUTPUTS(1) //检查成员是否确实属于LETS  val token0 = participant0.tokens(0)._1 val token1 = participant1.tokens(0)._1 val memberTokens = Coll(token0, token1) val membersExist = membersTree.getMany(memberTokens, lookupProof).forall({ (o: Option[Coll[Byte]]) =\u0026gt; o.isDefined }) // 检查交易期间LETS会员余额的变化是否正确  val initialBalance0 = participant0.R4[Long].get val initialBalance1 = participant1.R4[Long].get val finishBalance0 = participantOut0.R4[Long].get val finishBalance1 = participantOut1.R4[Long].get val diff0 = finishBalance0 - initialBalance0 val diff1 = finishBalance1 - initialBalance1 val diffCorrect = diff0 == -diff1 val balancesCorrect = (finishBalance0 \u0026gt; minBalance) \u0026amp;\u0026amp; (finishBalance1 \u0026gt; minBalance) \u0026amp;\u0026amp; diffCorrect // 检查会员币箱是否保存了脚本。  // todo：可以在这里进行优化  val script0Saved = participantOut0.propositionBytes == participant0.propositionBytes val script1Saved = participantOut1.propositionBytes == participant1.propositionBytes val scriptsSaved = script0Saved \u0026amp;\u0026amp; script1Saved // 会员特定的币箱保护  val selfPubKey = SELF.R5[SigmaProp].get selfPubKey \u0026amp;\u0026amp; properLetsToken \u0026amp;\u0026amp; membersExist \u0026amp;\u0026amp; diffCorrect \u0026amp;\u0026amp; scriptsSaved 请注意，可以通过多种方式修改这两个合约，以获得具有不同属性的新系统。 所以希望有一天这篇文章会有后续！\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_04_22-lets/","subtitle":null,"title":"尔格之上的本地交易所交易系统"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/news/","subtitle":null,"title":"News"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/faq/","subtitle":"Frequently asked questions page","title":"Faq"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/404/","subtitle":null,"title":"404"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/documents/","subtitle":"Documents page","title":"Documents"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/blog/","subtitle":null,"title":"Blog"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/blog/","subtitle":null,"title":"Blog"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/hall_of_fame/","subtitle":"Hall of Fame page","title":"Hall of Fame"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/about/","subtitle":"About page","title":"About"},{"contents":"本文介绍了在尔格脚本中执行的功能齐全的ICO（首次币发行）。该案例涵盖了尔格平台的几个重要和新颖的特征，并展示了如何使用少量代码来支持复杂的合约。\n第1部分。初步行动 加密货币协议中的一个重要设计决策是指定支出交易实际花费的内容。这里有两种可能性。第一个基于UTXO(未花费的交易输出）的模型，如在比特币中，交易花费一次性资产容器（在比特币中称为'硬币'或UTXO）并创建新的。另一种是基于账户的模型，如在Nxt，以太坊或Waves中，交易将一定数量的资产从现有长存的账户转移到另一个，可能是新的长存的账户，这后续可能产生副作用，例如Waves或以太坊中的合同执行。在这方面，尔格类似于比特币，因为它使用基于UTXO的方法，其中一次性容器被称为币箱。有趣的是，尔格交易还可以有未被花费的数据输入，而是用于从当前未使用的币箱来提供一些信息。\n在基于UTXO的模型之上创建首次币发行并非易事，因为与基于帐户的模型相比，此处没有明确的持久存储。但是，尔格将支出交易带入脚本的执行上下文中。通过这种小的改变，可以表达交易输出和输入之间的依赖关系。反过来，通过设置依赖关系，我们甚至可以在区块链上执行任意复杂的图灵完备程序（参见\u0026ldquo;自我复制硬币作为通用图灵机\u0026rdquo;论文）。在本文中，我们将使用ICO定义多阶段合同的具体方案，其中我们有三个阶段（融资，代币发行，退出）。\n现在想象一下成千上万参与者的ICO。与以太坊不同，尔格不提供存储大量数据的可能性，并且在整个合同执行过程中都可以存储它们。相反，它允许仅存储数据结构的大约40字节的头，表示为键 - \u0026gt;值字典，与默克尔树类似地进行验证。要访问字典中的某些元素或对其进行修改，触发保护脚本执行的支出交易应提供查找或修改证明。这为合同提供了对潜在巨大数据集进行验证的可能性，而无需太多内存来存储合约状态。但是，在（活动合约）状态下存储空间意味着更大的交易，但从可扩展性的角度来看，这个问题更容易，并且可扩展性是尔格的首要任务。\n第2部分.首次币发行（ICO）合同 可能存在许多与首次币发行（ICO）相关的可能情景。在本文中，我们考虑一个首次币发行想要收集至少一定数量的资金（尔格币）来启动项目。一旦超过资金门槛并且资金期结束，该项目就会启动，并且项目将根据所收集的资金总额发放首次币发行的代币。在永久延续的退出阶段，投资者根据他们在融资期间投入的金额撤回首次币发行的代币。下面简要介绍合约步骤，并进一步提供详细信息：\n 首先，融资期开始。它从一个项目币箱开始，对一个空字典进行验证。该词典用于持有（投资者，平衡）对，其中投资者是保护包含退出代币的币箱的脚本。为了平衡，我们假设在ICO期间1个代币等于1个尔格。在融资期，只有将尔格币放入项目的框中才有可能。资金交易花费在项目的框中，并创建一个包含更新信息的新项目框。为此，项目币箱的支出交易还有使投资者撤回脚本的其他输入。应将投资者脚本和输入值添加到新币箱的树中。这将会有许多链式资金交易。 其次，融资期结束，之后持有投资者数据的树变为只读。经过验证的树可以单独允许不同的修改操作：可以禁止插入，删除，更新或所有操作（因此树可以处于只读模式）。此外，此交易还会创建首次币发行项目的代币，该项目将在下一阶段退出。该项目可以在此阶段撤回尔格币。 第三，投资者撤回他们的首次发行币代币。为此，支出交易创建具有保护条件的输出和从树中获取的标记值。撤回的对也从树中清除。可能会有许多链式支出交易。  这三个阶段应按逻辑顺序链接在一起。使用一系列币箱来实现这些目标。\n第3部分.首次币发行合约细节 下面提供ICO合约阶段的细节和尔格脚本代码。\n融资阶段 在先期的融资阶段，我们假设最初项目创建了一个提交到空字典（存储在寄存器R5中）的币箱，其中包含下面描述的一些保护脚本。这个阶段至少持续到2,000高度。更具体地说，高度为2,000或更高的第一个交易应该更改输出币箱的脚本，如下一节所述（较低高度的交易必须输出具有相同脚本的币箱）。\n项目币箱检查它是否始终是交易的第一个输入和输出。 其他输入被视为投资者的输入。 投资者的输入包含寄存器R4中的脚本的哈希。 此哈希表示将在稍后的退出阶段使用的退出脚本。 应将所有投资输入的哈希值和货币值添加到字典中。 支出交易提供了证明投资者数据确实被添加到字典中的证据，并且在合同中检查证明。\n在资助分包合约中没有检查字典是否只允许插入，而不是更新现有值或删除（尽管添加显式检查并不困难）。\n支出交易应该支付费用，否则，它不太可能包含在一个区块中。因此，资助合同检查支出交易有两个输出（一个用于自身，另一个用于支付费用），费用不超过一定限度（在我们的例子中只有一个纳米），并且保护命题应该是这样只有矿工可以花费输出（在我们的例子中，我们只使用来自编译环境的变量“feeProp”而不提供任何细节）。这个“feeProp”对应于一个标准，虽然不是协议所要求的。\n下面的代码强制执行上述条件。请注意，“nextStageScriptHash”（下一步脚本哈希）环境变量包含颁发阶段序列化脚本的哈希值。\nval selfIndexIsZero = INPUTS(0).id == SELF.id val proof = getVar[Coll[Byte]](1).get val inputsCount = INPUTS.size val toAdd: Coll[(Coll[Byte], Coll[Byte])] = INPUTS.slice(1, inputsCount).map({ (b: Box) =\u0026gt; val pk = b.R4[Coll[Byte]].get val value = longToByteArray(b.value) (pk, value) }) val modifiedTree = SELF.R5[AvlTree].get.insert(toAdd, proof).get val expectedTree = OUTPUTS(0).R5[AvlTree].get val properTreeModification = modifiedTree == expectedTree val outputsCount = OUTPUTS.size == 2 val selfOutputCorrect = if(HEIGHT \u0026lt; 2000) { OUTPUTS(0).propositionBytes == SELF.propositionBytes } else { blake2b256(OUTPUTS(0).propositionBytes) == nextStageScriptHash } val feeOutputCorrect = (OUTPUTS(1).value \u0026lt;= 1) \u0026amp;\u0026amp; (OUTPUTS(1).propositionBytes == feeBytes) val outputsCorrect = outputsCount \u0026amp;\u0026amp; feeOutputCorrect \u0026amp;\u0026amp; selfOutputCorrect selfIndexIsZero \u0026amp;\u0026amp; outputsCorrect \u0026amp;\u0026amp; properTreeModification 发行阶段 这个阶段只有一个支出交易进入下一阶段（退出阶段）。支出交易进行以下修改。首先，它将字典上允许的操作列表从“仅插入”改为“仅删除”，因为下一阶段（退出）仅处理从字典中删除条目。\n其次，合同检查是否发行了适当数量的首次币发行的代币。在尔格中，允许每个交易发出一种新的代币，代币的标识符应该等于第一个输入币箱的（唯一）标识符。发行分包合同检查已发出新代币，其金额等于首次币发行迄今为止收集的纳米级数量。\n第三，合约检查支出交易确实正在重新创建具有对应于下一阶段（退出阶段）的保护脚本的币箱。\n最后，项目应该撤回收集的尔格币，当然，每次支出交易都应该支付费用。因此，分包合约检查支出交易确实有3个输出（项目代币币箱，尔格币撤回币箱和费用币箱各一个），并且第一个输出和输出带有发行的代币。由于我们没有指定项目资金撤回细节，我们需要在支出交易上签署项目签名。\nval openTree = SELF.R5[AvlTree].get val closedTree = OUTPUTS(0).R5[AvlTree].get val digestPreserved = openTree.digest == closedTree.digest val keyLengthPreserved = openTree.keyLength == closedTree.keyLength val valueLengthPreserved = openTree.valueLengthOpt == closedTree.valueLengthOpt val treeIsClosed = closedTree.enabledOperations == 4 val tokenId: Coll[Byte] = INPUTS(0).id val tokensIssued = OUTPUTS(0).tokens(0)._2 val outputsCountCorrect = OUTPUTS.size == 3 val secondOutputNoTokens = OUTPUTS(0).tokens.size == 1 \u0026amp;\u0026amp; OUTPUTS(1).tokens.size == 0 \u0026amp;\u0026amp; OUTPUTS(2).tokens.size == 0 val correctTokensIssued = SELF.value == tokensIssued val correctTokenId = OUTPUTS(0).R4[Coll[Byte]].get == tokenId \u0026amp;\u0026amp; OUTPUTS(0).tokens(0)._1 == tokenId val valuePreserved = outputsCountCorrect \u0026amp;\u0026amp; secondOutputNoTokens \u0026amp;\u0026amp; correctTokensIssued \u0026amp;\u0026amp; correctTokenId val stateChanged = blake2b256(OUTPUTS(0).propositionBytes) == nextStageScriptHash val treeIsCorrect = digestPreserved \u0026amp;\u0026amp; valueLengthPreserved \u0026amp;\u0026amp; keyLengthPreserved \u0026amp;\u0026amp; treeIsClosed projectPubKey \u0026amp;\u0026amp; treeIsCorrect \u0026amp;\u0026amp; valuePreserved \u0026amp;\u0026amp; stateChanged 退出阶段 在此阶段，允许投资者撤回受预定义保护脚本（其哈希存储在字典中）保护的项目令牌代币。 退出是按N个数量的批次进行的。因此，撤回交易有N + 2个输出，其中第一个输出优先于提取分包合同和余额标记，最后一个输出支付费用，其余N个输出有根据字典保护脚本和标记值。 合同需要两个字典元素的证明：一个证明要撤回的值确实在字典中，第二个证明得到的字典没有撤销的值。 分包合约如下。\nval removeProof = getVar[Coll[Byte]](2).get val lookupProof = getVar[Coll[Byte]](3).get val withdrawIndexes = getVar[Coll[Int]](4).get val out0 = OUTPUTS(0) val tokenId: Coll[Byte] = SELF.R4[Coll[Byte]].get val withdrawals = withdrawIndexes.map({(idx: Int) =\u0026gt; val b = OUTPUTS(idx) if(b.tokens(0)._1 == tokenId) { (blake2b256(b.propositionBytes), b.tokens(0)._2) } else { (blake2b256(b.propositionBytes), 0L) } }) val withdrawValues = withdrawals.map({(t: (Coll[Byte], Long)) =\u0026gt; t._2}) val withdrawTotal = withdrawValues.fold(0L, { (l1: Long, l2: Long) =\u0026gt; l1 + l2 }) val toRemove = withdrawals.map({(t: (Coll[Byte], Long)) =\u0026gt; t._1}) val initialTree = SELF.R5[AvlTree].get val removedValues = initialTree.getMany(toRemove, lookupProof).map({(o: Option[Coll[Byte]]) =\u0026gt; byteArrayToLong(o.get)}) val valuesCorrect = removedValues == withdrawValues val modifiedTree = initialTree.remove(toRemove, removeProof).get val expectedTree = out0.R5[AvlTree].get val selfTokensCorrect = SELF.tokens(0)._1 == tokenId val selfOutTokensAmount = SELF.tokens(0)._2 val soutTokensCorrect = out0.tokens(0)._1 == tokenId val soutTokensAmount = out0.tokens(0)._2 val tokensPreserved = selfTokensCorrect \u0026amp;\u0026amp; soutTokensCorrect \u0026amp;\u0026amp; (soutTokensAmount + withdrawTotal == selfOutTokensAmount) val properTreeModification = modifiedTree == expectedTree val selfOutputCorrect = out0.propositionBytes == SELF.propositionBytes properTreeModification \u0026amp;\u0026amp; valuesCorrect \u0026amp;\u0026amp; selfOutputCorrect \u0026amp;\u0026amp; tokensPreserved 可能的增强 请注意，我们的示例合约忽略了许多细微差别。 例如，任何听从区块链的人都可以在融资和退出阶段执行合约并构建适当的支出交易。 在现实世界中，可能需要使用来自项目或可信决定者的附加签名。\n此外，在退出合同中没有考虑自毁案件，因此它将一直存在，直到被矿工通过存储租用机制销毁，可能持续数十年甚至数百年。对于融资阶段，从项目中获得额外的输入是合理的，其值等于费用输出的值。 等等。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_04_10-ico-example/","subtitle":null,"title":"一个尔格顶层的首次币发行案例"},{"contents":"概况介绍 挖矿，是指在Ergo区块链上进行一系列资源密集的计算来加入新区块的过程。\nErgo挖矿基于Autolykos, 一个旨在抵抗ASIC超级矿机和矿池的工作量证明（PoW）算法。矿工们要进行内存硬计算（至少需要2GB内存，4-8GB的RAM是目前效率最高的配置）因此Ergo对于GPU挖矿十分友好。此外，Autolykos需要接入私钥，由此防止挖矿池的形成。一旦找到正确的算法，矿工即可散播他的区块（连同算法一起散播），在720个区块后拿到他相应的奖励。余下全网将用该矿工的公钥对该算法进行验证，验证的过程需要较少的内存千字节，效率相当高。\n如何进行Ergo挖矿 Ergo挖矿需要一个配置并同步过的Ergo节点，还有至少一个GPU，来完成实际的PoW计算。当然了，你可以用多个GPU倍增哈希算力，但你仅需一个Ergo节点。\n设置全节点 全节点设置可参见上一个章节（教程一：如何设置全节点）。要支持一个外部矿工，也就是我们会用到的，你的配置文件里要有以下设置：\nergo.node.mining = true ergo.node.useExternalMiner = true 如果你已经有了私钥/公钥对，你可以在节点配置里指定公钥或地址：\nergo.node.miningPubKeyHex = \u0026#34;11aa ... FF\u0026#34; 如果这个参数没出现，节点会采用内置钱包里第一个公钥来为外部矿工生成区块。\n只要节点同步完成，你就完成挖矿的准备工作了。\n设置矿工 警告！ ⚠️ 由于Autolykos要用到私钥，切勿切勿使用非受信任的挖矿软件。一定要检查软件是否开源，是否已被社区认可，这非常重要！\n从以下挖矿软件里安装你的软件：\n CUDA miner (Nvidia GPU only)  挖矿配置文件如下：\n{ \u0026#34;seed\u0026#34;: \u0026#34;注意！！！ 将此替换为您的助记句并保密，否则您将被抢劫\u0026#34;, \u0026#34;node\u0026#34;: \u0026#34;http://188.166.89.71:9052\u0026#34;,\u0026#34;keepPrehash\u0026#34;: false } 定义：\n 种子 是节点配置里的助记句，或是该设置里能为miningPubKeyHex计算私钥的助记句 节点 是您的节点API端口的URL 保留预哈希（keep Prehash）是一个优化参数。如果设定成 true, 矿工会消耗最多8GB内存。如果设定成 false 矿工会消耗最大4GB内存，但其表现也会打25%左右折扣。  现在，用矿机运行指令 ./auto.out config.json (用Linux)，尽情享受区块奖励吧！\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_04_03_mining/","subtitle":null,"title":"如何进行Ergo挖矿"},{"contents":"","link":"https://ergoplatform.org/cn/blog/2019_04_03_mining/","permalink":"https://ergoplatform.org/cn/news/2019-04-03-ergo-mining-tutorial/","subtitle":"通过完成算力密集的计算，向区块链上增加新的区块，这就是Ergo上的挖矿过程","title":"尔格挖矿教程"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.0.3","permalink":"https://ergoplatform.org/cn/news/2019-04-02-testnet-2.0.3/","subtitle":"测试网2.0.3版本正式发布，修复多个已知漏洞，增加支持GPU挖矿功能。","title":"测试链2.0.3发布"},{"contents":"首先，我们有一个重要的公告—如果在审计过程中没有发现安全漏洞，计划于5月26日发布尔格主网！\n关于扩展和应用的愿景是什么？ 关于扩展，主要方法是在不影响功能的情况下避免膨胀。例如。持久可更新存储是可能的，更新由区块链合约检查，但只有验证了的数据结构的摘要（以及一些额外的字节，少于40个字节）存储在UTXO集，这与数据集的大小无关。存储租金有助于清除UTXO设备上的灰尘。轻量客户端：在尔格中，如果你不使用，你可以在不存储UTXO设置的情况下获得全节点保证。这大大改善了boostrapping（机器学习算法）和区块验证时间。通过这些改进，可以在不影响经典区块链假设和保证的情况下提高TPS（透明页共享）。但是你想要具体数字吗？我没有具体数字，因为区块大小等参数不是一成不变的，而是矿工可以调整它们。因此，如果矿工正在经历低的完整区块验证时间（硬件随着时间的推移而变得越来越好，软件也是），他可能会建议或投票来增加区块大小。\n关于应用，我们希望有人追随：1。人们重视系统及其用户之间的社会契约。例如。人们对以太坊分叉不满意。尔格不会有硬件更新功能，而社区可以在很多方面升级协议。 2.由于（1）至少，同时也有限的供应，尔格将作为储值资产（如果您只是在系统中存储硬币，滞期费用很少）。3.需要安全，简单和高效的金融应用的人员。尔格的智能货币概念比以太坊的智能合约简单得多，同时功能强大，足以满足那些没有特定技术开发固态合约的人们的大多数金融应用，或大量资金来雇用熟练的开发人员。 4.还没准备好预测大公司的任何事情，但有些企业已表示有兴趣在尔格之上做一些代币和合约。我们会尽早宣布任何相关事宜。\n有没有示例或用例？ 我们有很多示例，合约：预言机（oracles），众筹，原子交叉链和单链（代币到代币）交换，混合等。 开发人员的尔格脚本教程涵盖了基础信息。\n一个包含更复杂示例的文件（冷钱包，混合，石头剪刀布游戏）即将发布。此外，我们将展示首次币发行场景和LETS系统的示例。 另请参阅\u0026ldquo;为大众提供智能合约\u0026rdquo;博文中的目标小额信贷合约示例。\n您是否有意建立像闪电网络这样的本地链下解决方案？您对社区驱动方案的看法是什么？ 是的，我们希望它们会在某个时刻出现。我们现在的目标是提供尽可能灵活的协议，使其实现变得容易。最重要的是，我们已经有社区成员在尔格之上执行侧链，但这项工作还处于早期阶段。我们支持社区的任何活动，包括侧链。\n哪个区块链项目与尔格类似？ 在某些方面，比特币（软分叉，但我们会更进一步），Coda（如果它是真实的，我仍需检查;轻量客户端），Grin（FlyClient类似于PoPoWs），ZCash（Equihash是类似于我们的工作量证明，但我们的参数更严格，我们的工作量证明是池阻的）。不能像我们的语言一样命名任何其他项目！所以，总的来说，尔格非常独特。\n什么是尔格数据以及它的实际用例是什么？ 主网将在多久之后执行？ 尔格数据计划成为一个具有相同技术的区块链，但不同的参数可满足面向数据的应用需求。现在我们完全专注于在其上推出单链和应用。我认为尔格数据可能会在2到3年后出现，如果需要这样的应用，并且还可能又基于尔格之上的应用限制（特别是数据密集型）。按说，将会有一个侧链。现在这个领域已经有很好的进展，所以到那时我们可能会有无条件好的侧链。\n什么时候开始挖矿？我们可以用cpu挖矿吗？ 当然，您现在可以开始使用CPU进行挖掘。只需使用mining = true config settings设置一个完整节点（查看本指南），您的节点将在初始同步后开始挖矿。可以在此处找到示例配置\n但是我们还没有上主网呢？所以我们只能挖掘测试网硬币？ 是的，你现在只能挖掘测试网硬币。 GPU 矿工绝对可以在主网之前使用（可能是本周或下周）。\n是否有关于如何设置钱包的手册？ 钱包是在主网发布之前应该更新的另一件事，我们会就它的安全设置等提出建议。现在，您只能在设置帖子的配置文件部分2中将助记词设置为纯文本\n运行节点的最低要求是什么？ 这一切都取决于你的节点制度。我们没有精确测量它，我们用4 Gb内存，2个CPU，80 Gb SSD驱动上打开我们的全部节点，但它就像推荐的配置，而不是最小的配置。\n您是否计划与其他平台合作（例如Waves）？哪一种？ 我们计划在Waves DEX上市（这将大大简化EFYT / 尔格币互换），没有计划与平台的其他合作。\n您有计划增加一个选择来生成类似ERC721的代币吗？无法拆分的令牌。 您可以免费为每个交易发行一个代币，因此发行大量代币（最大供应量为1）不是问题。没有标准可以将它们组合成一类相似的代币（没有标准的方法来检查，标记aa \u0026hellip; aa与标记aa...bb具有相同类别的代币），但可能在将来会出现这样的标准。\n是否可以同时播报一批交易？理想情况下，它们包含在同一区块中。 没有API方法可以同时播报批量交易，但没有什么可以阻止您逐个广播它们而没有延迟。因此，同时播报尽可能多的交易不应该是一个问题。理想情况下，它们应包含在同一个区块中 - 可以编写某种合约，确保一些交易包含在一个单一的交易中阻止（或者没有包括它们）但是，我们还没有尝试过。此外，这可能需要矿工具有从内存池收集交易的修改规则。\n是否可以选择使用0值资产发送交易？ 所以代币在交易中，它的数量是0？不，那是不可能的\n是否有选择发送“广告”交易？ 交易的该费用由自定义代币支付。 它可能是使用交换示例完成的，因此您可以创建一个为尔格购买代币的合约，当发件人要发送代币时—他会卖出所需数量的代币并将剩余的代币数量转移到里面一笔交易。\n所以没有办法转移0.0000001的代币？ 尔格中的每个输出都应该包含一定量的尔格币。 交易费用可能为0，但您应该为每个创建的输出放一定数量的尔格币。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_03_19-qa/","subtitle":null,"title":"Alex Chepurnoy 和Dmitry Meshkov的问答"},{"contents":"","link":"/cn/blog/2019_03_19-qa/","permalink":"https://ergoplatform.org/cn/news/2019-03-19/","subtitle":"与开发团队Alex Chepurnoy和Dmitry Meshkov的问答环节笔录","title":"问答环节记录。主链计划于5月26日发布"},{"contents":"节点安全性 为保证您的钱包和资产的安全，请格外注意以下几个节点使用中的注意事项：\n Ergo节点要求在设置文件中存储一定的关键安全参数，因此，切勿泄露您的设置文件。 Ergo节点已为内置钱包的交互提供了REST API（变现层状态转移编程接口）。灵敏API手段需要安全的通证，切勿采取非信任的渠道发送通证。  节点环境设置 您需要安装至少JRE 8.0 版本来运行Ergo节点。安装方法之一是通过Oracle执行的Java。\n设置Ergo节点 当运行环境设置完备，您就可以下载最新版的Ergo客户端（Ergo client release）创建一个设置文件了。至于jar包，不需要单独下载，您只需要用SBT通过sbt assembly指令来克隆一份资源库，就可创建您自己的jar包\n所有的设置参数都可以在默认设置文件（(default configuration file](https://github.com/ergoplatform/ergo/blob/master/src/main/resources/reference.conf)）中找到。在您的设置文件基础上，您只需重写您在默认值基础上想要进行改动的参数即可。比如，在该设置文件样本（sampleconfiguration file）中您可以查看最新的测试网，里面只包含了一些重要的参数。请注意，在这个样本文件中，您必须去除以下几行指令：\ntestMnemonic = ... testKeysQty = ... 现在，我们来运行下面几个重要步骤： 、设置一个API密钥： 设置API端口密钥。要想设置钱包，您需要先通过节点设置文件来设置apiKeyHash参数，参见此处。文件中要编辑替换：\njavascript scorex.restApi.apiKeyHash = \u0026quot;replace_this_with_your_unique_api_key_hash\u0026quot; \n替换值是在运行您的API请求时生成的密码字符，是一串hex加密Blake2b256哈希数值。您可以使用这个脚本或任意其他脚本来计算blake2b哈希值。密码字符应该是一串随机字符，请务必保管妥善，切勿发给任何非信任方。 这个REST API终端也提供了一个（不受保护的）哈希计算办法：\n/utils/hashBlake2b\n初始化钱包： 这里就用到了前一个步骤提及的API端口密钥。第一次运行节点时，需要先通过REST API对钱包进行初始化，有两个办法可以做到：\n  从头初始化（节点会生成一个种子文件）：向/wallet/init发送一个包含数据body: {\u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;, \u0026quot;mnemonicPass\u0026quot;: \u0026quot;abc\u0026quot;}的POST请求（提示：别忘了保存下来助记词，节点响应要用到。请求中的mnemonicPass参数是可选项，它用来保护助记词）\n  从已有种子文件恢复钱包：该方法需要您提供助记词。向/wallet/restore发送一个包含数据body: {\u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;, \u0026quot;mnemonic\u0026quot;: \u0026quot;abandon abandon ...\u0026quot;, \u0026quot;mnemonicPass\u0026quot;: “abc”}的POST请求（提示：mnemonicPass部分只有在您的助记词有额外密码保护的情况下才用得到）。\n  解锁钱包： 钱包初始化之后，向/wallet/unlock发送一个包含数据body: {\u0026quot;pass\u0026quot;: “123”}的POST请求（提示：使用您在初始阶段用的密码）\n更多关于钱包的细节描述，请查看此处。\n运行Ergo节点 用ergo-assembly-\u0026lt;version\u0026gt;.jar二进制和ergo.conf设置文件运行节点：\n$ java -jar ergo-assembly-\u0026lt;version\u0026gt;.jar ergo.conf 为确保节点在运行，在浏览器里打开127.0.0.1:9052/info这里会显示关于节点的相关信息。\n使用REST API 节点会提供REST API（相关描述） 您可以用Swagger来完成API请求，访问127.0.0.1:9052/swagger。API完整说明可以在这里找到。要接入受保护的API端口路径，需把您在前面步骤创建的密码字符，输入到[api_key, Content-Type]部分，或者点Swagger里的Authorize按键然后键入您的密码字符。\n关闭控制端打印Console Printing 默认情况下，Ergo节点会打印大量排错信息，这个功能可以关闭，在src/main/resources里编辑logback.xml，然后重新编译（或直接在jar包里编辑XML文件）。编辑以下指令：\n\u0026lt;root level=\u0026#34;WARN\u0026#34;\u0026gt; \u0026lt;!-- other options are TRACE, ERROR --\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34;/\u0026gt; \u0026lt;!-- remove this line to disable all printing --\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; 或者也可以在运行节点时设置想要的参数，如：\njava -jar ergo-assembly-\u0026lt;version\u0026gt;.jar ergo.conf -Dlogback.stdout.level = ERROR ","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_03_17_how_to_set/","subtitle":null,"title":"如何创建跟设置Ergo全节点"},{"contents":"","link":"https://ergoplatform.org/cn/blog/2019_03_17_how_to_set/","permalink":"https://ergoplatform.org/cn/news/2019-03-17-how-to-set-up-full-node/","subtitle":"教学：如何安装及配置Ergo节点","title":"如何设置和配置尔格全节点"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.0.0","permalink":"https://ergoplatform.org/cn/news/2019-03-14/","subtitle":"Ergo上线前的里程碑！主要性能已全部实现，现进入调试阶段，只剩进行性能优化及安全审计等最后调试。至此，平台与主网二进制兼容，快来Ergo上开发你的Dapp吧！","title":"侧链2.0已发布！智能合约语言已更新"},{"contents":"如今，很多与区块链相关的新闻都在告诉我们，银行X或Y公司将使用“区块链”来“降低成本”。基本上，这意味着大银行家认为另一个流行术语只是另一种以更有效的方式从某处提取价值的工具，也可以通过裁员来节省成本。\n虽然我不想对“Satoshi的愿景”说什么（他离开后只能去猜测），但我在网络论坛用户早期见证下的广泛观点是加密货币应该提供能使普通人变得富裕的工具，他们的小企业背后提供的不是生活收入，而不是非个人化的大金融资本。从最初广泛的社区愿景看来，加密货币的工具应该允许人们进行经济活动，而不依赖于业务规模，地理位置，大公司设定的利率等等。这些工具应该允许人们签订合同（没有纸质合约，而是数字化，自我执行和合理智能的合约），这取决于司法管辖区，传统，遵循商业惯例等方面的差异。\n我希望尔格在这方面发挥作用。成千上万的小型合作社和个体企业家对全球健康和可持续的财富增长更为重要，而不是几家公司在离岸天堂中牟利。\n例如，让我们考虑一个合作联盟（如Radical Routes激进路线），愿意为数千公里以外的企业家提供经济援助（例如，在Rojava）。\n我们现在需要假设一些细节。首先，假设网络中有四个合作社。他们在合约中共同锁定10,000 个尔格币（均分四等份，即每份2,500个尔格币），其中说明如下：\n 合作社与公钥pubkeyA，pubkeyB，pubkeyC，pubkeyD相关联。企业家与公钥businessKey关联。 合作社将资金锁定在受融资合约保护的硬币中，然后进行尽职调查，并就是否为企业家提供资金进行投票。所有合约基金（10,000个尔格币）都是给企业家的，如果4个中有3个投了票的话。从技术上讲，投票是通过3/4阈值签名完成的。如果在区块编号1,000之前投票不成功（没有达到3/4的签名），任何合作社（实际上，任何人）都可以提交撤销交易，这将向每个合作社返回2,500个尔格币（至少）。此外，融资合同也将被称为投票合同。 投资可以花在三个目标上，并且有一些严格的限制。也就是说，企业家必须在设备上花费至少5,000个尔格币，在建造所需建筑时至少需要2,000个尔格币，企业家可能会随意花费其他资金。 为了确保设备资金将用于设备，合作社联合会使用企业家领域中已知设备销售商的公钥。例如，考虑设备销售商在该区域中使用公钥pubkeyTool1，pubkeyTool2，pubkeyTool3，pubkeyTool4。从技术上讲，转移是作为一个设备销售商的集体签名组织的（因此来自设备销售商的环签名和企业家的签名） 类似地，假设合作联盟中有3个创建者正在识别，与公钥pubkeyConstr1，pubkeyConstr2和pubkeyConstr3相关联。 与投票合约类似，如果设备和建设合约在5000号区块之前没有共同签署，联合合作社可以撤回资金。  在尔格中定义合约的方法有很多种。 低级语言尔格树中的一个脚本描述了一个（单个）逻辑条件，关于是否可以根据它使用硬币，以及支出交易提供的支出证明。 在内部，条件表示为类型化语法树这一名称。 该结构允许我们进行提前成本分析等。名为尔格脚本的高级语言允许具有更传统和可读的描述，使用变量并将逻辑分解为子程序。\n让我们从上面（1-3）中定义的主合约开始：\n{ val spendingSuccess = (pubkeyTool1 || pubkeyTool2 || pubkeyTool3 || pubkeyTool4) \u0026amp;\u0026amp; businessKey val withdrawCondition = HEIGHT \u0026gt; 5000L \u0026amp;\u0026amp; OUTPUTS(0).value \u0026gt;= 1250L \u0026amp;\u0026amp; OUTPUTS(0).propositionBytes == pubkeyA.propBytes \u0026amp;\u0026amp; OUTPUTS(1).value \u0026gt;= 1250L \u0026amp;\u0026amp; OUTPUTS(1).propositionBytes == pubkeyB.propBytes \u0026amp;\u0026amp; OUTPUTS(2).value \u0026gt;= 1250L \u0026amp;\u0026amp; OUTPUTS(2).propositionBytes == pubkeyC.propBytes \u0026amp;\u0026amp; OUTPUTS(3).value \u0026gt;= 1250L \u0026amp;\u0026amp; OUTPUTS(3).propositionBytes == pubkeyD.propBytes spendingSuccess || withdrawCondition } 尔格脚本中的这个脚本将通过与变量的具体值（pubkeyA，pubkeyB，pubkeyC，pubkeyD，spendContract1Hash，spendContract2Hash）绑定，编译成语法树（以序列化形式写入区块链）。 spendContract1Hash是（序列化）设备支出脚本的哈希，将在下面提供具体脚本，spendContract2Hash是一个建造支出脚本的哈希。\n设备支出脚本如下：\n{ val spendingSuccess = (pubkeyConstr1 || pubkeyConstr2 || pubkeyConstr3) \u0026amp;\u0026amp; businessKey val withdrawCondition = HEIGHT \u0026gt; 5000L \u0026amp;\u0026amp; OUTPUTS(0).value \u0026gt;= 500L \u0026amp;\u0026amp; OUTPUTS(0).propositionBytes == pubkeyA.propBytes \u0026amp;\u0026amp; OUTPUTS(1).value \u0026gt;= 500L \u0026amp;\u0026amp; OUTPUTS(1).propositionBytes == pubkeyB.propBytes \u0026amp;\u0026amp; OUTPUTS(2).value \u0026gt;= 500L \u0026amp;\u0026amp; OUTPUTS(2).propositionBytes == pubkeyC.propBytes \u0026amp;\u0026amp; OUTPUTS(3).value \u0026gt;= 500L \u0026amp;\u0026amp; OUTPUTS(3).propositionBytes == pubkeyD.propBytes spendingSuccess || withdrawCondition } 现在假设合作联盟创建了一个受投票合约保护的硬币。以下是企业家如何开展业务：\n 创建一个消耗硬币并创建至少三个硬币的交易，一个与设备支出合同，另一个与建筑支出合同，第三个是创建由企业家的公钥保护的硬币。 将交易发送给合作社，等待交易，并在区块链上发布阈值签名输入。 考虑与设备销售商签订合同，共同签署支出交易。 考虑与建筑商签订合同，共同签署支出交易。  企业家可以轻松逃离而不做任何业务，但不超过3,000尔格币。这可以是固定的，例如这笔钱只能在5000数量的区块之后才能消费，之前合作社可以提取这笔钱。对于设备和建筑支出，企业家正在与一些可能已经声誉良好的企业合作。这样投资者就能降低风险。\n您可以在线查找代码和示例交易。请注意，我们有更多复杂签名方案的例子，多步合约（具有在线执行路径显示，比如比特币中的MAST，但允许循环），oracles（数据库），众筹等等。请查看我们的示例库。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2018_10_19-smart-contracts/","subtitle":null,"title":"为客户提供智能合约"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/search/","subtitle":"Search page","title":"Search"}]